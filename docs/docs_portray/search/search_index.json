{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pydoc_fork A fork of pydoc to optimize it for generating, on a build server, html documentation for a python library you wrote Less ambitious than the very good pdoc3 and easier to use than Sphinx Installation Requires Python 3.6+, according to vermin pip install pydoc_fork # or virtual environment access pipenv install pydoc_fork # WARNING - installation by pipx will only allow for doc generation of the python standard library ! pipx install pydoc_fork Usage # Generate HTML for all modules and submodules from source code > pydoc_fork my_module -- output docs -- document_internals # Generate HTML for a module that is importable , e . g . sys > pydoc_fork sys -- output docs Docs Motivation Prior Art TODO pydoc_fork documented in several ways: pydoc_fork Pycco PyDoctor pdoc3 mkdocstrings sphinx Credits Forked from python 3.10. https://github.com/python/cpython/blob/3.10/Lib/pydoc.py That code is governed by this license https://github.com/python/cpython/blob/main/LICENSE I picked a MIT license, but I'm no lawyer, the cpython license probably governs in any conflict.","title":"Home"},{"location":"#pydoc_fork","text":"A fork of pydoc to optimize it for generating, on a build server, html documentation for a python library you wrote Less ambitious than the very good pdoc3 and easier to use than Sphinx","title":"pydoc_fork"},{"location":"#installation","text":"Requires Python 3.6+, according to vermin pip install pydoc_fork # or virtual environment access pipenv install pydoc_fork # WARNING - installation by pipx will only allow for doc generation of the python standard library ! pipx install pydoc_fork","title":"Installation"},{"location":"#usage","text":"# Generate HTML for all modules and submodules from source code > pydoc_fork my_module -- output docs -- document_internals # Generate HTML for a module that is importable , e . g . sys > pydoc_fork sys -- output docs","title":"Usage"},{"location":"#docs","text":"Motivation Prior Art TODO","title":"Docs"},{"location":"#pydoc_fork-documented-in-several-ways","text":"pydoc_fork Pycco PyDoctor pdoc3 mkdocstrings sphinx","title":"pydoc_fork documented in several ways:"},{"location":"#credits","text":"Forked from python 3.10. https://github.com/python/cpython/blob/3.10/Lib/pydoc.py That code is governed by this license https://github.com/python/cpython/blob/main/LICENSE I picked a MIT license, but I'm no lawyer, the cpython license probably governs in any conflict.","title":"Credits"},{"location":"docs/CHANGES/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [3.1.3] - 2021-11-18 Fixed pydoc_fork can build basic docs from source Fix README.MD so it looks good on pypi [3.1.4] - 2021-11-26 Fixed documents all references by default documents stdlib in pydoc style by default almost html 5, use jinja some suppress typing module cruft by default","title":"Changes"},{"location":"docs/CHANGES/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"docs/CHANGES/#313-2021-11-18","text":"","title":"[3.1.3] - 2021-11-18"},{"location":"docs/CHANGES/#fixed","text":"pydoc_fork can build basic docs from source Fix README.MD so it looks good on pypi","title":"Fixed"},{"location":"docs/CHANGES/#314-2021-11-26","text":"","title":"[3.1.4] - 2021-11-26"},{"location":"docs/CHANGES/#fixed_1","text":"documents all references by default documents stdlib in pydoc style by default almost html 5, use jinja some suppress typing module cruft by default","title":"Fixed"},{"location":"docs/TODO/","text":"What pydoc does well Pydoc excels at: - giving you consistent documentation for everything - your code - standard lib code (except when it links to external) - 3rd package code - (will have) switch to document only own code Real world documentation comes wildly different formats, missing, all over the place. TODO: https://pypi.org/project/docstring-parser/ FEATURE: pydoc_fork --path . pydoc_fork --path foo.py pydoc_fork --dot_path foo.bar pydoc_fork --package bs4 bug: when folder is empty, still pulls in site and dependencies (how?!) need clean folder option bug, writes . folder as ..html bug, misleading message if you omit --output folder irritation, no abbreviation for --output just copy pdoc, pydoc or the likes extension switches Detect MD or RST & format as such Separate \"document source code at this path\" from \"document this imported type/module\" eg: pydoc_fork foo.bar pydoc_fork c:/src/foo/bar.py copy source to target folder...using pycco! index page Surface all settings in cmd switchs or yaml config or pyproject.toml config DONE font tags in JINJA. DONE.Now HTML 4.5 Option to walk the module tree (to some specified depth) DONE...? https://stackoverflow.com/questions/48000761/list-submodules-of-a-python-module suppress typing/annotation cruft- DONE! font tags in .py code - DONE Just enough jinja to fix the HTML- DONE heading, page, section are templates rip out web server and browser. DONE rip out the plain text (console) generator. DONE rip out interactive text (console) code. DONE rip out most arg parser logic. DONE Make path relative for source file links. DONE Allow specifiying output folders. DONE Allow just doing one folder module and subs. DONE Allow documenting more than __all__ . DONE. \"document internals\" flag Add more documentaion scenarios Pull in some unit tests. DONE. Could hardly salvage any. Link built ins to main doc site (or give option to generate). DONE Double encoding (in unit tests flag HTML escape codes for \"greater than\"?). Fixed 1. Links to stdlib documentation work again Now attempts to doc import foo modules Now shows from foo import bar functions MAYBE Not sure I can pull in the tests https://github.com/python/cpython/blob/3.10/Lib/test/test_pydoc.py","title":"Todo"},{"location":"docs/TODO/#what-pydoc-does-well","text":"Pydoc excels at: - giving you consistent documentation for everything - your code - standard lib code (except when it links to external) - 3rd package code - (will have) switch to document only own code Real world documentation comes wildly different formats, missing, all over the place.","title":"What pydoc does well"},{"location":"docs/TODO/#todo","text":"https://pypi.org/project/docstring-parser/ FEATURE: pydoc_fork --path . pydoc_fork --path foo.py pydoc_fork --dot_path foo.bar pydoc_fork --package bs4 bug: when folder is empty, still pulls in site and dependencies (how?!) need clean folder option bug, writes . folder as ..html bug, misleading message if you omit --output folder irritation, no abbreviation for --output just copy pdoc, pydoc or the likes extension switches Detect MD or RST & format as such Separate \"document source code at this path\" from \"document this imported type/module\" eg: pydoc_fork foo.bar pydoc_fork c:/src/foo/bar.py copy source to target folder...using pycco! index page Surface all settings in cmd switchs or yaml config or pyproject.toml config","title":"TODO:"},{"location":"docs/TODO/#done","text":"font tags in JINJA. DONE.Now HTML 4.5 Option to walk the module tree (to some specified depth) DONE...? https://stackoverflow.com/questions/48000761/list-submodules-of-a-python-module suppress typing/annotation cruft- DONE! font tags in .py code - DONE Just enough jinja to fix the HTML- DONE heading, page, section are templates rip out web server and browser. DONE rip out the plain text (console) generator. DONE rip out interactive text (console) code. DONE rip out most arg parser logic. DONE Make path relative for source file links. DONE Allow specifiying output folders. DONE Allow just doing one folder module and subs. DONE Allow documenting more than __all__ . DONE. \"document internals\" flag Add more documentaion scenarios Pull in some unit tests. DONE. Could hardly salvage any. Link built ins to main doc site (or give option to generate). DONE Double encoding (in unit tests flag HTML escape codes for \"greater than\"?). Fixed 1. Links to stdlib documentation work again Now attempts to doc import foo modules Now shows from foo import bar functions","title":"DONE"},{"location":"docs/TODO/#maybe","text":"Not sure I can pull in the tests https://github.com/python/cpython/blob/3.10/Lib/test/test_pydoc.py","title":"MAYBE"},{"location":"docs/contributing/","text":"Building pipenv install --dev --skip-lock nb package Some dependencies are expected to be pipx installed globally on the machine, e.g. pylint Testing Testing requires live modules. Scenarios - Pipx installed. Target in file system, installed packages or system. - Pipenv installed - Target in file system - In vs not in /src/ folder - On some entirely different path - Target in virtual environment or system python - Target is system python - Target is self (pydoc_fork) - Mentioning because pydoc itself has code to handle documenting pydoc.","title":"Contributing"},{"location":"docs/contributing/#building","text":"pipenv install --dev --skip-lock nb package Some dependencies are expected to be pipx installed globally on the machine, e.g. pylint","title":"Building"},{"location":"docs/contributing/#testing","text":"Testing requires live modules. Scenarios - Pipx installed. Target in file system, installed packages or system. - Pipenv installed - Target in file system - In vs not in /src/ folder - On some entirely different path - Target in virtual environment or system python - Target is system python - Target is self (pydoc_fork) - Mentioning because pydoc itself has code to handle documenting pydoc.","title":"Testing"},{"location":"docs/feature_clusters/","text":"object tree walking Live code vs static source code- Some members of objects only appear after code is run Some members are noise (e.g. all the __str__ things) Retrofitting scope onto a scopeless language Is the _underscore public or private? Is stuff not in __all__ public or private? Is the audience someone who wants to maintain the code (must understand it all) or use the public interface HTML generation Templating strategy (python strings or mako or jinja) Customizable templates Customization points Config file or switches to turn on various featurs or shape them Markup language ad hoc (pydoc) Well known (rst, md, google-style guidelines) API first or hand written sphinx, mkdocs favors handwritten docs pdoc, pydoc, etc favor all machine written (except text in source files) Validation and linting Errors and warnings on generation Linters, e.g. pydocstyle","title":"Feature Clusters"},{"location":"docs/feature_clusters/#object-tree-walking","text":"Live code vs static source code- Some members of objects only appear after code is run Some members are noise (e.g. all the __str__ things)","title":"object tree walking"},{"location":"docs/feature_clusters/#retrofitting-scope-onto-a-scopeless-language","text":"Is the _underscore public or private? Is stuff not in __all__ public or private? Is the audience someone who wants to maintain the code (must understand it all) or use the public interface","title":"Retrofitting scope onto a scopeless language"},{"location":"docs/feature_clusters/#html-generation","text":"Templating strategy (python strings or mako or jinja) Customizable templates","title":"HTML generation"},{"location":"docs/feature_clusters/#customization-points","text":"Config file or switches to turn on various featurs or shape them","title":"Customization points"},{"location":"docs/feature_clusters/#markup-language","text":"ad hoc (pydoc) Well known (rst, md, google-style guidelines)","title":"Markup language"},{"location":"docs/feature_clusters/#api-first-or-hand-written","text":"sphinx, mkdocs favors handwritten docs pdoc, pydoc, etc favor all machine written (except text in source files)","title":"API first or hand written"},{"location":"docs/feature_clusters/#validation-and-linting","text":"Errors and warnings on generation Linters, e.g. pydocstyle","title":"Validation and linting"},{"location":"docs/motivation/","text":"Motivation Pydoc appears to have been pulled in five directions without the input of a product manager. It is a mishmash of intentions: the help() function that spits out the doc string for a type a plaintext in-console manpage-like documentation browser basic documentation search html templating with no separation between logic and UI code a customized web server/web application inspection/reflection code to support it all I think it should be a html documentation generator alone. There is another tool, pdoc that appears to be written from scratch. This will keep the intention of the html generator. Path vs type confusion import \"foo.bar\" import foo <-- a Module on the Pythonpath import \".\" <-- But gets confused uses \".\" import \"foo \\\\ \" <-- weird syntax meant Path * import foo.py <-- Path import foo <-- Folder on the Path import / src / foo <-- Path import .. / foo <-- Path Pydoc Bugs Can't specify module plus submodules (limitations to .// option) Can't do relative paths (404s if you move folders) Can't specify host url for builtins (404s) Can't specify output folder (paths break if you copy files)","title":"Motivation"},{"location":"docs/motivation/#motivation","text":"Pydoc appears to have been pulled in five directions without the input of a product manager. It is a mishmash of intentions: the help() function that spits out the doc string for a type a plaintext in-console manpage-like documentation browser basic documentation search html templating with no separation between logic and UI code a customized web server/web application inspection/reflection code to support it all I think it should be a html documentation generator alone. There is another tool, pdoc that appears to be written from scratch. This will keep the intention of the html generator.","title":"Motivation"},{"location":"docs/motivation/#path-vs-type-confusion","text":"import \"foo.bar\" import foo <-- a Module on the Pythonpath import \".\" <-- But gets confused uses \".\" import \"foo \\\\ \" <-- weird syntax meant Path * import foo.py <-- Path import foo <-- Folder on the Path import / src / foo <-- Path import .. / foo <-- Path","title":"Path vs type confusion"},{"location":"docs/motivation/#pydoc-bugs","text":"Can't specify module plus submodules (limitations to .// option) Can't do relative paths (404s if you move folders) Can't specify host url for builtins (404s) Can't specify output folder (paths break if you copy files)","title":"Pydoc Bugs"},{"location":"docs/prior_art/","text":"Prior Art I'm strictly thinking of tools that turn python code into some sort of documentation, usually based on the docstrings and object hierarchy. Out of scope are manpage documentation generators. Docstrings are covered by a PEP, PEP-257 There are many styles of \"markup\" for a docstring Google Style RST Style , used by Sphyix Epydoc Markdown Standard library pydoc recognizes none of those. Kinds of Generators Live code to documentation (pydoc) Source code to documentation (pdoc3) (possibly some overlap with live code generators) Markup-to-html generators with API plugins (sphinx, mkdocs) These tools assume you write documents by hand first, and as an afterthought add an API docs generator Markdown first (mkdocs, handsdown) Souce code prettifiers (pycco, pygmentize) For people who need to understand the code (as opposed to just the public API) Abstract model generators (pytkdocs) that create JSON or the like from source Multilangage generator (doxygen) Generators LazyDocs - API centric. Generates Markdown. pytkdocs - Extracts docstrings to json. This is what should have been in the standard library portray - pycco - Literate programming style handsdown - markdown first style Docutils - RST generator Sphinx - RST generator (needs plugin) Sphinx plugins sphinx-apidoc autoapi Linters Pydocstyle - Not sure what style this is validating. Interogate - Fine grained rules on what to document, e.g. skip property getters/setters Pylint Has some rules to require docstrings flake8-docstrings Lint according to a chosen syntax flake8-rst-docstrings Formatters blacken-docs Formats code examples in docstrings IDE Pycharm Ctrl-Q Pycharm Docutil RST compilation Pycharm Sphinx RST compilation VSCode generator - https://pythonrepo.com/repo/NilsJPWerner-autoDocstring-python-documentation to review - - https://github.com/twisted/pydoctor","title":"Prior Art"},{"location":"docs/prior_art/#prior-art","text":"I'm strictly thinking of tools that turn python code into some sort of documentation, usually based on the docstrings and object hierarchy. Out of scope are manpage documentation generators. Docstrings are covered by a PEP, PEP-257 There are many styles of \"markup\" for a docstring Google Style RST Style , used by Sphyix Epydoc Markdown Standard library pydoc recognizes none of those.","title":"Prior Art"},{"location":"docs/prior_art/#kinds-of-generators","text":"Live code to documentation (pydoc) Source code to documentation (pdoc3) (possibly some overlap with live code generators) Markup-to-html generators with API plugins (sphinx, mkdocs) These tools assume you write documents by hand first, and as an afterthought add an API docs generator Markdown first (mkdocs, handsdown) Souce code prettifiers (pycco, pygmentize) For people who need to understand the code (as opposed to just the public API) Abstract model generators (pytkdocs) that create JSON or the like from source Multilangage generator (doxygen)","title":"Kinds of Generators"},{"location":"docs/prior_art/#generators","text":"LazyDocs - API centric. Generates Markdown. pytkdocs - Extracts docstrings to json. This is what should have been in the standard library portray - pycco - Literate programming style handsdown - markdown first style Docutils - RST generator Sphinx - RST generator (needs plugin)","title":"Generators"},{"location":"docs/prior_art/#sphinx-plugins","text":"sphinx-apidoc autoapi","title":"Sphinx plugins"},{"location":"docs/prior_art/#linters","text":"Pydocstyle - Not sure what style this is validating. Interogate - Fine grained rules on what to document, e.g. skip property getters/setters Pylint Has some rules to require docstrings flake8-docstrings Lint according to a chosen syntax flake8-rst-docstrings","title":"Linters"},{"location":"docs/prior_art/#formatters","text":"blacken-docs Formats code examples in docstrings","title":"Formatters"},{"location":"docs/prior_art/#ide","text":"Pycharm Ctrl-Q Pycharm Docutil RST compilation Pycharm Sphinx RST compilation VSCode generator - https://pythonrepo.com/repo/NilsJPWerner-autoDocstring-python-documentation","title":"IDE"},{"location":"docs/prior_art/#to-review","text":"- - https://github.com/twisted/pydoctor","title":"to review"},{"location":"docs/usage/","text":"Pydoc's Adhoc Markup Supports - PEP links - RFC links - Arbitrary links - __doc__ on most types - suppression on _name Pydoc_Fork's \"markup language\" Supports (soon?) - Assuming markup language for all - Guessing markup language Adding __doc__ to dynamic things Slots - https://stackoverflow.com/questions/39171672/adding-docstring-to-slots-descriptor Conditional Implementation - https://stackoverflow.com/questions/57274925/documenting-a-module-interface-with-multiple-implementations Inheritence https://pypi.org/project/docstring-inheritance/","title":"Usage"},{"location":"docs/usage/#pydocs-adhoc-markup","text":"Supports - PEP links - RFC links - Arbitrary links - __doc__ on most types - suppression on _name","title":"Pydoc's Adhoc Markup"},{"location":"docs/usage/#pydoc_forks-markup-language","text":"Supports (soon?) - Assuming markup language for all - Guessing markup language Adding __doc__ to dynamic things Slots - https://stackoverflow.com/questions/39171672/adding-docstring-to-slots-descriptor Conditional Implementation - https://stackoverflow.com/questions/57274925/documenting-a-module-interface-with-multiple-implementations Inheritence https://pypi.org/project/docstring-inheritance/","title":"Pydoc_Fork's \"markup language\""},{"location":"docs/workflows/","text":"Documentation workflows Docs first Write a collection of markup files, refer to code as appropriate. Code First Write documentation in comments, write stand-alone documents as appropriate. Code First build Before: shit = None \"\"\"String representation of hits\"\"\" After, fix names, annotate, docstrings: hits : Optional [ str ] = None \"\"\"Player hit points\"\"\" Fix identifier names. Good names should make documentation less important. Add annotations. Tools can automatically add type annotations. Mypy checks if types are correct. Build Script Steps: - Annotate - Validate annotations (mypy) - Auto-comment (tools?) - Lint comments - Generate - Publish/Host - If Markdown and Github, source repo is the host - If html, use Github pages or the like - If read-the-docs, then ....","title":"Workflows"},{"location":"docs/workflows/#documentation-workflows","text":"","title":"Documentation workflows"},{"location":"docs/workflows/#docs-first","text":"Write a collection of markup files, refer to code as appropriate.","title":"Docs first"},{"location":"docs/workflows/#code-first","text":"Write documentation in comments, write stand-alone documents as appropriate.","title":"Code First"},{"location":"docs/workflows/#code-first-build","text":"Before: shit = None \"\"\"String representation of hits\"\"\" After, fix names, annotate, docstrings: hits : Optional [ str ] = None \"\"\"Player hit points\"\"\" Fix identifier names. Good names should make documentation less important. Add annotations. Tools can automatically add type annotations. Mypy checks if types are correct.","title":"Code First build"},{"location":"docs/workflows/#build-script","text":"Steps: - Annotate - Validate annotations (mypy) - Auto-comment (tools?) - Lint comments - Generate - Publish/Host - If Markdown and Github, source repo is the host - If html, use Github pages or the like - If read-the-docs, then ....","title":"Build Script"},{"location":"reference/pydoc_fork/","text":"Module pydoc_fork Generate Python documentation in HTML. None View Source \"\"\"Generate Python documentation in HTML.\"\"\" # __all__ = ['help'] __author__ = \"Ka-Ping Yee <ping@lfw.org>\" __date__ = \"26 February 2001\" __credits__ = \"\"\"Guido van Rossum, for an excellent programming language. Tommy Burnette, the original creator of manpy. Paul Prescod, for all his work on onlinehelp. Richard Chamberlain, for the first implementation of textdoc. \"\"\" # Known bugs that can't be fixed here: # - synopsis() cannot be prevented from clobbering existing # loaded modules. # - If the __file__ attribute on a module is a relative path and # the current directory is changed with os.chdir(), an incorrect # path will be displayed. from pydoc_fork.commands import * # noqa # from pydoc_fork.formatter_html import * # noqa # from pydoc_fork.module_utils import * # noqa # from pydoc_fork.path_utils import * # noqa # from pydoc_fork.string_utils import * # noqa # from pydoc_fork.utils import * # noqa # forgot why I needed this # __spec__ = \"123\" # noqa Sub-modules pydoc_fork.commands pydoc_fork.inspector pydoc_fork.reporter pydoc_fork.settings","title":"Index"},{"location":"reference/pydoc_fork/#module-pydoc_fork","text":"Generate Python documentation in HTML. None View Source \"\"\"Generate Python documentation in HTML.\"\"\" # __all__ = ['help'] __author__ = \"Ka-Ping Yee <ping@lfw.org>\" __date__ = \"26 February 2001\" __credits__ = \"\"\"Guido van Rossum, for an excellent programming language. Tommy Burnette, the original creator of manpy. Paul Prescod, for all his work on onlinehelp. Richard Chamberlain, for the first implementation of textdoc. \"\"\" # Known bugs that can't be fixed here: # - synopsis() cannot be prevented from clobbering existing # loaded modules. # - If the __file__ attribute on a module is a relative path and # the current directory is changed with os.chdir(), an incorrect # path will be displayed. from pydoc_fork.commands import * # noqa # from pydoc_fork.formatter_html import * # noqa # from pydoc_fork.module_utils import * # noqa # from pydoc_fork.path_utils import * # noqa # from pydoc_fork.string_utils import * # noqa # from pydoc_fork.utils import * # noqa # forgot why I needed this # __spec__ = \"123\" # noqa","title":"Module pydoc_fork"},{"location":"reference/pydoc_fork/#sub-modules","text":"pydoc_fork.commands pydoc_fork.inspector pydoc_fork.reporter pydoc_fork.settings","title":"Sub-modules"},{"location":"reference/pydoc_fork/commands/","text":"Module pydoc_fork.commands Process commands as pure python functions. All the CLI logic should be handled in main . View Source \"\"\"Process commands as pure python functions. All the CLI logic should be handled in __main__. \"\"\" import logging import os import pkgutil from shutil import copy2 from typing import List , Optional , Union import os . path import glob from pydoc_fork import settings from pydoc_fork . inspector . custom_types import TypeLike from pydoc_fork . inspector . module_utils import ImportTimeError from pydoc_fork . inspector . path_utils import _ adjust_cli_sys_path , locate_file from pydoc_fork . inspector . utils import describe , resolve from pydoc_fork . reporter . format_page import render LOGGER = logging . getLogger ( __ name__ ) def document_one ( thing : Union [ TypeLike , str ], output_folder: str , force_load: bool = False , ) -> Optional [ str ] : \"\"\"Write HTML documentation to a file in the current directory.\"\"\" try : the_object , name = resolve ( thing , force_load ) except ( ImportError , ImportTimeError ) : LOGGER . warning ( f \"document_one failed for {str(thing)} with folder {output_folder}\" ) return None # MR # should go in constructor , but what? no constructor settings . OUTPUT_FOLDER = output_folder page_out = render ( describe ( the_object ), the_object , name ) # MR output_folder + os . sep full_path = calculate_file_name ( name , output_folder ) with open ( full_path , \"w\" , encoding= \"utf-8\" ) as file : file . write ( page_out ) print ( \"wrote\" , name + \".html\" ) return full_path # except ( ImportError , ErrorDuringImport ) as value : # print ( value ) # return \"\" def calculate_file_name ( name : str , output_folder: str ) -> str : \"\"\"Returns name. If this was written, what would its name be\"\"\" name = ( name . replace ( \"<\" , \"\" ) . replace ( \">\" , \"\" ) . replace ( \":\" , \"\" ) . replace ( \",\" , \"_\" ) . replace ( \" \" , \"_\" ) . replace ( \"(\" , \"\" ) . replace ( \")\" , \"\" ) ) full_path = output_folder + os . sep + name + \".html\" return full_path def modules_in_current () -> List [ str ] : \"\"\"Convert . shortcut into list of modules\"\"\" current = os . getcwd () files = glob . glob ( os . path . join ( os . path . dirname ( current ), \"*.py\" )) py_files = [ os . path . basename ( f )[:- 3 ] for f in files if os . path . isdir ( f )] folders = glob . glob ( os . path . join ( os . path . dirname ( current ), \"*.py\" )) py_folders = [ os . path . basename ( f ) for f in folders if os . path . isdir ( f )] found = py_files + py_folders LOGGER . debug ( f \"Adding these modules from current folder to document {found}\" ) return found def write_docs_per_module ( modules : List [ str ], output_folder: str , skip_if_written: bool = False , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" if \".\" in modules : modules . extend ( modules_in_current ()) # This is going to handle filesystem paths , e . g . . / module / submodule . py # There will be ANOTHER method to handle MODULE paths , e . g . module . submodule \" # Attempting to mix these two types is a bad idea. written: List[str] = [] for module in modules: # file if module.lower().endswith(\" . py \"): full_path = document_one(module[:-3], output_folder) if full_path: written.append(full_path) else: full_path = document_one(module, output_folder) if full_path: written.append(full_path) # \" . \" needs to mean pwd... does it? full_paths = document_directory(\" . \", output_folder, for_only=module) written.extend(full_paths) # One pass, not ready to walk entire tree. third_party_written = write_docs_live_module(output_folder, 0, skip_if_written) written.extend(third_party_written) return written def write_docs_live_module( output_folder: str, total_third_party: int = 0, skip_if_written: bool = False, ) -> List[str]: \"\"\" Write out HTML documentation for all modules in a directory tree . \"\"\" # This is going to handle filesystem paths, e.g. ./module/submodule.py # There will be ANOTHER method to handle MODULE paths, e.g. module.submodule\" # Attempting to mix these two types is a bad idea . written : List [ str ] = [] while settings . MENTIONED_MODULES and total_third_party <= 100 : module = settings . MENTIONED_MODULES . pop () thing , name = module # destructure it # should only be live modules or dot notation modules , not paths . full_path = calculate_file_name ( name , output_folder ) if os . path . exists ( full_path ) and skip_if_written: settings . MENTIONED_MODULES . discard ( module ) else : actual_full_path = document_one ( thing , output_folder ) total_third_party += 1 if actual_full_path: written . append ( actual_full_path ) settings . MENTIONED_MODULES . discard ( module ) # TODO : make this a param return written def document_directory ( source_directory: str , output_folder: str , for_only: str = \"\" , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" package_path = \"\" # walk packages is why pydoc drags along with it tests folders LOGGER . debug ( f \"document_directory: Walking packages for {source_directory}\" ) full_paths: List [ str ] = [] for _ , modname , _ in pkgutil . walk_packages ([ source_directory ], package_path ) : if not str ( modname ). startswith ( for_only ) : continue LOGGER . debug ( f \"document_directory: current module: {modname})\" ) full_path = document_one ( modname , output_folder ) if full_path: full_paths . append ( full_path ) return full_paths def process_path_or_dot_name ( files : List [ str ], output_folder: str , overwrite_existing: bool = False , ) -> List [ str ] : \"\"\" Generate html documentation for all modules found at paths or dot notation module names. Args: files: output_folder: overwrite_existing: Returns: List of successfully documented modules \"\"\" LOGGER . debug ( f \"process_path_or_dot_name for {files} and writing to {output_folder}\" ) if not os . path . exists ( output_folder ) : os . makedirs ( output_folder ) copy2 ( locate_file ( \"templates/style.css\" , __ file__ ), output_folder ) _ adjust_cli_sys_path () return write_docs_per_module ( files , output_folder , skip_if_written =not overwrite_existing ) # def something () : # \"\"\" a doctest in a docstring # >>> something() # 42 # \"\"\" # return 42 if __ name__ == \"__main__\" : process_path_or_dot_name ([ \".\" ], output_folder= \"tmp\" ) # process_path_or_dot_name ([ \" . \\\\ \"], output_folder=\" docs_api \") # process_path_or_dot_name([\" pydoc_fork \"], output_folder=\" docs_api \") # process_path_or_dot_name([\" sys \"], output_folder=\" docs_api \") # process_path_or_dot_name( # [\" cats \"], output_folder=\" docs_api \" # ) # writes cats.html, even tho this isn't a module! # process_path_or_dot_name([\" inspect \"], output_folder=\" docs_api \" ) Variables LOGGER Functions calculate_file_name def calculate_file_name ( name : str , output_folder : str ) -> str Returns name. If this was written, what would its name be View Source def calculate_file_name ( name : str , output_folder : str ) -> str : \"\"\"Returns name. If this was written, what would its name be\"\"\" name = ( name . replace ( \"<\" , \"\" ) . replace ( \">\" , \"\" ) . replace ( \":\" , \"\" ) . replace ( \",\" , \"_\" ) . replace ( \" \" , \"_\" ) . replace ( \"(\" , \"\" ) . replace ( \")\" , \"\" ) ) full_path = output_folder + os . sep + name + \".html\" return full_path document_directory def document_directory ( source_directory : str , output_folder : str , for_only : str = '' ) -> List [ str ] Write out HTML documentation for all modules in a directory tree. View Source def document_directory ( source_directory : str , output_folder : str , for_only : str = \"\" , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" package_path = \"\" # walk packages is why pydoc drags along with it tests folders LOGGER . debug ( f \"document_directory: Walking packages for {source_directory}\" ) full_paths : List [ str ] = [] for _ , modname , _ in pkgutil . walk_packages ( [ source_directory ] , package_path ) : if not str ( modname ). startswith ( for_only ) : continue LOGGER . debug ( f \"document_directory: current module: {modname})\" ) full_path = document_one ( modname , output_folder ) if full_path : full_paths . append ( full_path ) return full_paths document_one def document_one ( thing : Union [ pydoc_fork . inspector . custom_types . TypeLike , str ], output_folder : str , force_load : bool = False ) -> Optional [ str ] Write HTML documentation to a file in the current directory. View Source def document_one ( thing : Union [ TypeLike , str ], output_folder : str , force_load : bool = False , ) -> Optional [ str ]: \"\"\"Write HTML documentation to a file in the current directory.\"\"\" try : the_object , name = resolve ( thing , force_load ) except ( ImportError , ImportTimeError ): LOGGER . warning ( f \"document_one failed for {str(thing)} with folder {output_folder}\" ) return None # MR # should go in constructor, but what? no constructor settings . OUTPUT_FOLDER = output_folder page_out = render ( describe ( the_object ), the_object , name ) # MR output_folder + os.sep full_path = calculate_file_name ( name , output_folder ) with open ( full_path , \"w\" , encoding = \"utf-8\" ) as file : file . write ( page_out ) print ( \"wrote\" , name + \".html\" ) return full_path # except (ImportError, ErrorDuringImport) as value: # print(value) # return \"\" modules_in_current def modules_in_current ( ) -> List [ str ] Convert . shortcut into list of modules View Source def modules_in_current () -> List [ str ] : \"\"\"Convert . shortcut into list of modules\"\"\" current = os . getcwd () files = glob . glob ( os . path . join ( os . path . dirname ( current ), \"*.py\" )) py_files = [ os . path . basename ( f )[:- 3 ] for f in files if os . path . isdir ( f )] folders = glob . glob ( os . path . join ( os . path . dirname ( current ), \"*.py\" )) py_folders = [ os . path . basename ( f ) for f in folders if os . path . isdir ( f )] found = py_files + py_folders LOGGER . debug ( f \"Adding these modules from current folder to document {found}\" ) return found process_path_or_dot_name def process_path_or_dot_name ( files : List [ str ], output_folder : str , overwrite_existing : bool = False ) -> List [ str ] Generate html documentation for all modules found at paths or dot notation module names. Parameters: Name Type Description Default files None None output_folder None None overwrite_existing None None Returns: Type Description None List of successfully documented modules View Source def process_path_or_dot_name ( files : List [ str ] , output_folder : str , overwrite_existing : bool = False , ) -> List [ str ] : \"\"\" Generate html documentation for all modules found at paths or dot notation module names. Args: files: output_folder: overwrite_existing: Returns: List of successfully documented modules \"\"\" LOGGER . debug ( f \"process_path_or_dot_name for {files} and writing to {output_folder}\" ) if not os . path . exists ( output_folder ) : os . makedirs ( output_folder ) copy2 ( locate_file ( \"templates/style.css\" , __file__ ), output_folder ) _adjust_cli_sys_path () return write_docs_per_module ( files , output_folder , skip_if_written = not overwrite_existing ) write_docs_live_module def write_docs_live_module ( output_folder : str , total_third_party : int = 0 , skip_if_written : bool = False ) -> List [ str ] Write out HTML documentation for all modules in a directory tree. View Source def write_docs_live_module ( output_folder : str , total_third_party : int = 0 , skip_if_written : bool = False , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" # This is going to handle filesystem paths , e . g . . / module / submodule . py # There will be ANOTHER method to handle MODULE paths , e . g . module . submodule \" # Attempting to mix these two types is a bad idea . written : List [ str ] = [] while settings . MENTIONED_MODULES and total_third_party <= 100 : module = settings . MENTIONED_MODULES . pop () thing , name = module # destructure it # should only be live modules or dot notation modules , not paths . full_path = calculate_file_name ( name , output_folder ) if os . path . exists ( full_path ) and skip_if_written : settings . MENTIONED_MODULES . discard ( module ) else : actual_full_path = document_one ( thing , output_folder ) total_third_party += 1 if actual_full_path : written . append ( actual_full_path ) settings . MENTIONED_MODULES . discard ( module ) # TODO : make this a param return written write_docs_per_module def write_docs_per_module ( modules : List [ str ], output_folder : str , skip_if_written : bool = False ) -> List [ str ] Write out HTML documentation for all modules in a directory tree. View Source def write_docs_per_module ( modules : List [ str ], output_folder: str , skip_if_written: bool = False , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" if \".\" in modules : modules . extend ( modules_in_current ()) # This is going to handle filesystem paths , e . g . . / module / submodule . py # There will be ANOTHER method to handle MODULE paths , e . g . module . submodule \" # Attempting to mix these two types is a bad idea. written: List[str] = [] for module in modules: # file if module.lower().endswith(\" . py \"): full_path = document_one(module[:-3], output_folder) if full_path: written.append(full_path) else: full_path = document_one(module, output_folder) if full_path: written.append(full_path) # \" . \" needs to mean pwd... does it? full_paths = document_directory(\" . \" , output_folder , for_only = module ) written . extend ( full_paths ) # One pass , not ready to walk entire tree . third_party_written = write_docs_live_module ( output_folder , 0 , skip_if_written ) written . extend ( third_party_written ) return written","title":"Commands"},{"location":"reference/pydoc_fork/commands/#module-pydoc_forkcommands","text":"Process commands as pure python functions. All the CLI logic should be handled in main . View Source \"\"\"Process commands as pure python functions. All the CLI logic should be handled in __main__. \"\"\" import logging import os import pkgutil from shutil import copy2 from typing import List , Optional , Union import os . path import glob from pydoc_fork import settings from pydoc_fork . inspector . custom_types import TypeLike from pydoc_fork . inspector . module_utils import ImportTimeError from pydoc_fork . inspector . path_utils import _ adjust_cli_sys_path , locate_file from pydoc_fork . inspector . utils import describe , resolve from pydoc_fork . reporter . format_page import render LOGGER = logging . getLogger ( __ name__ ) def document_one ( thing : Union [ TypeLike , str ], output_folder: str , force_load: bool = False , ) -> Optional [ str ] : \"\"\"Write HTML documentation to a file in the current directory.\"\"\" try : the_object , name = resolve ( thing , force_load ) except ( ImportError , ImportTimeError ) : LOGGER . warning ( f \"document_one failed for {str(thing)} with folder {output_folder}\" ) return None # MR # should go in constructor , but what? no constructor settings . OUTPUT_FOLDER = output_folder page_out = render ( describe ( the_object ), the_object , name ) # MR output_folder + os . sep full_path = calculate_file_name ( name , output_folder ) with open ( full_path , \"w\" , encoding= \"utf-8\" ) as file : file . write ( page_out ) print ( \"wrote\" , name + \".html\" ) return full_path # except ( ImportError , ErrorDuringImport ) as value : # print ( value ) # return \"\" def calculate_file_name ( name : str , output_folder: str ) -> str : \"\"\"Returns name. If this was written, what would its name be\"\"\" name = ( name . replace ( \"<\" , \"\" ) . replace ( \">\" , \"\" ) . replace ( \":\" , \"\" ) . replace ( \",\" , \"_\" ) . replace ( \" \" , \"_\" ) . replace ( \"(\" , \"\" ) . replace ( \")\" , \"\" ) ) full_path = output_folder + os . sep + name + \".html\" return full_path def modules_in_current () -> List [ str ] : \"\"\"Convert . shortcut into list of modules\"\"\" current = os . getcwd () files = glob . glob ( os . path . join ( os . path . dirname ( current ), \"*.py\" )) py_files = [ os . path . basename ( f )[:- 3 ] for f in files if os . path . isdir ( f )] folders = glob . glob ( os . path . join ( os . path . dirname ( current ), \"*.py\" )) py_folders = [ os . path . basename ( f ) for f in folders if os . path . isdir ( f )] found = py_files + py_folders LOGGER . debug ( f \"Adding these modules from current folder to document {found}\" ) return found def write_docs_per_module ( modules : List [ str ], output_folder: str , skip_if_written: bool = False , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" if \".\" in modules : modules . extend ( modules_in_current ()) # This is going to handle filesystem paths , e . g . . / module / submodule . py # There will be ANOTHER method to handle MODULE paths , e . g . module . submodule \" # Attempting to mix these two types is a bad idea. written: List[str] = [] for module in modules: # file if module.lower().endswith(\" . py \"): full_path = document_one(module[:-3], output_folder) if full_path: written.append(full_path) else: full_path = document_one(module, output_folder) if full_path: written.append(full_path) # \" . \" needs to mean pwd... does it? full_paths = document_directory(\" . \", output_folder, for_only=module) written.extend(full_paths) # One pass, not ready to walk entire tree. third_party_written = write_docs_live_module(output_folder, 0, skip_if_written) written.extend(third_party_written) return written def write_docs_live_module( output_folder: str, total_third_party: int = 0, skip_if_written: bool = False, ) -> List[str]: \"\"\" Write out HTML documentation for all modules in a directory tree . \"\"\" # This is going to handle filesystem paths, e.g. ./module/submodule.py # There will be ANOTHER method to handle MODULE paths, e.g. module.submodule\" # Attempting to mix these two types is a bad idea . written : List [ str ] = [] while settings . MENTIONED_MODULES and total_third_party <= 100 : module = settings . MENTIONED_MODULES . pop () thing , name = module # destructure it # should only be live modules or dot notation modules , not paths . full_path = calculate_file_name ( name , output_folder ) if os . path . exists ( full_path ) and skip_if_written: settings . MENTIONED_MODULES . discard ( module ) else : actual_full_path = document_one ( thing , output_folder ) total_third_party += 1 if actual_full_path: written . append ( actual_full_path ) settings . MENTIONED_MODULES . discard ( module ) # TODO : make this a param return written def document_directory ( source_directory: str , output_folder: str , for_only: str = \"\" , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" package_path = \"\" # walk packages is why pydoc drags along with it tests folders LOGGER . debug ( f \"document_directory: Walking packages for {source_directory}\" ) full_paths: List [ str ] = [] for _ , modname , _ in pkgutil . walk_packages ([ source_directory ], package_path ) : if not str ( modname ). startswith ( for_only ) : continue LOGGER . debug ( f \"document_directory: current module: {modname})\" ) full_path = document_one ( modname , output_folder ) if full_path: full_paths . append ( full_path ) return full_paths def process_path_or_dot_name ( files : List [ str ], output_folder: str , overwrite_existing: bool = False , ) -> List [ str ] : \"\"\" Generate html documentation for all modules found at paths or dot notation module names. Args: files: output_folder: overwrite_existing: Returns: List of successfully documented modules \"\"\" LOGGER . debug ( f \"process_path_or_dot_name for {files} and writing to {output_folder}\" ) if not os . path . exists ( output_folder ) : os . makedirs ( output_folder ) copy2 ( locate_file ( \"templates/style.css\" , __ file__ ), output_folder ) _ adjust_cli_sys_path () return write_docs_per_module ( files , output_folder , skip_if_written =not overwrite_existing ) # def something () : # \"\"\" a doctest in a docstring # >>> something() # 42 # \"\"\" # return 42 if __ name__ == \"__main__\" : process_path_or_dot_name ([ \".\" ], output_folder= \"tmp\" ) # process_path_or_dot_name ([ \" . \\\\ \"], output_folder=\" docs_api \") # process_path_or_dot_name([\" pydoc_fork \"], output_folder=\" docs_api \") # process_path_or_dot_name([\" sys \"], output_folder=\" docs_api \") # process_path_or_dot_name( # [\" cats \"], output_folder=\" docs_api \" # ) # writes cats.html, even tho this isn't a module! # process_path_or_dot_name([\" inspect \"], output_folder=\" docs_api \" )","title":"Module pydoc_fork.commands"},{"location":"reference/pydoc_fork/commands/#variables","text":"LOGGER","title":"Variables"},{"location":"reference/pydoc_fork/commands/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/commands/#calculate_file_name","text":"def calculate_file_name ( name : str , output_folder : str ) -> str Returns name. If this was written, what would its name be View Source def calculate_file_name ( name : str , output_folder : str ) -> str : \"\"\"Returns name. If this was written, what would its name be\"\"\" name = ( name . replace ( \"<\" , \"\" ) . replace ( \">\" , \"\" ) . replace ( \":\" , \"\" ) . replace ( \",\" , \"_\" ) . replace ( \" \" , \"_\" ) . replace ( \"(\" , \"\" ) . replace ( \")\" , \"\" ) ) full_path = output_folder + os . sep + name + \".html\" return full_path","title":"calculate_file_name"},{"location":"reference/pydoc_fork/commands/#document_directory","text":"def document_directory ( source_directory : str , output_folder : str , for_only : str = '' ) -> List [ str ] Write out HTML documentation for all modules in a directory tree. View Source def document_directory ( source_directory : str , output_folder : str , for_only : str = \"\" , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" package_path = \"\" # walk packages is why pydoc drags along with it tests folders LOGGER . debug ( f \"document_directory: Walking packages for {source_directory}\" ) full_paths : List [ str ] = [] for _ , modname , _ in pkgutil . walk_packages ( [ source_directory ] , package_path ) : if not str ( modname ). startswith ( for_only ) : continue LOGGER . debug ( f \"document_directory: current module: {modname})\" ) full_path = document_one ( modname , output_folder ) if full_path : full_paths . append ( full_path ) return full_paths","title":"document_directory"},{"location":"reference/pydoc_fork/commands/#document_one","text":"def document_one ( thing : Union [ pydoc_fork . inspector . custom_types . TypeLike , str ], output_folder : str , force_load : bool = False ) -> Optional [ str ] Write HTML documentation to a file in the current directory. View Source def document_one ( thing : Union [ TypeLike , str ], output_folder : str , force_load : bool = False , ) -> Optional [ str ]: \"\"\"Write HTML documentation to a file in the current directory.\"\"\" try : the_object , name = resolve ( thing , force_load ) except ( ImportError , ImportTimeError ): LOGGER . warning ( f \"document_one failed for {str(thing)} with folder {output_folder}\" ) return None # MR # should go in constructor, but what? no constructor settings . OUTPUT_FOLDER = output_folder page_out = render ( describe ( the_object ), the_object , name ) # MR output_folder + os.sep full_path = calculate_file_name ( name , output_folder ) with open ( full_path , \"w\" , encoding = \"utf-8\" ) as file : file . write ( page_out ) print ( \"wrote\" , name + \".html\" ) return full_path # except (ImportError, ErrorDuringImport) as value: # print(value) # return \"\"","title":"document_one"},{"location":"reference/pydoc_fork/commands/#modules_in_current","text":"def modules_in_current ( ) -> List [ str ] Convert . shortcut into list of modules View Source def modules_in_current () -> List [ str ] : \"\"\"Convert . shortcut into list of modules\"\"\" current = os . getcwd () files = glob . glob ( os . path . join ( os . path . dirname ( current ), \"*.py\" )) py_files = [ os . path . basename ( f )[:- 3 ] for f in files if os . path . isdir ( f )] folders = glob . glob ( os . path . join ( os . path . dirname ( current ), \"*.py\" )) py_folders = [ os . path . basename ( f ) for f in folders if os . path . isdir ( f )] found = py_files + py_folders LOGGER . debug ( f \"Adding these modules from current folder to document {found}\" ) return found","title":"modules_in_current"},{"location":"reference/pydoc_fork/commands/#process_path_or_dot_name","text":"def process_path_or_dot_name ( files : List [ str ], output_folder : str , overwrite_existing : bool = False ) -> List [ str ] Generate html documentation for all modules found at paths or dot notation module names. Parameters: Name Type Description Default files None None output_folder None None overwrite_existing None None Returns: Type Description None List of successfully documented modules View Source def process_path_or_dot_name ( files : List [ str ] , output_folder : str , overwrite_existing : bool = False , ) -> List [ str ] : \"\"\" Generate html documentation for all modules found at paths or dot notation module names. Args: files: output_folder: overwrite_existing: Returns: List of successfully documented modules \"\"\" LOGGER . debug ( f \"process_path_or_dot_name for {files} and writing to {output_folder}\" ) if not os . path . exists ( output_folder ) : os . makedirs ( output_folder ) copy2 ( locate_file ( \"templates/style.css\" , __file__ ), output_folder ) _adjust_cli_sys_path () return write_docs_per_module ( files , output_folder , skip_if_written = not overwrite_existing )","title":"process_path_or_dot_name"},{"location":"reference/pydoc_fork/commands/#write_docs_live_module","text":"def write_docs_live_module ( output_folder : str , total_third_party : int = 0 , skip_if_written : bool = False ) -> List [ str ] Write out HTML documentation for all modules in a directory tree. View Source def write_docs_live_module ( output_folder : str , total_third_party : int = 0 , skip_if_written : bool = False , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" # This is going to handle filesystem paths , e . g . . / module / submodule . py # There will be ANOTHER method to handle MODULE paths , e . g . module . submodule \" # Attempting to mix these two types is a bad idea . written : List [ str ] = [] while settings . MENTIONED_MODULES and total_third_party <= 100 : module = settings . MENTIONED_MODULES . pop () thing , name = module # destructure it # should only be live modules or dot notation modules , not paths . full_path = calculate_file_name ( name , output_folder ) if os . path . exists ( full_path ) and skip_if_written : settings . MENTIONED_MODULES . discard ( module ) else : actual_full_path = document_one ( thing , output_folder ) total_third_party += 1 if actual_full_path : written . append ( actual_full_path ) settings . MENTIONED_MODULES . discard ( module ) # TODO : make this a param return written","title":"write_docs_live_module"},{"location":"reference/pydoc_fork/commands/#write_docs_per_module","text":"def write_docs_per_module ( modules : List [ str ], output_folder : str , skip_if_written : bool = False ) -> List [ str ] Write out HTML documentation for all modules in a directory tree. View Source def write_docs_per_module ( modules : List [ str ], output_folder: str , skip_if_written: bool = False , ) -> List [ str ] : \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\" if \".\" in modules : modules . extend ( modules_in_current ()) # This is going to handle filesystem paths , e . g . . / module / submodule . py # There will be ANOTHER method to handle MODULE paths , e . g . module . submodule \" # Attempting to mix these two types is a bad idea. written: List[str] = [] for module in modules: # file if module.lower().endswith(\" . py \"): full_path = document_one(module[:-3], output_folder) if full_path: written.append(full_path) else: full_path = document_one(module, output_folder) if full_path: written.append(full_path) # \" . \" needs to mean pwd... does it? full_paths = document_directory(\" . \" , output_folder , for_only = module ) written . extend ( full_paths ) # One pass , not ready to walk entire tree . third_party_written = write_docs_live_module ( output_folder , 0 , skip_if_written ) written . extend ( third_party_written ) return written","title":"write_docs_per_module"},{"location":"reference/pydoc_fork/settings/","text":"Module pydoc_fork.settings Configuration options that could be used by anything. Also global variables View Source \"\"\" Configuration options that could be used by anything. Also global variables \"\"\" import logging import os import pathlib import sys from typing import Any , Dict , Optional , Set , Tuple import tomli from pydoc_fork.inspector.custom_types import TypeLike LOGGER = logging . getLogger ( __name__ ) # pylint: disable=global-statement MENTIONED_MODULES : Set [ Tuple [ TypeLike , str ]] = set () SKIP_MODULES = [ \"typing\" ] PREFER_DOCS_PYTHON_ORG = False DOCUMENT_INTERNALS = False ONLY_NAMED_AND_SUBS = False OUTPUT_FOLDER = \"\" PYTHONDOCS = os . environ . get ( \"PYTHONDOCS\" , \"https://docs.python.org/ %d . %d /library\" % sys . version_info [: 2 ] ) \"\"\"Module docs for core modules are assumed to be in https://docs.python.org/X.Y/library/ This can be overridden by setting the PYTHONDOCS environment variable to a different URL or to a local directory containing the Library Reference Manual pages.\"\"\" def load_config ( path : Optional [ str ]): \"\"\"Copy config from toml to globals\"\"\" global PREFER_DOCS_PYTHON_ORG global DOCUMENT_INTERNALS global SKIP_MODULES global ONLY_NAMED_AND_SUBS pairs = parse_toml ( path ) if pairs : LOGGER . debug ( f \"Found config at { path } \" ) PREFER_DOCS_PYTHON_ORG = pairs . get ( \"PREFER_DOCS_PYTHON_ORG\" , False ) DOCUMENT_INTERNALS = pairs . get ( \"DOCUMENT_INTERNALS\" , True ) SKIP_MODULES = pairs . get ( \"SKIP_MODULES\" , [ \"typing\" ]) ONLY_NAMED_AND_SUBS = pairs . get ( \"ONLY_NAMED_AND_SUBS\" , False ) def parse_toml ( path_string : Optional [ str ]) -> Dict [ str , Any ]: \"\"\"Parse toml\"\"\" if not path_string : path = pathlib . Path ( os . getcwd ()) else : path = pathlib . Path ( path_string ) toml_path = path / \"pyproject.toml\" if not toml_path . exists (): return {} with open ( toml_path , encoding = \"utf8\" ) as handle : pyproject_toml = tomli . loads ( handle . read ()) config = pyproject_toml . get ( \"tool\" , {}) . get ( \"pydoc_fork\" , {}) loose_matching = { k . replace ( \"--\" , \"\" ) . replace ( \"-\" , \"_\" ): v for k , v in config . items () } return loose_matching Variables DOCUMENT_INTERNALS LOGGER MENTIONED_MODULES ONLY_NAMED_AND_SUBS OUTPUT_FOLDER PREFER_DOCS_PYTHON_ORG PYTHONDOCS Module docs for core modules are assumed to be in https://docs.python.org/X.Y/library/ This can be overridden by setting the PYTHONDOCS environment variable to a different URL or to a local directory containing the Library Reference Manual pages. SKIP_MODULES Functions load_config def load_config ( path : Optional [ str ] ) Copy config from toml to globals View Source def load_config ( path : Optional [ str ] ) : \"\"\"Copy config from toml to globals\"\"\" global PREFER_DOCS_PYTHON_ORG global DOCUMENT_INTERNALS global SKIP_MODULES global ONLY_NAMED_AND_SUBS pairs = parse_toml ( path ) if pairs : LOGGER . debug ( f \"Found config at {path}\" ) PREFER_DOCS_PYTHON_ORG = pairs . get ( \"PREFER_DOCS_PYTHON_ORG\" , False ) DOCUMENT_INTERNALS = pairs . get ( \"DOCUMENT_INTERNALS\" , True ) SKIP_MODULES = pairs . get ( \"SKIP_MODULES\" , [ \"typing\" ] ) ONLY_NAMED_AND_SUBS = pairs . get ( \"ONLY_NAMED_AND_SUBS\" , False ) parse_toml def parse_toml ( path_string : Optional [ str ] ) -> Dict [ str , Any ] Parse toml View Source def parse_toml ( path_string : Optional [ str ]) -> Dict [ str , Any ]: \"\"\"Parse toml\"\"\" if not path_string : path = pathlib . Path ( os . getcwd ()) else : path = pathlib . Path ( path_string ) toml_path = path / \"pyproject.toml\" if not toml_path . exists (): return {} with open ( toml_path , encoding = \"utf8\" ) as handle : pyproject_toml = tomli . loads ( handle . read ()) config = pyproject_toml . get ( \"tool\" , {}) . get ( \"pydoc_fork\" , {}) loose_matching = { k . replace ( \"--\" , \"\" ) . replace ( \"-\" , \"_\" ): v for k , v in config . items () } return loose_matching","title":"Settings"},{"location":"reference/pydoc_fork/settings/#module-pydoc_forksettings","text":"Configuration options that could be used by anything. Also global variables View Source \"\"\" Configuration options that could be used by anything. Also global variables \"\"\" import logging import os import pathlib import sys from typing import Any , Dict , Optional , Set , Tuple import tomli from pydoc_fork.inspector.custom_types import TypeLike LOGGER = logging . getLogger ( __name__ ) # pylint: disable=global-statement MENTIONED_MODULES : Set [ Tuple [ TypeLike , str ]] = set () SKIP_MODULES = [ \"typing\" ] PREFER_DOCS_PYTHON_ORG = False DOCUMENT_INTERNALS = False ONLY_NAMED_AND_SUBS = False OUTPUT_FOLDER = \"\" PYTHONDOCS = os . environ . get ( \"PYTHONDOCS\" , \"https://docs.python.org/ %d . %d /library\" % sys . version_info [: 2 ] ) \"\"\"Module docs for core modules are assumed to be in https://docs.python.org/X.Y/library/ This can be overridden by setting the PYTHONDOCS environment variable to a different URL or to a local directory containing the Library Reference Manual pages.\"\"\" def load_config ( path : Optional [ str ]): \"\"\"Copy config from toml to globals\"\"\" global PREFER_DOCS_PYTHON_ORG global DOCUMENT_INTERNALS global SKIP_MODULES global ONLY_NAMED_AND_SUBS pairs = parse_toml ( path ) if pairs : LOGGER . debug ( f \"Found config at { path } \" ) PREFER_DOCS_PYTHON_ORG = pairs . get ( \"PREFER_DOCS_PYTHON_ORG\" , False ) DOCUMENT_INTERNALS = pairs . get ( \"DOCUMENT_INTERNALS\" , True ) SKIP_MODULES = pairs . get ( \"SKIP_MODULES\" , [ \"typing\" ]) ONLY_NAMED_AND_SUBS = pairs . get ( \"ONLY_NAMED_AND_SUBS\" , False ) def parse_toml ( path_string : Optional [ str ]) -> Dict [ str , Any ]: \"\"\"Parse toml\"\"\" if not path_string : path = pathlib . Path ( os . getcwd ()) else : path = pathlib . Path ( path_string ) toml_path = path / \"pyproject.toml\" if not toml_path . exists (): return {} with open ( toml_path , encoding = \"utf8\" ) as handle : pyproject_toml = tomli . loads ( handle . read ()) config = pyproject_toml . get ( \"tool\" , {}) . get ( \"pydoc_fork\" , {}) loose_matching = { k . replace ( \"--\" , \"\" ) . replace ( \"-\" , \"_\" ): v for k , v in config . items () } return loose_matching","title":"Module pydoc_fork.settings"},{"location":"reference/pydoc_fork/settings/#variables","text":"DOCUMENT_INTERNALS LOGGER MENTIONED_MODULES ONLY_NAMED_AND_SUBS OUTPUT_FOLDER PREFER_DOCS_PYTHON_ORG PYTHONDOCS Module docs for core modules are assumed to be in https://docs.python.org/X.Y/library/ This can be overridden by setting the PYTHONDOCS environment variable to a different URL or to a local directory containing the Library Reference Manual pages. SKIP_MODULES","title":"Variables"},{"location":"reference/pydoc_fork/settings/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/settings/#load_config","text":"def load_config ( path : Optional [ str ] ) Copy config from toml to globals View Source def load_config ( path : Optional [ str ] ) : \"\"\"Copy config from toml to globals\"\"\" global PREFER_DOCS_PYTHON_ORG global DOCUMENT_INTERNALS global SKIP_MODULES global ONLY_NAMED_AND_SUBS pairs = parse_toml ( path ) if pairs : LOGGER . debug ( f \"Found config at {path}\" ) PREFER_DOCS_PYTHON_ORG = pairs . get ( \"PREFER_DOCS_PYTHON_ORG\" , False ) DOCUMENT_INTERNALS = pairs . get ( \"DOCUMENT_INTERNALS\" , True ) SKIP_MODULES = pairs . get ( \"SKIP_MODULES\" , [ \"typing\" ] ) ONLY_NAMED_AND_SUBS = pairs . get ( \"ONLY_NAMED_AND_SUBS\" , False )","title":"load_config"},{"location":"reference/pydoc_fork/settings/#parse_toml","text":"def parse_toml ( path_string : Optional [ str ] ) -> Dict [ str , Any ] Parse toml View Source def parse_toml ( path_string : Optional [ str ]) -> Dict [ str , Any ]: \"\"\"Parse toml\"\"\" if not path_string : path = pathlib . Path ( os . getcwd ()) else : path = pathlib . Path ( path_string ) toml_path = path / \"pyproject.toml\" if not toml_path . exists (): return {} with open ( toml_path , encoding = \"utf8\" ) as handle : pyproject_toml = tomli . loads ( handle . read ()) config = pyproject_toml . get ( \"tool\" , {}) . get ( \"pydoc_fork\" , {}) loose_matching = { k . replace ( \"--\" , \"\" ) . replace ( \"-\" , \"_\" ): v for k , v in config . items () } return loose_matching","title":"parse_toml"},{"location":"reference/pydoc_fork/inspector/","text":"Module pydoc_fork.inspector This submodule has all the logic related to type-lookup and type-discovery. It has nothing to do with UI output other than it is creating a view model for the reporter submodule. View Source \"\"\" This submodule has all the logic related to type - lookup and type - discovery . It has nothing to do with UI output other than it is creating a view model for the reporter submodule . \"\"\" Sub-modules pydoc_fork.inspector.custom_types pydoc_fork.inspector.module_utils pydoc_fork.inspector.path_utils pydoc_fork.inspector.utils","title":"Index"},{"location":"reference/pydoc_fork/inspector/#module-pydoc_forkinspector","text":"This submodule has all the logic related to type-lookup and type-discovery. It has nothing to do with UI output other than it is creating a view model for the reporter submodule. View Source \"\"\" This submodule has all the logic related to type - lookup and type - discovery . It has nothing to do with UI output other than it is creating a view model for the reporter submodule . \"\"\"","title":"Module pydoc_fork.inspector"},{"location":"reference/pydoc_fork/inspector/#sub-modules","text":"pydoc_fork.inspector.custom_types pydoc_fork.inspector.module_utils pydoc_fork.inspector.path_utils pydoc_fork.inspector.utils","title":"Sub-modules"},{"location":"reference/pydoc_fork/inspector/custom_types/","text":"Module pydoc_fork.inspector.custom_types Custom Types so mypy can check the code None View Source \"\"\" Custom Types so mypy can check the code \"\"\" from typing import List from typing_extensions import Protocol # noinspection SpellCheckingInspection class TypeLike ( Protocol ): \"\"\"This is a union of all sort of types\"\"\" __name__ : str __module__ : str __path__ : str # noinspection SpellCheckingInspection __objclass__ : \"TypeLike\" __func__ : \"TypeLike\" __self__ : \"TypeLike\" __bases__ : List [ \"TypeLike\" ] __all__ : List [ str ] __qualname__ : str __file__ : str __mro__ : str # pure metadata, people can write about anything here __version__ : str __date__ : str __author__ : str __credits__ : str Classes TypeLike class TypeLike ( * args , ** kwargs ) View Source class TypeLike ( Protocol ) : \"\"\"This is a union of all sort of types\"\"\" __name__ : str __module__ : str __path__ : str # noinspection SpellCheckingInspection __objclass__ : \"TypeLike\" __func__ : \"TypeLike\" __self__ : \"TypeLike\" __bases__ : List [ \"TypeLike\" ] __all__ : List [ str ] __qualname__ : str __file__ : str __mro__ : str # pure metadata , people can write about anything here __version__ : str __date__ : str __author__ : str __credits__ : str Ancestors (in MRO) typing.Protocol typing.Generic","title":"Custom Types"},{"location":"reference/pydoc_fork/inspector/custom_types/#module-pydoc_forkinspectorcustom_types","text":"Custom Types so mypy can check the code None View Source \"\"\" Custom Types so mypy can check the code \"\"\" from typing import List from typing_extensions import Protocol # noinspection SpellCheckingInspection class TypeLike ( Protocol ): \"\"\"This is a union of all sort of types\"\"\" __name__ : str __module__ : str __path__ : str # noinspection SpellCheckingInspection __objclass__ : \"TypeLike\" __func__ : \"TypeLike\" __self__ : \"TypeLike\" __bases__ : List [ \"TypeLike\" ] __all__ : List [ str ] __qualname__ : str __file__ : str __mro__ : str # pure metadata, people can write about anything here __version__ : str __date__ : str __author__ : str __credits__ : str","title":"Module pydoc_fork.inspector.custom_types"},{"location":"reference/pydoc_fork/inspector/custom_types/#classes","text":"","title":"Classes"},{"location":"reference/pydoc_fork/inspector/custom_types/#typelike","text":"class TypeLike ( * args , ** kwargs ) View Source class TypeLike ( Protocol ) : \"\"\"This is a union of all sort of types\"\"\" __name__ : str __module__ : str __path__ : str # noinspection SpellCheckingInspection __objclass__ : \"TypeLike\" __func__ : \"TypeLike\" __self__ : \"TypeLike\" __bases__ : List [ \"TypeLike\" ] __all__ : List [ str ] __qualname__ : str __file__ : str __mro__ : str # pure metadata , people can write about anything here __version__ : str __date__ : str __author__ : str __credits__ : str","title":"TypeLike"},{"location":"reference/pydoc_fork/inspector/custom_types/#ancestors-in-mro","text":"typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/pydoc_fork/inspector/module_utils/","text":"Module pydoc_fork.inspector.module_utils Module Manipulation None View Source \"\"\" Module Manipulation \"\"\" import builtins # noinspection PyProtectedMember import importlib._bootstrap # noinspection PyProtectedMember import importlib._bootstrap_external import importlib.machinery import importlib.util import logging import os import sys from typing import Any , Dict , Optional , Tuple , cast from pydoc_fork.inspector.custom_types import TypeLike LOGGER = logging . getLogger ( __name__ ) class ImportTimeError ( Exception ): \"\"\"Errors that occurred while trying to import something to document it.\"\"\" def __init__ ( self , filename : Optional [ str ], exc_info : Tuple [ Any , Any , Any ]) -> None : \"\"\"Set up\"\"\" self . filename = filename # pylint: disable=invalid-name self . exc , self . value , self . tb = exc_info def __str__ ( self ) -> str : \"\"\"For display\"\"\" exc = self . exc . __name__ return f \"Problem in { self . filename } - { exc } : { self . value } \" # noinspection PyProtectedMember def importfile ( path : str ) -> TypeLike : \"\"\"Import a Python source file or compiled file given its path.\"\"\" magic = importlib . util . MAGIC_NUMBER with open ( path , \"rb\" ) as file : is_bytecode = magic == file . read ( len ( magic )) filename = os . path . basename ( path ) name , _ = os . path . splitext ( filename ) if is_bytecode : loader = importlib . _bootstrap_external . SourcelessFileLoader ( name , path ) else : loader = importlib . _bootstrap_external . SourceFileLoader ( name , path ) # XXX We probably don't need to pass in the loader here. spec = importlib . util . spec_from_file_location ( name , path , loader = loader ) try : return cast ( TypeLike , importlib . _bootstrap . _load ( spec )) # pylint: disable=broad-except except BaseException as import_error : LOGGER . warning ( f \"Skipping importfile for { name } at { path } , got a { import_error } \" ) raise ImportTimeError ( path , sys . exc_info ()) from import_error # pylint: disable=dangerous-default-value def safe_import ( path : str , force_load : bool = False , cache : Dict [ str , Any ] = {}, # noqa - this is mutable on purpose! ) -> Any : \"\"\" Import a module; handle errors; return None if the module isn't found. If the module *is* found but an exception occurs, it's wrapped in an ErrorDuringImport exception and reraised. Unlike __import__, if a package path is specified, the module at the end of the path is returned, not the package at the beginning. If the optional 'force_load' argument is True, we reload the module from disk (unless it's a dynamic extension). \"\"\" try : # If force_load is True and the module has been previously loaded from # disk, we always have to reload the module. Checking the file's # mtime isn't good enough (e.g. the module could contain a class # that inherits from another module that has changed). if force_load and path in sys . modules : if path not in sys . builtin_module_names : # Remove the module from sys.modules and re-import to try # and avoid problems with partially loaded modules. # Also remove any submodules because they won't appear # in the newly loaded module's namespace if they're already # in sys.modules. subs = [ m for m in sys . modules if m . startswith ( path + \".\" )] for key in [ path ] + subs : # Prevent garbage collection. cache [ key ] = sys . modules [ key ] del sys . modules [ key ] module = __import__ ( path ) # pylint: disable=broad-except except BaseException as import_error : # Did the error occur before or after the module was found? ( exc , value , _ ) = info = sys . exc_info () if path in sys . modules : # An error occurred while executing the imported module. LOGGER . warning ( f \"Skipping safe_import for { path } , got a { import_error } \" ) raise ImportTimeError ( sys . modules [ path ] . __file__ , info ) from import_error if exc is SyntaxError : # A SyntaxError occurred before we could execute the module. # MR : this isn't null safe. LOGGER . warning ( f \"Skipping safe_import for { path } , got a { str ( exc ) } \" ) raise ImportTimeError ( cast ( SyntaxError , value ) . filename , info ) from import_error if issubclass ( exc , ImportError ) and cast ( ImportError , value ) . name == path : LOGGER . warning ( f \"Skipping safe_import for { path } , got a { import_error } \" ) LOGGER . warning ( f \"Cannot import this path: { path } \" ) # No such module in the path. return None LOGGER . warning ( f \"Skipping safe_import for { path } , got a { import_error } \" ) # Some other error occurred during the importing process. raise ImportTimeError ( path , sys . exc_info ()) from import_error for part in path . split ( \".\" )[ 1 :]: try : module = getattr ( module , part ) except AttributeError : LOGGER . warning ( f \"While safe_import - { str ( module ) } does not have { part } from dot path { path } \" ) return None return module def ispackage ( path : str ) -> bool : \"\"\"Guess whether a path refers to a package directory.\"\"\" if os . path . isdir ( path ): for ext in ( \".py\" , \".pyc\" ): if os . path . isfile ( os . path . join ( path , \"__init__\" + ext )): return True return False def locate ( path : str , force_load : bool = False ) -> Any : \"\"\"Locate an object by name or dotted path, importing as necessary.\"\"\" if \"-\" in path : # Not sure about this path = path . replace ( \"-\" , \"_\" ) LOGGER . debug ( f \"locate(): locating { path } \" ) parts = [ part for part in path . split ( \".\" ) if part ] module , index = None , 0 while index < len ( parts ): next_module = safe_import ( \".\" . join ( parts [: index + 1 ]), force_load ) if next_module : module , index = next_module , index + 1 else : break if module : the_object = module # this errors?! # LOGGER.debug(f\"putative module {str(the_object)}\") else : the_object = builtins for part in parts [ index :]: try : the_object = getattr ( the_object , part ) except AttributeError : LOGGER . debug ( f \"locate(): Don't think this is a module { the_object } \" ) return None return the_object Variables LOGGER Functions importfile def importfile ( path : str ) -> pydoc_fork . inspector . custom_types . TypeLike Import a Python source file or compiled file given its path. View Source def importfile ( path : str ) -> TypeLike : \"\"\"Import a Python source file or compiled file given its path.\"\"\" magic = importlib . util . MAGIC_NUMBER with open ( path , \"rb\" ) as file : is_bytecode = magic == file . read ( len ( magic )) filename = os . path . basename ( path ) name , _ = os . path . splitext ( filename ) if is_bytecode : loader = importlib . _bootstrap_external . SourcelessFileLoader ( name , path ) else : loader = importlib . _bootstrap_external . SourceFileLoader ( name , path ) # XXX We probably don't need to pass in the loader here. spec = importlib . util . spec_from_file_location ( name , path , loader = loader ) try : return cast ( TypeLike , importlib . _bootstrap . _load ( spec )) # pylint: disable=broad-except except BaseException as import_error : LOGGER . warning ( f \"Skipping importfile for {name} at {path}, got a {import_error}\" ) raise ImportTimeError ( path , sys . exc_info ()) from import_error ispackage def ispackage ( path : str ) -> bool Guess whether a path refers to a package directory. View Source def ispackage ( path : str ) -> bool : \"\"\"Guess whether a path refers to a package directory.\"\"\" if os . path . isdir ( path ) : for ext in ( \".py\" , \".pyc\" ) : if os . path . isfile ( os . path . join ( path , \"__init__\" + ext )) : return True return False locate def locate ( path : str , force_load : bool = False ) -> Any Locate an object by name or dotted path, importing as necessary. View Source def locate ( path : str , force_load : bool = False ) -> Any : \"\"\"Locate an object by name or dotted path, importing as necessary.\"\"\" if \"-\" in path : # Not sure about this path = path . replace ( \"-\" , \"_\" ) LOGGER . debug ( f \"locate(): locating {path}\" ) parts = [ part for part in path . split ( \".\" ) if part ] module , index = None , 0 while index < len ( parts ): next_module = safe_import ( \".\" . join ( parts [: index + 1 ]), force_load ) if next_module : module , index = next_module , index + 1 else : break if module : the_object = module # this errors?! # LOGGER.debug(f\"putative module {str(the_object)}\") else : the_object = builtins for part in parts [ index :]: try : the_object = getattr ( the_object , part ) except AttributeError : LOGGER . debug ( f \"locate(): Don't think this is a module {the_object}\" ) return None return the_object safe_import def safe_import ( path : str , force_load : bool = False , cache : Dict [ str , Any ] = {} ) -> Any Import a module; handle errors; return None if the module isn't found. If the module is found but an exception occurs, it's wrapped in an ErrorDuringImport exception and reraised. Unlike import , if a package path is specified, the module at the end of the path is returned, not the package at the beginning. If the optional 'force_load' argument is True, we reload the module from disk (unless it's a dynamic extension). View Source def safe_import ( path : str , force_load : bool = False , cache : Dict [ str, Any ] = {} , # noqa - this is mutable on purpose ! ) -> Any : \"\"\" Import a module; handle errors; return None if the module isn't found. If the module *is* found but an exception occurs, it's wrapped in an ErrorDuringImport exception and reraised. Unlike __import__, if a package path is specified, the module at the end of the path is returned, not the package at the beginning. If the optional 'force_load' argument is True, we reload the module from disk (unless it's a dynamic extension). \"\"\" try : # If force_load is True and the module has been previously loaded from # disk , we always have to reload the module . Checking the file 's # mtime isn' t good enough ( e . g . the module could contain a class # that inherits from another module that has changed ). if force_load and path in sys . modules : if path not in sys . builtin_module_names : # Remove the module from sys . modules and re - import to try # and avoid problems with partially loaded modules . # Also remove any submodules because they won 't appear # in the newly loaded module' s namespace if they 're already # in sys.modules. subs = [m for m in sys.modules if m.startswith(path + \".\")] for key in [path] + subs: # Prevent garbage collection. cache[key] = sys.modules[key] del sys.modules[key] module = __import__(path) # pylint: disable=broad-except except BaseException as import_error: # Did the error occur before or after the module was found? (exc, value, _) = info = sys.exc_info() if path in sys.modules: # An error occurred while executing the imported module. LOGGER.warning(f\"Skipping safe_import for {path}, got a {import_error}\") raise ImportTimeError(sys.modules[path].__file__, info) from import_error if exc is SyntaxError: # A SyntaxError occurred before we could execute the module. # MR : this isn' t null safe . LOGGER . warning ( f \"Skipping safe_import for {path}, got a {str(exc)}\" ) raise ImportTimeError ( cast ( SyntaxError , value ). filename , info ) from import_error if issubclass ( exc , ImportError ) and cast ( ImportError , value ). name == path : LOGGER . warning ( f \"Skipping safe_import for {path}, got a {import_error}\" ) LOGGER . warning ( f \"Cannot import this path: {path}\" ) # No such module in the path . return None LOGGER . warning ( f \"Skipping safe_import for {path}, got a {import_error}\" ) # Some other error occurred during the importing process . raise ImportTimeError ( path , sys . exc_info ()) from import_error for part in path . split ( \".\" ) [ 1: ] : try : module = getattr ( module , part ) except AttributeError : LOGGER . warning ( f \"While safe_import - {str(module)} does not have {part} from dot path {path}\" ) return None return module Classes ImportTimeError class ImportTimeError ( filename : Optional [ str ], exc_info : Tuple [ Any , Any , Any ] ) View Source class ImportTimeError ( Exception ): \"\"\"Errors that occurred while trying to import something to document it.\"\"\" def __init__ ( self , filename : Optional [ str ], exc_info : Tuple [ Any , Any , Any ]) -> None : \"\"\"Set up\"\"\" self . filename = filename # pylint: disable=invalid-name self . exc , self . value , self . tb = exc_info def __str__ ( self ) -> str : \"\"\"For display\"\"\" exc = self . exc . __name__ return f \"Problem in { self . filename } - { exc } : { self . value } \" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Module Utils"},{"location":"reference/pydoc_fork/inspector/module_utils/#module-pydoc_forkinspectormodule_utils","text":"Module Manipulation None View Source \"\"\" Module Manipulation \"\"\" import builtins # noinspection PyProtectedMember import importlib._bootstrap # noinspection PyProtectedMember import importlib._bootstrap_external import importlib.machinery import importlib.util import logging import os import sys from typing import Any , Dict , Optional , Tuple , cast from pydoc_fork.inspector.custom_types import TypeLike LOGGER = logging . getLogger ( __name__ ) class ImportTimeError ( Exception ): \"\"\"Errors that occurred while trying to import something to document it.\"\"\" def __init__ ( self , filename : Optional [ str ], exc_info : Tuple [ Any , Any , Any ]) -> None : \"\"\"Set up\"\"\" self . filename = filename # pylint: disable=invalid-name self . exc , self . value , self . tb = exc_info def __str__ ( self ) -> str : \"\"\"For display\"\"\" exc = self . exc . __name__ return f \"Problem in { self . filename } - { exc } : { self . value } \" # noinspection PyProtectedMember def importfile ( path : str ) -> TypeLike : \"\"\"Import a Python source file or compiled file given its path.\"\"\" magic = importlib . util . MAGIC_NUMBER with open ( path , \"rb\" ) as file : is_bytecode = magic == file . read ( len ( magic )) filename = os . path . basename ( path ) name , _ = os . path . splitext ( filename ) if is_bytecode : loader = importlib . _bootstrap_external . SourcelessFileLoader ( name , path ) else : loader = importlib . _bootstrap_external . SourceFileLoader ( name , path ) # XXX We probably don't need to pass in the loader here. spec = importlib . util . spec_from_file_location ( name , path , loader = loader ) try : return cast ( TypeLike , importlib . _bootstrap . _load ( spec )) # pylint: disable=broad-except except BaseException as import_error : LOGGER . warning ( f \"Skipping importfile for { name } at { path } , got a { import_error } \" ) raise ImportTimeError ( path , sys . exc_info ()) from import_error # pylint: disable=dangerous-default-value def safe_import ( path : str , force_load : bool = False , cache : Dict [ str , Any ] = {}, # noqa - this is mutable on purpose! ) -> Any : \"\"\" Import a module; handle errors; return None if the module isn't found. If the module *is* found but an exception occurs, it's wrapped in an ErrorDuringImport exception and reraised. Unlike __import__, if a package path is specified, the module at the end of the path is returned, not the package at the beginning. If the optional 'force_load' argument is True, we reload the module from disk (unless it's a dynamic extension). \"\"\" try : # If force_load is True and the module has been previously loaded from # disk, we always have to reload the module. Checking the file's # mtime isn't good enough (e.g. the module could contain a class # that inherits from another module that has changed). if force_load and path in sys . modules : if path not in sys . builtin_module_names : # Remove the module from sys.modules and re-import to try # and avoid problems with partially loaded modules. # Also remove any submodules because they won't appear # in the newly loaded module's namespace if they're already # in sys.modules. subs = [ m for m in sys . modules if m . startswith ( path + \".\" )] for key in [ path ] + subs : # Prevent garbage collection. cache [ key ] = sys . modules [ key ] del sys . modules [ key ] module = __import__ ( path ) # pylint: disable=broad-except except BaseException as import_error : # Did the error occur before or after the module was found? ( exc , value , _ ) = info = sys . exc_info () if path in sys . modules : # An error occurred while executing the imported module. LOGGER . warning ( f \"Skipping safe_import for { path } , got a { import_error } \" ) raise ImportTimeError ( sys . modules [ path ] . __file__ , info ) from import_error if exc is SyntaxError : # A SyntaxError occurred before we could execute the module. # MR : this isn't null safe. LOGGER . warning ( f \"Skipping safe_import for { path } , got a { str ( exc ) } \" ) raise ImportTimeError ( cast ( SyntaxError , value ) . filename , info ) from import_error if issubclass ( exc , ImportError ) and cast ( ImportError , value ) . name == path : LOGGER . warning ( f \"Skipping safe_import for { path } , got a { import_error } \" ) LOGGER . warning ( f \"Cannot import this path: { path } \" ) # No such module in the path. return None LOGGER . warning ( f \"Skipping safe_import for { path } , got a { import_error } \" ) # Some other error occurred during the importing process. raise ImportTimeError ( path , sys . exc_info ()) from import_error for part in path . split ( \".\" )[ 1 :]: try : module = getattr ( module , part ) except AttributeError : LOGGER . warning ( f \"While safe_import - { str ( module ) } does not have { part } from dot path { path } \" ) return None return module def ispackage ( path : str ) -> bool : \"\"\"Guess whether a path refers to a package directory.\"\"\" if os . path . isdir ( path ): for ext in ( \".py\" , \".pyc\" ): if os . path . isfile ( os . path . join ( path , \"__init__\" + ext )): return True return False def locate ( path : str , force_load : bool = False ) -> Any : \"\"\"Locate an object by name or dotted path, importing as necessary.\"\"\" if \"-\" in path : # Not sure about this path = path . replace ( \"-\" , \"_\" ) LOGGER . debug ( f \"locate(): locating { path } \" ) parts = [ part for part in path . split ( \".\" ) if part ] module , index = None , 0 while index < len ( parts ): next_module = safe_import ( \".\" . join ( parts [: index + 1 ]), force_load ) if next_module : module , index = next_module , index + 1 else : break if module : the_object = module # this errors?! # LOGGER.debug(f\"putative module {str(the_object)}\") else : the_object = builtins for part in parts [ index :]: try : the_object = getattr ( the_object , part ) except AttributeError : LOGGER . debug ( f \"locate(): Don't think this is a module { the_object } \" ) return None return the_object","title":"Module pydoc_fork.inspector.module_utils"},{"location":"reference/pydoc_fork/inspector/module_utils/#variables","text":"LOGGER","title":"Variables"},{"location":"reference/pydoc_fork/inspector/module_utils/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/inspector/module_utils/#importfile","text":"def importfile ( path : str ) -> pydoc_fork . inspector . custom_types . TypeLike Import a Python source file or compiled file given its path. View Source def importfile ( path : str ) -> TypeLike : \"\"\"Import a Python source file or compiled file given its path.\"\"\" magic = importlib . util . MAGIC_NUMBER with open ( path , \"rb\" ) as file : is_bytecode = magic == file . read ( len ( magic )) filename = os . path . basename ( path ) name , _ = os . path . splitext ( filename ) if is_bytecode : loader = importlib . _bootstrap_external . SourcelessFileLoader ( name , path ) else : loader = importlib . _bootstrap_external . SourceFileLoader ( name , path ) # XXX We probably don't need to pass in the loader here. spec = importlib . util . spec_from_file_location ( name , path , loader = loader ) try : return cast ( TypeLike , importlib . _bootstrap . _load ( spec )) # pylint: disable=broad-except except BaseException as import_error : LOGGER . warning ( f \"Skipping importfile for {name} at {path}, got a {import_error}\" ) raise ImportTimeError ( path , sys . exc_info ()) from import_error","title":"importfile"},{"location":"reference/pydoc_fork/inspector/module_utils/#ispackage","text":"def ispackage ( path : str ) -> bool Guess whether a path refers to a package directory. View Source def ispackage ( path : str ) -> bool : \"\"\"Guess whether a path refers to a package directory.\"\"\" if os . path . isdir ( path ) : for ext in ( \".py\" , \".pyc\" ) : if os . path . isfile ( os . path . join ( path , \"__init__\" + ext )) : return True return False","title":"ispackage"},{"location":"reference/pydoc_fork/inspector/module_utils/#locate","text":"def locate ( path : str , force_load : bool = False ) -> Any Locate an object by name or dotted path, importing as necessary. View Source def locate ( path : str , force_load : bool = False ) -> Any : \"\"\"Locate an object by name or dotted path, importing as necessary.\"\"\" if \"-\" in path : # Not sure about this path = path . replace ( \"-\" , \"_\" ) LOGGER . debug ( f \"locate(): locating {path}\" ) parts = [ part for part in path . split ( \".\" ) if part ] module , index = None , 0 while index < len ( parts ): next_module = safe_import ( \".\" . join ( parts [: index + 1 ]), force_load ) if next_module : module , index = next_module , index + 1 else : break if module : the_object = module # this errors?! # LOGGER.debug(f\"putative module {str(the_object)}\") else : the_object = builtins for part in parts [ index :]: try : the_object = getattr ( the_object , part ) except AttributeError : LOGGER . debug ( f \"locate(): Don't think this is a module {the_object}\" ) return None return the_object","title":"locate"},{"location":"reference/pydoc_fork/inspector/module_utils/#safe_import","text":"def safe_import ( path : str , force_load : bool = False , cache : Dict [ str , Any ] = {} ) -> Any Import a module; handle errors; return None if the module isn't found. If the module is found but an exception occurs, it's wrapped in an ErrorDuringImport exception and reraised. Unlike import , if a package path is specified, the module at the end of the path is returned, not the package at the beginning. If the optional 'force_load' argument is True, we reload the module from disk (unless it's a dynamic extension). View Source def safe_import ( path : str , force_load : bool = False , cache : Dict [ str, Any ] = {} , # noqa - this is mutable on purpose ! ) -> Any : \"\"\" Import a module; handle errors; return None if the module isn't found. If the module *is* found but an exception occurs, it's wrapped in an ErrorDuringImport exception and reraised. Unlike __import__, if a package path is specified, the module at the end of the path is returned, not the package at the beginning. If the optional 'force_load' argument is True, we reload the module from disk (unless it's a dynamic extension). \"\"\" try : # If force_load is True and the module has been previously loaded from # disk , we always have to reload the module . Checking the file 's # mtime isn' t good enough ( e . g . the module could contain a class # that inherits from another module that has changed ). if force_load and path in sys . modules : if path not in sys . builtin_module_names : # Remove the module from sys . modules and re - import to try # and avoid problems with partially loaded modules . # Also remove any submodules because they won 't appear # in the newly loaded module' s namespace if they 're already # in sys.modules. subs = [m for m in sys.modules if m.startswith(path + \".\")] for key in [path] + subs: # Prevent garbage collection. cache[key] = sys.modules[key] del sys.modules[key] module = __import__(path) # pylint: disable=broad-except except BaseException as import_error: # Did the error occur before or after the module was found? (exc, value, _) = info = sys.exc_info() if path in sys.modules: # An error occurred while executing the imported module. LOGGER.warning(f\"Skipping safe_import for {path}, got a {import_error}\") raise ImportTimeError(sys.modules[path].__file__, info) from import_error if exc is SyntaxError: # A SyntaxError occurred before we could execute the module. # MR : this isn' t null safe . LOGGER . warning ( f \"Skipping safe_import for {path}, got a {str(exc)}\" ) raise ImportTimeError ( cast ( SyntaxError , value ). filename , info ) from import_error if issubclass ( exc , ImportError ) and cast ( ImportError , value ). name == path : LOGGER . warning ( f \"Skipping safe_import for {path}, got a {import_error}\" ) LOGGER . warning ( f \"Cannot import this path: {path}\" ) # No such module in the path . return None LOGGER . warning ( f \"Skipping safe_import for {path}, got a {import_error}\" ) # Some other error occurred during the importing process . raise ImportTimeError ( path , sys . exc_info ()) from import_error for part in path . split ( \".\" ) [ 1: ] : try : module = getattr ( module , part ) except AttributeError : LOGGER . warning ( f \"While safe_import - {str(module)} does not have {part} from dot path {path}\" ) return None return module","title":"safe_import"},{"location":"reference/pydoc_fork/inspector/module_utils/#classes","text":"","title":"Classes"},{"location":"reference/pydoc_fork/inspector/module_utils/#importtimeerror","text":"class ImportTimeError ( filename : Optional [ str ], exc_info : Tuple [ Any , Any , Any ] ) View Source class ImportTimeError ( Exception ): \"\"\"Errors that occurred while trying to import something to document it.\"\"\" def __init__ ( self , filename : Optional [ str ], exc_info : Tuple [ Any , Any , Any ]) -> None : \"\"\"Set up\"\"\" self . filename = filename # pylint: disable=invalid-name self . exc , self . value , self . tb = exc_info def __str__ ( self ) -> str : \"\"\"For display\"\"\" exc = self . exc . __name__ return f \"Problem in { self . filename } - { exc } : { self . value } \"","title":"ImportTimeError"},{"location":"reference/pydoc_fork/inspector/module_utils/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/pydoc_fork/inspector/module_utils/#class-variables","text":"args","title":"Class variables"},{"location":"reference/pydoc_fork/inspector/module_utils/#methods","text":"","title":"Methods"},{"location":"reference/pydoc_fork/inspector/module_utils/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/pydoc_fork/inspector/path_utils/","text":"Module pydoc_fork.inspector.path_utils Path Manipulation None View Source \"\"\" Path Manipulation \"\"\" import logging import os import sys from typing import List , Optional LOGGER = logging . getLogger ( __name__ ) def _get_revised_path ( current_python_path : List [ str ], script_path : str ) -> Optional [ List [ str ]]: \"\"\"Ensures current directory is on returned path, and argv0 directory is not Exception: argv0 dir is left alone if it's also pydoc's directory. Returns a new path entry list, or None if no adjustment is needed. \"\"\" # Scripts may get the current directory in their path by default if they're # run with the -m switch, or directly from the current directory. # The interactive prompt also allows imports from the current directory. # Accordingly, if the current directory is already present, don't make # any changes to the given_path if ( \"\" in current_python_path or os . curdir in current_python_path or os . getcwd () in current_python_path ): return None # Otherwise, add the current directory to the given path, and remove the # script directory (as long as the latter isn't also pydoc's directory. stdlib_dir = os . path . dirname ( __file__ ) script_dir = os . path . dirname ( script_path ) revised_path = current_python_path . copy () if script_dir in current_python_path and not os . path . samefile ( script_dir , stdlib_dir ): revised_path . remove ( script_dir ) revised_path . insert ( 0 , os . getcwd ()) return revised_path # Note: the tests only cover _get_revised_path, not _adjust_cli_path itself def _adjust_cli_sys_path () -> None : \"\"\"Ensures current directory is on sys.path, and __main__ directory is not. Exception: __main__ dir is left alone if it's also pydoc's directory. \"\"\" revised_path = _get_revised_path ( sys . path , sys . argv [ 0 ]) if revised_path is not None : sys . path [:] = revised_path def locate_file ( file_name : str , executing_file : str ) -> str : \"\"\" Find file relative to a source file, e.g. locate_file(\"foo/bar.txt\", __file__) Succeeds regardless to context of execution \"\"\" file_path = os . path . join ( os . path . dirname ( os . path . abspath ( executing_file )), file_name ) return file_path Variables LOGGER Functions locate_file def locate_file ( file_name : str , executing_file : str ) -> str Find file relative to a source file, e.g. locate_file(\"foo/bar.txt\", file ) Succeeds regardless to context of execution View Source def locate_file ( file_name: str , executing_file: str ) -> str: \"\"\" Find file relative to a source file , e . g . locate_file ( \"foo/bar.txt\" , __file__ ) Succeeds regardless to context of execution \"\"\" file_path = os . path . join ( os . path . dirname ( os . path . abspath ( executing_file )), file_name ) return file_path","title":"Path Utils"},{"location":"reference/pydoc_fork/inspector/path_utils/#module-pydoc_forkinspectorpath_utils","text":"Path Manipulation None View Source \"\"\" Path Manipulation \"\"\" import logging import os import sys from typing import List , Optional LOGGER = logging . getLogger ( __name__ ) def _get_revised_path ( current_python_path : List [ str ], script_path : str ) -> Optional [ List [ str ]]: \"\"\"Ensures current directory is on returned path, and argv0 directory is not Exception: argv0 dir is left alone if it's also pydoc's directory. Returns a new path entry list, or None if no adjustment is needed. \"\"\" # Scripts may get the current directory in their path by default if they're # run with the -m switch, or directly from the current directory. # The interactive prompt also allows imports from the current directory. # Accordingly, if the current directory is already present, don't make # any changes to the given_path if ( \"\" in current_python_path or os . curdir in current_python_path or os . getcwd () in current_python_path ): return None # Otherwise, add the current directory to the given path, and remove the # script directory (as long as the latter isn't also pydoc's directory. stdlib_dir = os . path . dirname ( __file__ ) script_dir = os . path . dirname ( script_path ) revised_path = current_python_path . copy () if script_dir in current_python_path and not os . path . samefile ( script_dir , stdlib_dir ): revised_path . remove ( script_dir ) revised_path . insert ( 0 , os . getcwd ()) return revised_path # Note: the tests only cover _get_revised_path, not _adjust_cli_path itself def _adjust_cli_sys_path () -> None : \"\"\"Ensures current directory is on sys.path, and __main__ directory is not. Exception: __main__ dir is left alone if it's also pydoc's directory. \"\"\" revised_path = _get_revised_path ( sys . path , sys . argv [ 0 ]) if revised_path is not None : sys . path [:] = revised_path def locate_file ( file_name : str , executing_file : str ) -> str : \"\"\" Find file relative to a source file, e.g. locate_file(\"foo/bar.txt\", __file__) Succeeds regardless to context of execution \"\"\" file_path = os . path . join ( os . path . dirname ( os . path . abspath ( executing_file )), file_name ) return file_path","title":"Module pydoc_fork.inspector.path_utils"},{"location":"reference/pydoc_fork/inspector/path_utils/#variables","text":"LOGGER","title":"Variables"},{"location":"reference/pydoc_fork/inspector/path_utils/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/inspector/path_utils/#locate_file","text":"def locate_file ( file_name : str , executing_file : str ) -> str Find file relative to a source file, e.g. locate_file(\"foo/bar.txt\", file ) Succeeds regardless to context of execution View Source def locate_file ( file_name: str , executing_file: str ) -> str: \"\"\" Find file relative to a source file , e . g . locate_file ( \"foo/bar.txt\" , __file__ ) Succeeds regardless to context of execution \"\"\" file_path = os . path . join ( os . path . dirname ( os . path . abspath ( executing_file )), file_name ) return file_path","title":"locate_file"},{"location":"reference/pydoc_fork/inspector/utils/","text":"Module pydoc_fork.inspector.utils Unclassified utils None View Source \"\"\" Unclassified utils \"\"\" import inspect import logging import re import sys from modulefinder import Module from typing import Any , Callable , List , Optional , Sequence , Tuple , Union , cast from pydoc_fork . inspector . custom_types import TypeLike from pydoc_fork . inspector . module_utils import locate LOGGER = logging . getLogger ( __ name__ ) def resolve ( thing : Union [ str , Any ], force_load: bool = False ) -> Tuple [ Any , Any ] : \"\"\"Given an object or a path to an object, get the object and its name.\"\"\" if isinstance ( thing , str ) : the_object = locate ( thing , force_load ) if the_object is None : raise ImportError ( \"\"\"\\ No Python documentation found for %r.\"\"\" % thing ) return the_object , thing name = getattr ( thing , \"__name__\" , None ) if isinstance ( name , str ) : return thing , name return thing , str ( thing ) # HACK def describe ( thing : TypeLike ) -> str : \"\"\"Produce a short description of the given thing.\"\"\" if inspect . ismodule ( thing ) : if thing . __ name__ in sys . builtin_module_names: return \"built-in module \" + thing . __ name__ if hasattr ( thing , \"__path__\" ) : return \"package \" + thing . __ name__ return \"module \" + thing . __ name__ if inspect . isbuiltin ( thing ) : return \"built-in function \" + thing . __ name__ if inspect . isgetsetdescriptor ( thing ) : return f \"getset descriptor {thing.__objclass__.__module__}.{thing.__objclass__.__name__}.{thing.__name__}\" if inspect . ismemberdescriptor ( thing ) : return f \"member descriptor {thing.__objclass__.__module__}.{thing.__objclass__.__name__}.{thing.__name__}\" if inspect . isclass ( thing ) : return \"class \" + thing . __ name__ if inspect . isfunction ( thing ) : return \"function \" + thing . __ name__ if inspect . ismethod ( thing ) : return \"method \" + thing . __ name__ return type ( thing ). __ name__ def _ find_class ( func : TypeLike ) -> Optional [ Module ] : \"\"\"Find a Class\"\"\" cls = sys . modules . get ( func . __ module__ ) if cls is None : return None for name in func . __ qualname__ . split ( \".\" )[:- 1 ] : cls = getattr ( cls , name ) if not inspect . isclass ( cls ) : return None return cls # type : ignore def _ find_doc_string ( obj : TypeLike ) -> Optional [ str ] : \"\"\"Find doc string\"\"\" if inspect . ismethod ( obj ) : name = obj . __ func__ . __ name__ self = obj . __ self__ if ( inspect . isclass ( self ) and getattr ( getattr ( self , name , None ), \"__func__\" ) is obj . __ func__ # noqa ) : # class_method cls = self else : cls = self . __ class__ elif inspect . isfunction ( obj ) : name = obj . __ name__ cls = _ find_class ( obj ) if cls is None or getattr ( cls , name ) is not obj : return None elif inspect . isbuiltin ( obj ) : name = obj . __ name__ self = obj . __ self__ if inspect . isclass ( self ) and self . __ qualname__ + \".\" + name == obj . __ qualname__: # class_method cls = self else : cls = self . __ class__ # Should be tested before isdatadescriptor (). elif isinstance ( obj , property ) : func = obj . fget name = func . __ name__ cls = _ find_class ( cast ( TypeLike , func )) if cls is None or getattr ( cls , name ) is not obj : return None elif inspect . ismethoddescriptor ( obj ) or inspect . isdatadescriptor ( obj ) : name = obj . __ name__ cls = obj . __ objclass__ if getattr ( cls , name ) is not obj : return None if inspect . ismemberdescriptor ( obj ) : slots = getattr ( cls , \"__slots__\" , None ) if isinstance ( slots , dict ) and name in slots : return slots [ name ] else : return None for base in cls . __ mro__: try : doc = _ get_own_doc_string ( getattr ( base , name )) except AttributeError : continue if doc is not None : return doc return None def _ get_own_doc_string ( obj : TypeLike ) -> str : \"\"\"Get the documentation string for an object if it is not inherited from its class.\"\"\" try : doc = object . __ getattribute__ ( obj , \"__doc__\" ) if doc is None : return \"\" # null safety if obj is not type : typedoc = type ( obj ). __ doc__ if isinstance ( typedoc , str ) and typedoc == doc : return \"\" # null safety return cast ( str , doc ) except AttributeError : LOGGER . debug ( f \"No docstring for {str(obj)}\" ) return \"\" # null safety def _ getdoc ( the_object: TypeLike ) -> str : \"\"\" Get the documentation string for an object. All tabs are expanded to spaces. To clean up docstrings that are indented to line up with blocks of code, any whitespace than can be uniformly removed from the second line onwards is removed. \"\"\" doc = _ get_own_doc_string ( the_object ) if doc is None : try : doc = _ find_doc_string ( the_object ) except ( AttributeError , TypeError ) : return \"\" # null safety if not isinstance ( doc , str ) : return \"\" # null safety result = inspect . cleandoc ( doc ) # not sure what to do with this not sure it validates . # from docstring_parser import parse # parsed_result = parse ( result ) # https : // pypi . org / project / jsonnet - docblock - parser / return result def getdoc ( the_object: TypeLike ) -> str : \"\"\"Get the doc string or comments for an object.\"\"\" result = _ getdoc ( the_object ) or inspect . getcomments ( the_object ) return result and re . sub ( \"^ *\\n\" , \"\" , result . rstrip ()) or \"\" def classname ( the_object: TypeLike , modname : str ) -> str : \"\"\"Get a class name and qualify it with a module name if necessary.\"\"\" name = the_object . __ name__ if the_object . __ module__ ! = modname : name = the_object . __ module__ + \".\" + name return name def isdata ( the_object: Any ) -> bool : \"\"\"Check if an object is of a type that probably means it's data.\"\"\" return not ( inspect . ismodule ( the_object ) or inspect . isclass ( the_object ) or inspect . isroutine ( the_object ) or inspect . isframe ( the_object ) or inspect . istraceback ( the_object ) or inspect . iscode ( the_object ) ) def _ is_bound_method ( the_function: object ) -> bool : \"\"\" Returns True if fn is a bound method, regardless of whether fn was implemented in Python or in C. \"\"\" if inspect . ismethod ( the_function ) : return True if inspect . isbuiltin ( the_function ) : self = getattr ( the_function , \"__self__\" , None ) return not ( inspect . ismodule ( self ) or ( self is None )) return False # def all_methods ( cl : type ) -> Dict [ str , Any ] : # \"\"\"all methods\"\"\" # methods = {} # for key , value in inspect . getmembers ( cl , inspect . isroutine ) : # methods [ key ] = 1 # for base in cl . __ bases__: # methods . update ( all_methods ( base )) # all your base are belong to us # for key in methods . keys () : # methods [ key ] = getattr ( cl , key ) # return methods def _ split_list ( the_sequence: Sequence [ Any ], predicate : Callable [[ Any ], Any ] ) -> Tuple [ List [ Any ], List [ Any ]] : \"\"\"Split sequence s via predicate, and return pair ([true], [false]). The return value is a 2-tuple of lists, ([x for x in s if predicate(x)], [x for x in s if not predicate(x)]) \"\"\" yes = [] # pylint : disable = invalid - name no = [] for x in the_sequence: if predicate ( x ) : yes . append ( x ) else : no . append ( x ) return yes , no def visiblename ( name : str , all_things: Optional [ List [ str ]] = None , obj : Optional [ Any ] = None ) -> bool : \"\"\"Decide whether to show documentation on a variable.\"\"\" # Certain special names are redundant or internal . # XXX Remove __ initializing__? if name in { # people use these for all sorts of things # \"__author__\" , # \"__credits__\" , # \"__date__\" , # \"__version__\" , # # These are internal implementation details USUALLY \"__builtins__\" , \"__cached__\" , \"__doc__\" , \"__file__\" , \"__spec__\" , \"__loader__\" , \"__module__\" , \"__name__\" , \"__package__\" , \"__path__\" , \"__qualname__\" , \"__slots__\" , \"__dict__\" , \"__weakref__\" , } : return False # Private names are hidden , but special names are displayed . if name . startswith ( \"__\" ) and name . endswith ( \"__\" ) : return True # Namedtuples have public fields and methods with a single leading underscore if name . startswith ( \"_\" ) and hasattr ( obj , \"_fields\" ) : return True if all_things is not None : # only document that which the programmer exported in __ all__ return name in all_things return not name . startswith ( \"_\" ) def classify_class_attrs ( the_object: TypeLike ) -> List [ Tuple [ str , str , type , object ]] : \"\"\"Wrap inspect.classify_class_attrs, with fixup for data descriptors.\"\"\" results = [] try : for ( name , kind , cls , value ) in inspect . classify_class_attrs ( cast ( type , the_object ) ) : if inspect . isdatadescriptor ( value ) : kind = \"data descriptor\" if isinstance ( value , property ) and value . fset is None : kind = \"readonly property\" results . append (( name , kind , cls , value )) except ValueError : LOGGER . warning ( f \"Skipping classify_class_attrs for {str(the_object)} got ValueError, maybe this is a Namespace\" ) # py . _ xmlgen . Namespace # ValueError : Namespace class is abstract return results def sort_attributes ( attrs : List [ Any ], the_object: Union [ TypeLike , type ]) -> None : \"\"\"Sort the attrs list in-place by _fields and then alphabetically by name\"\"\" # This allows data descriptors to be ordered according # to a _ fields attribute if present . fields = getattr ( the_object , \"_fields\" , []) try : field_order = { name : i - len ( fields ) for ( i , name ) in enumerate ( fields )} except TypeError : field_order = {} def key_function ( attr : List [ Any ]) -> Tuple [ Any , Any ] : \"\"\"Sorting function\"\"\" return field_order . get ( attr [ 0 ], 0 ), attr [ 0 ] attrs . sort ( key = key_function ) Variables LOGGER Functions classify_class_attrs def classify_class_attrs ( the_object : pydoc_fork . inspector . custom_types . TypeLike ) -> List [ Tuple [ str , str , type , object ]] Wrap inspect.classify_class_attrs, with fixup for data descriptors. View Source def classify_class_attrs ( the_object : TypeLike ) -> List [ Tuple [ str , str , type , object ]] : \"\"\"Wrap inspect.classify_class_attrs, with fixup for data descriptors.\"\"\" results = [] try : for ( name , kind , cls , value ) in inspect . classify_class_attrs ( cast ( type , the_object ) ) : if inspect . isdatadescriptor ( value ) : kind = \"data descriptor\" if isinstance ( value , property ) and value . fset is None : kind = \"readonly property\" results . append (( name , kind , cls , value )) except ValueError : LOGGER . warning ( f \"Skipping classify_class_attrs for {str(the_object)} got ValueError, maybe this is a Namespace\" ) # py . _xmlgen . Namespace # ValueError : Namespace class is abstract return results classname def classname ( the_object : pydoc_fork . inspector . custom_types . TypeLike , modname : str ) -> str Get a class name and qualify it with a module name if necessary. View Source def classname ( the_object : TypeLike , modname : str ) -> str : \"\"\"Get a class name and qualify it with a module name if necessary.\"\"\" name = the_object . __name__ if the_object . __module__ != modname : name = the_object . __module__ + \".\" + name return name describe def describe ( thing : pydoc_fork . inspector . custom_types . TypeLike ) -> str Produce a short description of the given thing. View Source def describe ( thing : TypeLike ) -> str : \"\"\"Produce a short description of the given thing.\"\"\" if inspect . ismodule ( thing ) : if thing . __name__ in sys . builtin_module_names : return \"built-in module \" + thing . __name__ if hasattr ( thing , \"__path__\" ) : return \"package \" + thing . __name__ return \"module \" + thing . __name__ if inspect . isbuiltin ( thing ) : return \"built-in function \" + thing . __name__ if inspect . isgetsetdescriptor ( thing ) : return f \"getset descriptor {thing.__objclass__.__module__}.{thing.__objclass__.__name__}.{thing.__name__}\" if inspect . ismemberdescriptor ( thing ) : return f \"member descriptor {thing.__objclass__.__module__}.{thing.__objclass__.__name__}.{thing.__name__}\" if inspect . isclass ( thing ) : return \"class \" + thing . __name__ if inspect . isfunction ( thing ) : return \"function \" + thing . __name__ if inspect . ismethod ( thing ) : return \"method \" + thing . __name__ return type ( thing ). __name__ getdoc def getdoc ( the_object : pydoc_fork . inspector . custom_types . TypeLike ) -> str Get the doc string or comments for an object. View Source def getdoc ( the_object : TypeLike ) -> str : \"\"\"Get the doc string or comments for an object.\"\"\" result = _getdoc ( the_object ) or inspect . getcomments ( the_object ) return result and re . sub ( \"^ *\\n\" , \"\" , result . rstrip ()) or \"\" isdata def isdata ( the_object : Any ) -> bool Check if an object is of a type that probably means it's data. View Source def isdata ( the_object : Any ) -> bool : \"\"\"Check if an object is of a type that probably means it' s data . \"\"\" return not ( inspect.ismodule(the_object) or inspect.isclass(the_object) or inspect.isroutine(the_object) or inspect.isframe(the_object) or inspect.istraceback(the_object) or inspect.iscode(the_object) ) resolve def resolve ( thing : Union [ str , Any ], force_load : bool = False ) -> Tuple [ Any , Any ] Given an object or a path to an object, get the object and its name. View Source def resolve ( thing : Union [ str , Any ], force_load : bool = False ) -> Tuple [ Any , Any ]: \"\"\"Given an object or a path to an object, get the object and its name.\"\"\" if isinstance ( thing , str ): the_object = locate ( thing , force_load ) if the_object is None : raise ImportError ( \"\"\"\\ No Python documentation found for %r.\"\"\" % thing ) return the_object , thing name = getattr ( thing , \"__name__\" , None ) if isinstance ( name , str ): return thing , name return thing , str ( thing ) # HACK sort_attributes def sort_attributes ( attrs : List [ Any ], the_object : Union [ pydoc_fork . inspector . custom_types . TypeLike , type ] ) -> None Sort the attrs list in-place by _fields and then alphabetically by name View Source def sort_attributes ( attrs : List [ Any ] , the_object : Union [ TypeLike, type ] ) -> None : \"\"\"Sort the attrs list in-place by _fields and then alphabetically by name\"\"\" # This allows data descriptors to be ordered according # to a _fields attribute if present . fields = getattr ( the_object , \"_fields\" , [] ) try : field_order = { name : i - len ( fields ) for ( i , name ) in enumerate ( fields ) } except TypeError : field_order = {} def key_function ( attr : List [ Any ] ) -> Tuple [ Any, Any ] : \"\"\"Sorting function\"\"\" return field_order . get ( attr [ 0 ] , 0 ), attr [ 0 ] attrs . sort ( key = key_function ) visiblename def visiblename ( name : str , all_things : Optional [ List [ str ]] = None , obj : Optional [ Any ] = None ) -> bool Decide whether to show documentation on a variable. View Source def visiblename ( name : str , all_things : Optional [ List [ str ]] = None , obj : Optional [ Any ] = None ) -> bool : \"\"\"Decide whether to show documentation on a variable.\"\"\" # Certain special names are redundant or internal. # XXX Remove __initializing__? if name in { # people use these for all sorts of things # \"__author__\", # \"__credits__\", # \"__date__\", # \"__version__\", # # These are internal implementation details USUALLY \"__builtins__\" , \"__cached__\" , \"__doc__\" , \"__file__\" , \"__spec__\" , \"__loader__\" , \"__module__\" , \"__name__\" , \"__package__\" , \"__path__\" , \"__qualname__\" , \"__slots__\" , \"__dict__\" , \"__weakref__\" , }: return False # Private names are hidden, but special names are displayed. if name . startswith ( \"__\" ) and name . endswith ( \"__\" ): return True # Namedtuples have public fields and methods with a single leading underscore if name . startswith ( \"_\" ) and hasattr ( obj , \"_fields\" ): return True if all_things is not None : # only document that which the programmer exported in __all__ return name in all_things return not name . startswith ( \"_\" )","title":"Utils"},{"location":"reference/pydoc_fork/inspector/utils/#module-pydoc_forkinspectorutils","text":"Unclassified utils None View Source \"\"\" Unclassified utils \"\"\" import inspect import logging import re import sys from modulefinder import Module from typing import Any , Callable , List , Optional , Sequence , Tuple , Union , cast from pydoc_fork . inspector . custom_types import TypeLike from pydoc_fork . inspector . module_utils import locate LOGGER = logging . getLogger ( __ name__ ) def resolve ( thing : Union [ str , Any ], force_load: bool = False ) -> Tuple [ Any , Any ] : \"\"\"Given an object or a path to an object, get the object and its name.\"\"\" if isinstance ( thing , str ) : the_object = locate ( thing , force_load ) if the_object is None : raise ImportError ( \"\"\"\\ No Python documentation found for %r.\"\"\" % thing ) return the_object , thing name = getattr ( thing , \"__name__\" , None ) if isinstance ( name , str ) : return thing , name return thing , str ( thing ) # HACK def describe ( thing : TypeLike ) -> str : \"\"\"Produce a short description of the given thing.\"\"\" if inspect . ismodule ( thing ) : if thing . __ name__ in sys . builtin_module_names: return \"built-in module \" + thing . __ name__ if hasattr ( thing , \"__path__\" ) : return \"package \" + thing . __ name__ return \"module \" + thing . __ name__ if inspect . isbuiltin ( thing ) : return \"built-in function \" + thing . __ name__ if inspect . isgetsetdescriptor ( thing ) : return f \"getset descriptor {thing.__objclass__.__module__}.{thing.__objclass__.__name__}.{thing.__name__}\" if inspect . ismemberdescriptor ( thing ) : return f \"member descriptor {thing.__objclass__.__module__}.{thing.__objclass__.__name__}.{thing.__name__}\" if inspect . isclass ( thing ) : return \"class \" + thing . __ name__ if inspect . isfunction ( thing ) : return \"function \" + thing . __ name__ if inspect . ismethod ( thing ) : return \"method \" + thing . __ name__ return type ( thing ). __ name__ def _ find_class ( func : TypeLike ) -> Optional [ Module ] : \"\"\"Find a Class\"\"\" cls = sys . modules . get ( func . __ module__ ) if cls is None : return None for name in func . __ qualname__ . split ( \".\" )[:- 1 ] : cls = getattr ( cls , name ) if not inspect . isclass ( cls ) : return None return cls # type : ignore def _ find_doc_string ( obj : TypeLike ) -> Optional [ str ] : \"\"\"Find doc string\"\"\" if inspect . ismethod ( obj ) : name = obj . __ func__ . __ name__ self = obj . __ self__ if ( inspect . isclass ( self ) and getattr ( getattr ( self , name , None ), \"__func__\" ) is obj . __ func__ # noqa ) : # class_method cls = self else : cls = self . __ class__ elif inspect . isfunction ( obj ) : name = obj . __ name__ cls = _ find_class ( obj ) if cls is None or getattr ( cls , name ) is not obj : return None elif inspect . isbuiltin ( obj ) : name = obj . __ name__ self = obj . __ self__ if inspect . isclass ( self ) and self . __ qualname__ + \".\" + name == obj . __ qualname__: # class_method cls = self else : cls = self . __ class__ # Should be tested before isdatadescriptor (). elif isinstance ( obj , property ) : func = obj . fget name = func . __ name__ cls = _ find_class ( cast ( TypeLike , func )) if cls is None or getattr ( cls , name ) is not obj : return None elif inspect . ismethoddescriptor ( obj ) or inspect . isdatadescriptor ( obj ) : name = obj . __ name__ cls = obj . __ objclass__ if getattr ( cls , name ) is not obj : return None if inspect . ismemberdescriptor ( obj ) : slots = getattr ( cls , \"__slots__\" , None ) if isinstance ( slots , dict ) and name in slots : return slots [ name ] else : return None for base in cls . __ mro__: try : doc = _ get_own_doc_string ( getattr ( base , name )) except AttributeError : continue if doc is not None : return doc return None def _ get_own_doc_string ( obj : TypeLike ) -> str : \"\"\"Get the documentation string for an object if it is not inherited from its class.\"\"\" try : doc = object . __ getattribute__ ( obj , \"__doc__\" ) if doc is None : return \"\" # null safety if obj is not type : typedoc = type ( obj ). __ doc__ if isinstance ( typedoc , str ) and typedoc == doc : return \"\" # null safety return cast ( str , doc ) except AttributeError : LOGGER . debug ( f \"No docstring for {str(obj)}\" ) return \"\" # null safety def _ getdoc ( the_object: TypeLike ) -> str : \"\"\" Get the documentation string for an object. All tabs are expanded to spaces. To clean up docstrings that are indented to line up with blocks of code, any whitespace than can be uniformly removed from the second line onwards is removed. \"\"\" doc = _ get_own_doc_string ( the_object ) if doc is None : try : doc = _ find_doc_string ( the_object ) except ( AttributeError , TypeError ) : return \"\" # null safety if not isinstance ( doc , str ) : return \"\" # null safety result = inspect . cleandoc ( doc ) # not sure what to do with this not sure it validates . # from docstring_parser import parse # parsed_result = parse ( result ) # https : // pypi . org / project / jsonnet - docblock - parser / return result def getdoc ( the_object: TypeLike ) -> str : \"\"\"Get the doc string or comments for an object.\"\"\" result = _ getdoc ( the_object ) or inspect . getcomments ( the_object ) return result and re . sub ( \"^ *\\n\" , \"\" , result . rstrip ()) or \"\" def classname ( the_object: TypeLike , modname : str ) -> str : \"\"\"Get a class name and qualify it with a module name if necessary.\"\"\" name = the_object . __ name__ if the_object . __ module__ ! = modname : name = the_object . __ module__ + \".\" + name return name def isdata ( the_object: Any ) -> bool : \"\"\"Check if an object is of a type that probably means it's data.\"\"\" return not ( inspect . ismodule ( the_object ) or inspect . isclass ( the_object ) or inspect . isroutine ( the_object ) or inspect . isframe ( the_object ) or inspect . istraceback ( the_object ) or inspect . iscode ( the_object ) ) def _ is_bound_method ( the_function: object ) -> bool : \"\"\" Returns True if fn is a bound method, regardless of whether fn was implemented in Python or in C. \"\"\" if inspect . ismethod ( the_function ) : return True if inspect . isbuiltin ( the_function ) : self = getattr ( the_function , \"__self__\" , None ) return not ( inspect . ismodule ( self ) or ( self is None )) return False # def all_methods ( cl : type ) -> Dict [ str , Any ] : # \"\"\"all methods\"\"\" # methods = {} # for key , value in inspect . getmembers ( cl , inspect . isroutine ) : # methods [ key ] = 1 # for base in cl . __ bases__: # methods . update ( all_methods ( base )) # all your base are belong to us # for key in methods . keys () : # methods [ key ] = getattr ( cl , key ) # return methods def _ split_list ( the_sequence: Sequence [ Any ], predicate : Callable [[ Any ], Any ] ) -> Tuple [ List [ Any ], List [ Any ]] : \"\"\"Split sequence s via predicate, and return pair ([true], [false]). The return value is a 2-tuple of lists, ([x for x in s if predicate(x)], [x for x in s if not predicate(x)]) \"\"\" yes = [] # pylint : disable = invalid - name no = [] for x in the_sequence: if predicate ( x ) : yes . append ( x ) else : no . append ( x ) return yes , no def visiblename ( name : str , all_things: Optional [ List [ str ]] = None , obj : Optional [ Any ] = None ) -> bool : \"\"\"Decide whether to show documentation on a variable.\"\"\" # Certain special names are redundant or internal . # XXX Remove __ initializing__? if name in { # people use these for all sorts of things # \"__author__\" , # \"__credits__\" , # \"__date__\" , # \"__version__\" , # # These are internal implementation details USUALLY \"__builtins__\" , \"__cached__\" , \"__doc__\" , \"__file__\" , \"__spec__\" , \"__loader__\" , \"__module__\" , \"__name__\" , \"__package__\" , \"__path__\" , \"__qualname__\" , \"__slots__\" , \"__dict__\" , \"__weakref__\" , } : return False # Private names are hidden , but special names are displayed . if name . startswith ( \"__\" ) and name . endswith ( \"__\" ) : return True # Namedtuples have public fields and methods with a single leading underscore if name . startswith ( \"_\" ) and hasattr ( obj , \"_fields\" ) : return True if all_things is not None : # only document that which the programmer exported in __ all__ return name in all_things return not name . startswith ( \"_\" ) def classify_class_attrs ( the_object: TypeLike ) -> List [ Tuple [ str , str , type , object ]] : \"\"\"Wrap inspect.classify_class_attrs, with fixup for data descriptors.\"\"\" results = [] try : for ( name , kind , cls , value ) in inspect . classify_class_attrs ( cast ( type , the_object ) ) : if inspect . isdatadescriptor ( value ) : kind = \"data descriptor\" if isinstance ( value , property ) and value . fset is None : kind = \"readonly property\" results . append (( name , kind , cls , value )) except ValueError : LOGGER . warning ( f \"Skipping classify_class_attrs for {str(the_object)} got ValueError, maybe this is a Namespace\" ) # py . _ xmlgen . Namespace # ValueError : Namespace class is abstract return results def sort_attributes ( attrs : List [ Any ], the_object: Union [ TypeLike , type ]) -> None : \"\"\"Sort the attrs list in-place by _fields and then alphabetically by name\"\"\" # This allows data descriptors to be ordered according # to a _ fields attribute if present . fields = getattr ( the_object , \"_fields\" , []) try : field_order = { name : i - len ( fields ) for ( i , name ) in enumerate ( fields )} except TypeError : field_order = {} def key_function ( attr : List [ Any ]) -> Tuple [ Any , Any ] : \"\"\"Sorting function\"\"\" return field_order . get ( attr [ 0 ], 0 ), attr [ 0 ] attrs . sort ( key = key_function )","title":"Module pydoc_fork.inspector.utils"},{"location":"reference/pydoc_fork/inspector/utils/#variables","text":"LOGGER","title":"Variables"},{"location":"reference/pydoc_fork/inspector/utils/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/inspector/utils/#classify_class_attrs","text":"def classify_class_attrs ( the_object : pydoc_fork . inspector . custom_types . TypeLike ) -> List [ Tuple [ str , str , type , object ]] Wrap inspect.classify_class_attrs, with fixup for data descriptors. View Source def classify_class_attrs ( the_object : TypeLike ) -> List [ Tuple [ str , str , type , object ]] : \"\"\"Wrap inspect.classify_class_attrs, with fixup for data descriptors.\"\"\" results = [] try : for ( name , kind , cls , value ) in inspect . classify_class_attrs ( cast ( type , the_object ) ) : if inspect . isdatadescriptor ( value ) : kind = \"data descriptor\" if isinstance ( value , property ) and value . fset is None : kind = \"readonly property\" results . append (( name , kind , cls , value )) except ValueError : LOGGER . warning ( f \"Skipping classify_class_attrs for {str(the_object)} got ValueError, maybe this is a Namespace\" ) # py . _xmlgen . Namespace # ValueError : Namespace class is abstract return results","title":"classify_class_attrs"},{"location":"reference/pydoc_fork/inspector/utils/#classname","text":"def classname ( the_object : pydoc_fork . inspector . custom_types . TypeLike , modname : str ) -> str Get a class name and qualify it with a module name if necessary. View Source def classname ( the_object : TypeLike , modname : str ) -> str : \"\"\"Get a class name and qualify it with a module name if necessary.\"\"\" name = the_object . __name__ if the_object . __module__ != modname : name = the_object . __module__ + \".\" + name return name","title":"classname"},{"location":"reference/pydoc_fork/inspector/utils/#describe","text":"def describe ( thing : pydoc_fork . inspector . custom_types . TypeLike ) -> str Produce a short description of the given thing. View Source def describe ( thing : TypeLike ) -> str : \"\"\"Produce a short description of the given thing.\"\"\" if inspect . ismodule ( thing ) : if thing . __name__ in sys . builtin_module_names : return \"built-in module \" + thing . __name__ if hasattr ( thing , \"__path__\" ) : return \"package \" + thing . __name__ return \"module \" + thing . __name__ if inspect . isbuiltin ( thing ) : return \"built-in function \" + thing . __name__ if inspect . isgetsetdescriptor ( thing ) : return f \"getset descriptor {thing.__objclass__.__module__}.{thing.__objclass__.__name__}.{thing.__name__}\" if inspect . ismemberdescriptor ( thing ) : return f \"member descriptor {thing.__objclass__.__module__}.{thing.__objclass__.__name__}.{thing.__name__}\" if inspect . isclass ( thing ) : return \"class \" + thing . __name__ if inspect . isfunction ( thing ) : return \"function \" + thing . __name__ if inspect . ismethod ( thing ) : return \"method \" + thing . __name__ return type ( thing ). __name__","title":"describe"},{"location":"reference/pydoc_fork/inspector/utils/#getdoc","text":"def getdoc ( the_object : pydoc_fork . inspector . custom_types . TypeLike ) -> str Get the doc string or comments for an object. View Source def getdoc ( the_object : TypeLike ) -> str : \"\"\"Get the doc string or comments for an object.\"\"\" result = _getdoc ( the_object ) or inspect . getcomments ( the_object ) return result and re . sub ( \"^ *\\n\" , \"\" , result . rstrip ()) or \"\"","title":"getdoc"},{"location":"reference/pydoc_fork/inspector/utils/#isdata","text":"def isdata ( the_object : Any ) -> bool Check if an object is of a type that probably means it's data. View Source def isdata ( the_object : Any ) -> bool : \"\"\"Check if an object is of a type that probably means it' s data . \"\"\" return not ( inspect.ismodule(the_object) or inspect.isclass(the_object) or inspect.isroutine(the_object) or inspect.isframe(the_object) or inspect.istraceback(the_object) or inspect.iscode(the_object) )","title":"isdata"},{"location":"reference/pydoc_fork/inspector/utils/#resolve","text":"def resolve ( thing : Union [ str , Any ], force_load : bool = False ) -> Tuple [ Any , Any ] Given an object or a path to an object, get the object and its name. View Source def resolve ( thing : Union [ str , Any ], force_load : bool = False ) -> Tuple [ Any , Any ]: \"\"\"Given an object or a path to an object, get the object and its name.\"\"\" if isinstance ( thing , str ): the_object = locate ( thing , force_load ) if the_object is None : raise ImportError ( \"\"\"\\ No Python documentation found for %r.\"\"\" % thing ) return the_object , thing name = getattr ( thing , \"__name__\" , None ) if isinstance ( name , str ): return thing , name return thing , str ( thing ) # HACK","title":"resolve"},{"location":"reference/pydoc_fork/inspector/utils/#sort_attributes","text":"def sort_attributes ( attrs : List [ Any ], the_object : Union [ pydoc_fork . inspector . custom_types . TypeLike , type ] ) -> None Sort the attrs list in-place by _fields and then alphabetically by name View Source def sort_attributes ( attrs : List [ Any ] , the_object : Union [ TypeLike, type ] ) -> None : \"\"\"Sort the attrs list in-place by _fields and then alphabetically by name\"\"\" # This allows data descriptors to be ordered according # to a _fields attribute if present . fields = getattr ( the_object , \"_fields\" , [] ) try : field_order = { name : i - len ( fields ) for ( i , name ) in enumerate ( fields ) } except TypeError : field_order = {} def key_function ( attr : List [ Any ] ) -> Tuple [ Any, Any ] : \"\"\"Sorting function\"\"\" return field_order . get ( attr [ 0 ] , 0 ), attr [ 0 ] attrs . sort ( key = key_function )","title":"sort_attributes"},{"location":"reference/pydoc_fork/inspector/utils/#visiblename","text":"def visiblename ( name : str , all_things : Optional [ List [ str ]] = None , obj : Optional [ Any ] = None ) -> bool Decide whether to show documentation on a variable. View Source def visiblename ( name : str , all_things : Optional [ List [ str ]] = None , obj : Optional [ Any ] = None ) -> bool : \"\"\"Decide whether to show documentation on a variable.\"\"\" # Certain special names are redundant or internal. # XXX Remove __initializing__? if name in { # people use these for all sorts of things # \"__author__\", # \"__credits__\", # \"__date__\", # \"__version__\", # # These are internal implementation details USUALLY \"__builtins__\" , \"__cached__\" , \"__doc__\" , \"__file__\" , \"__spec__\" , \"__loader__\" , \"__module__\" , \"__name__\" , \"__package__\" , \"__path__\" , \"__qualname__\" , \"__slots__\" , \"__dict__\" , \"__weakref__\" , }: return False # Private names are hidden, but special names are displayed. if name . startswith ( \"__\" ) and name . endswith ( \"__\" ): return True # Namedtuples have public fields and methods with a single leading underscore if name . startswith ( \"_\" ) and hasattr ( obj , \"_fields\" ): return True if all_things is not None : # only document that which the programmer exported in __all__ return name in all_things return not name . startswith ( \"_\" )","title":"visiblename"},{"location":"reference/pydoc_fork/reporter/","text":"Module pydoc_fork.reporter This module has everything that turns type info into html. It also has a lot of type-lookup and type-discovery logic woven into into it, what we'd call a bad separation of concerns. View Source \"\"\" This module has everything that turns type info into html. It also has a lot of type-lookup and type-discovery logic woven into into it, what we'd call a bad separation of concerns. \"\"\" Sub-modules pydoc_fork.reporter.format_class pydoc_fork.reporter.format_data pydoc_fork.reporter.format_module pydoc_fork.reporter.format_other pydoc_fork.reporter.format_page pydoc_fork.reporter.format_routine pydoc_fork.reporter.formatter_html pydoc_fork.reporter.html_repr_class pydoc_fork.reporter.inline_styles pydoc_fork.reporter.jinja_code pydoc_fork.reporter.rst_support pydoc_fork.reporter.string_utils","title":"Index"},{"location":"reference/pydoc_fork/reporter/#module-pydoc_forkreporter","text":"This module has everything that turns type info into html. It also has a lot of type-lookup and type-discovery logic woven into into it, what we'd call a bad separation of concerns. View Source \"\"\" This module has everything that turns type info into html. It also has a lot of type-lookup and type-discovery logic woven into into it, what we'd call a bad separation of concerns. \"\"\"","title":"Module pydoc_fork.reporter"},{"location":"reference/pydoc_fork/reporter/#sub-modules","text":"pydoc_fork.reporter.format_class pydoc_fork.reporter.format_data pydoc_fork.reporter.format_module pydoc_fork.reporter.format_other pydoc_fork.reporter.format_page pydoc_fork.reporter.format_routine pydoc_fork.reporter.formatter_html pydoc_fork.reporter.html_repr_class pydoc_fork.reporter.inline_styles pydoc_fork.reporter.jinja_code pydoc_fork.reporter.rst_support pydoc_fork.reporter.string_utils","title":"Sub-modules"},{"location":"reference/pydoc_fork/reporter/format_class/","text":"Module pydoc_fork.reporter.format_class Roughly a UI component for classes None View Source \"\"\" Roughly a UI component for classes \"\"\" import builtins import inspect import sys from collections import deque from typing import Any , Callable , Dict , List , Optional , Union , cast from pydoc_fork import settings from pydoc_fork.inspector.custom_types import TypeLike from pydoc_fork.inspector.utils import ( _split_list , classify_class_attrs , classname , getdoc , sort_attributes , visiblename , ) from pydoc_fork.reporter import inline_styles from pydoc_fork.reporter.format_data import document_data from pydoc_fork.reporter.format_other import docother from pydoc_fork.reporter.formatter_html import markup , section def classlink ( the_object : Union [ TypeLike , type ], modname : str ) -> str : \"\"\"Make a link for a class.\"\"\" name , module = the_object . __name__ , sys . modules . get ( the_object . __module__ ) if hasattr ( module , name ) and getattr ( module , name ) is the_object : return f '<a href=\" { module . __name__ } .html# { name } \"> { classname ( cast ( TypeLike , the_object ), modname ) } </a>' return classname ( the_object , modname ) # noinspection PyBroadException def docclass ( the_object : TypeLike , name : str = \"\" , mod : str = \"\" , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None , ) -> str : \"\"\"Produce HTML documentation for a class object.\"\"\" funcs = funcs or {} classes = classes or {} real_name = the_object . __name__ name = name or real_name bases = the_object . __bases__ contents : List [ str ] = [] push = contents . append class HorizontalRule : \"\"\"Cute little class to pump out a horizontal rule between sections.\"\"\" def __init__ ( self ) -> None : self . need_one = 0 def maybe ( self ) -> None : \"\"\"Skip\"\"\" if self . need_one : push ( \"<hr> \\n \" ) self . need_one = 1 # pylint:disable=invalid-name hr = HorizontalRule () # List the mro, if non-trivial. mro = deque ( inspect . getmro ( cast ( type , the_object ))) if len ( mro ) > 2 : hr . maybe () push ( \"<dl><dt>Method resolution order:</dt> \\n \" ) for base in mro : push ( f \"<dd> { classlink ( base , the_object . __module__ ) } </dd> \\n \" ) push ( \"</dl> \\n \" ) def spill ( msg : str , attrs_in : List [ Any ], predicate : Callable [[ Any ], Any ] ) -> List [ Any ]: \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , _ , value in ok : # noinspection PyBroadException try : value = getattr ( the_object , name ) except Exception : # nosec # Some descriptors may meet a failure in their __get__. # (bug #1785) push ( document_data ( value , name , # mod, unused ) ) else : # circular ref # pylint: disable=import-outside-toplevel from pydoc_fork.reporter.format_page import document push ( document ( value , name , mod , funcs , classes , module_dict , the_object ) ) push ( \" \\n \" ) return attrs def spilldescriptors ( msg : str , attrs_in : List [ Any ], # Tuple[str, str, type, \"object\"] predicate : Callable [[ Any ], bool ], ) -> List [ Any ]: \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , _ , value in ok : push ( document_data ( value , name , # mod, ignored ) ) return attrs def spilldata ( msg : str , attrs_in : List [ Any ], predicate : Callable [[ Any ], bool ] ) -> List [ Any ]: \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , __ , value in ok : base = docother ( getattr ( the_object , name ), name , # mod ignored ) found_doc = getdoc ( value ) if not found_doc : push ( f \"<dl><dt> { base } </dl> \\n \" ) else : found_doc = markup ( getdoc ( value ), funcs , classes , module_dict ) found_doc = f \"<dd><tt> { found_doc } </tt>\" push ( f \"<dl><dt> { base }{ found_doc } </dl> \\n \" ) push ( \" \\n \" ) return attrs attrs = [ ( name , kind , cls , value ) for name , kind , cls , value in classify_class_attrs ( the_object ) if visiblename ( name , obj = the_object ) ] module_dict = {} for key , _ , _ , value in attrs : module_dict [ key ] = anchor = \"#\" + name + \"-\" + key try : value = getattr ( the_object , name ) except Exception : # nosec # Some descriptors may meet a failure in their __get__. # (bug #1785) pass # nosec try : # The value may not be hashable (e.g., a data attr with # a dict or list value). module_dict [ value ] = anchor except TypeError : pass # nosec while attrs : if mro : this_class = mro . popleft () else : this_class = attrs [ 0 ][ 2 ] is_this_class : Callable [[ Any ], Any ] = lambda t : t [ 2 ] is this_class attrs , inherited = _split_list ( attrs , is_this_class ) if the_object is not builtins . object and this_class is builtins . object : attrs = inherited continue if this_class is the_object : tag = \"defined here\" else : tag = f \"inherited from { classlink ( this_class , the_object . __module__ ) } \" tag += \":<br> \\n \" sort_attributes ( attrs , the_object ) # feature to remove typing annotations cruft. for kind in attrs . copy (): module_name = inspect . getmodule ( kind ) if module_name and module_name . __name__ in settings . SKIP_MODULES : attrs . remove ( kind ) # Pump out the attrs, segregated by kind. is_method : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"method\" attrs = spill ( f \"Methods { tag } \" , attrs , is_method ) is_class : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"class method\" attrs = spill ( f \"Class methods { tag } \" , attrs , is_class ) is_static : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"static method\" attrs = spill ( f \"Static methods { tag } \" , attrs , is_static ) is_read_only : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"readonly property\" attrs = spilldescriptors ( f \"Readonly properties { tag } \" , attrs , is_read_only , ) is_data_descriptor : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"data descriptor\" attrs = spilldescriptors ( f \"Data descriptors { tag } \" , attrs , is_data_descriptor ) is_data : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"data\" attrs = spilldata ( f \"Data and other attributes { tag } \" , attrs , is_data ) assert not attrs # nosec attrs = inherited contents_as_string = \"\" . join ( contents ) # type got redefined if name == real_name : title = f '<a name=\" { name } \">class <strong> { real_name } </strong></a>' else : title = f '<strong> { name } </strong> = <a name=\" { name } \">class { real_name } </a>' if bases : parents = [] for base in bases : parents . append ( classlink ( base , the_object . __module__ )) title = title + f \"( { ', ' . join ( parents ) } )\" decl = \"\" try : signature = inspect . signature ( the_object ) except ( ValueError , TypeError ): signature = None if signature : argument_specification = str ( signature ) if argument_specification and argument_specification != \"()\" : # this will cause double escape on -> # escape(argument_specification) decl = name + argument_specification + \" \\n\\n \" doc = getdoc ( the_object ) if decl : doc = decl + ( doc or \"\" ) doc = markup ( doc , funcs , classes , module_dict ) doc = doc and f \"<tt> { doc } <br>&nbsp;</tt>\" return section ( title , \"#000000\" , \"#ffc8d8\" , contents_as_string , 3 , doc ) def format_tree ( tree : List [ Any ], modname : str , parent : Optional [ Any ] = None ) -> str : \"\"\" Creates a representation of class inheritance. \"\"\" # \"\"\"Produce HTML for a class tree as given by inspect.getclasstree().\"\"\" result = \"\" for entry in tree : class_object = entry # pylint: disable=unidiomatic-typecheck if type ( entry ) is type (()): # noqa - not sure of switching to isinstance class_object , bases = entry result = ( result + f '<dt><span style=\"font-family: { inline_styles . SAN_SERIF } \">' ) result = result + classlink ( class_object , modname ) if bases and bases != ( parent ,): parents = [] for base in bases : parents . append ( classlink ( base , modname )) result = result + \"(\" + \", \" . join ( parents ) + \")\" result = result + \" \\n </span></dt>\" elif type ( entry ) is type ([]): # noqa - not sure of switching to isinstance tree = format_tree ( entry , modname , class_object ) result = result + f \"<dd> \\n { tree } </dd> \\n \" return f \"<dl> \\n { result } </dl> \\n \" Functions classlink def classlink ( the_object : Union [ pydoc_fork . inspector . custom_types . TypeLike , type ], modname : str ) -> str Make a link for a class. View Source def classlink(the_object: Union[TypeLike, type], modname: str) -> str: \"\"\"Make a link for a class.\"\"\" name, module = the_object.__name__, sys.modules.get(the_object.__module__) if hasattr(module, name) and getattr(module, name) is the_object: return f' <a href= \"{module.__name__}.html#{name}\" > {classname(cast(TypeLike, the_object), modname)} </a> ' return classname(the_object, modname) docclass def docclass ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' , mod : str = '' , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None ) -> str Produce HTML documentation for a class object. View Source def docclass ( the_object : TypeLike , name : str = \"\" , mod : str = \"\" , funcs : Optional [ Dict[str, str ] ] = None , classes : Optional [ Dict[str, str ] ] = None , ) -> str : \"\"\"Produce HTML documentation for a class object.\"\"\" funcs = funcs or {} classes = classes or {} real_name = the_object . __name__ name = name or real_name bases = the_object . __bases__ contents : List [ str ] = [] push = contents . append class HorizontalRule : \"\"\"Cute little class to pump out a horizontal rule between sections.\"\"\" def __init__ ( self ) -> None : self . need_one = 0 def maybe ( self ) -> None : \"\"\"Skip\"\"\" if self . need_one : push ( \"<hr>\\n\" ) self . need_one = 1 # pylint : disable = invalid - name hr = HorizontalRule () # List the mro , if non - trivial . mro = deque ( inspect . getmro ( cast ( type , the_object ))) if len ( mro ) > 2 : hr . maybe () push ( \"<dl><dt>Method resolution order:</dt>\\n\" ) for base in mro : push ( f \"<dd>{classlink(base, the_object.__module__)}</dd>\\n\" ) push ( \"</dl>\\n\" ) def spill ( msg : str , attrs_in : List [ Any ] , predicate : Callable [ [Any ] , Any ] ) -> List [ Any ] : \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , _ , value in ok : # noinspection PyBroadException try : value = getattr ( the_object , name ) except Exception : # nosec # Some descriptors may meet a failure in their __get__ . # ( bug #1785 ) push ( document_data ( value , name , # mod , unused ) ) else : # circular ref # pylint : disable = import - outside - toplevel from pydoc_fork . reporter . format_page import document push ( document ( value , name , mod , funcs , classes , module_dict , the_object ) ) push ( \"\\n\" ) return attrs def spilldescriptors ( msg : str , attrs_in : List [ Any ] , # Tuple [ str, str, type, \"object\" ] predicate : Callable [ [Any ] , bool ] , ) -> List [ Any ] : \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , _ , value in ok : push ( document_data ( value , name , # mod , ignored ) ) return attrs def spilldata ( msg : str , attrs_in : List [ Any ] , predicate : Callable [ [Any ] , bool ] ) -> List [ Any ] : \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , __ , value in ok : base = docother ( getattr ( the_object , name ), name , # mod ignored ) found_doc = getdoc ( value ) if not found_doc : push ( f \"<dl><dt>{base}</dl>\\n\" ) else : found_doc = markup ( getdoc ( value ), funcs , classes , module_dict ) found_doc = f \"<dd><tt>{found_doc}</tt>\" push ( f \"<dl><dt>{base}{found_doc}</dl>\\n\" ) push ( \"\\n\" ) return attrs attrs = [ (name, kind, cls, value) for name, kind, cls, value in classify_class_attrs(the_object) if visiblename(name, obj=the_object) ] module_dict = {} for key , _ , _ , value in attrs : module_dict [ key ] = anchor = \"#\" + name + \"-\" + key try : value = getattr ( the_object , name ) except Exception : # nosec # Some descriptors may meet a failure in their __get__ . # ( bug #1785 ) pass # nosec try : # The value may not be hashable ( e . g ., a data attr with # a dict or list value ). module_dict [ value ] = anchor except TypeError : pass # nosec while attrs : if mro : this_class = mro . popleft () else : this_class = attrs [ 0 ][ 2 ] is_this_class : Callable [ [Any ] , Any ] = lambda t : t [ 2 ] is this_class attrs , inherited = _split_list ( attrs , is_this_class ) if the_object is not builtins . object and this_class is builtins . object : attrs = inherited continue if this_class is the_object : tag = \"defined here\" else : tag = f \"inherited from {classlink(this_class, the_object.__module__)}\" tag += \":<br>\\n\" sort_attributes ( attrs , the_object ) # feature to remove typing annotations cruft . for kind in attrs . copy () : module_name = inspect . getmodule ( kind ) if module_name and module_name . __name__ in settings . SKIP_MODULES : attrs . remove ( kind ) # Pump out the attrs , segregated by kind . is_method : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"method\" attrs = spill ( f \"Methods {tag}\" , attrs , is_method ) is_class : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"class method\" attrs = spill ( f \"Class methods {tag}\" , attrs , is_class ) is_static : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"static method\" attrs = spill ( f \"Static methods {tag}\" , attrs , is_static ) is_read_only : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"readonly property\" attrs = spilldescriptors ( f \"Readonly properties {tag}\" , attrs , is_read_only , ) is_data_descriptor : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"data descriptor\" attrs = spilldescriptors ( f \"Data descriptors {tag}\" , attrs , is_data_descriptor ) is_data : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"data\" attrs = spilldata ( f \"Data and other attributes {tag}\" , attrs , is_data ) assert not attrs # nosec attrs = inherited contents_as_string = \"\" . join ( contents ) # type got redefined if name == real_name : title = f '<a name=\"{name}\">class <strong>{real_name}</strong></a>' else : title = f '<strong>{name}</strong> = <a name=\"{name}\">class {real_name}</a>' if bases : parents = [] for base in bases : parents . append ( classlink ( base , the_object . __module__ )) title = title + f \"({', '.join(parents)})\" decl = \"\" try : signature = inspect . signature ( the_object ) except ( ValueError , TypeError ) : signature = None if signature : argument_specification = str ( signature ) if argument_specification and argument_specification != \"()\" : # this will cause double escape on -> # escape ( argument_specification ) decl = name + argument_specification + \"\\n\\n\" doc = getdoc ( the_object ) if decl : doc = decl + ( doc or \"\" ) doc = markup ( doc , funcs , classes , module_dict ) doc = doc and f \"<tt>{doc}<br>&nbsp;</tt>\" return section ( title , \"#000000\" , \"#ffc8d8\" , contents_as_string , 3 , doc ) format_tree def format_tree ( tree : List [ Any ], modname : str , parent : Optional [ Any ] = None ) -> str Creates a representation of class inheritance. View Source def format_tree ( tree : List [ Any ] , modname : str , parent : Optional [ Any ] = None ) -> str : \"\"\" Creates a representation of class inheritance. \"\"\" # \"\"\"Produce HTML for a class tree as given by inspect.getclasstree().\"\"\" result = \"\" for entry in tree : class_object = entry # pylint : disable = unidiomatic - typecheck if type ( entry ) is type (()) : # noqa - not sure of switching to isinstance class_object , bases = entry result = ( result + f '<dt><span style=\"font-family:{inline_styles.SAN_SERIF}\">' ) result = result + classlink ( class_object , modname ) if bases and bases != ( parent ,) : parents = [] for base in bases : parents . append ( classlink ( base , modname )) result = result + \"(\" + \", \" . join ( parents ) + \")\" result = result + \"\\n</span></dt>\" elif type ( entry ) is type ( [] ) : # noqa - not sure of switching to isinstance tree = format_tree ( entry , modname , class_object ) result = result + f \"<dd>\\n{tree}</dd>\\n\" return f \"<dl>\\n{result}</dl>\\n\"","title":"Format Class"},{"location":"reference/pydoc_fork/reporter/format_class/#module-pydoc_forkreporterformat_class","text":"Roughly a UI component for classes None View Source \"\"\" Roughly a UI component for classes \"\"\" import builtins import inspect import sys from collections import deque from typing import Any , Callable , Dict , List , Optional , Union , cast from pydoc_fork import settings from pydoc_fork.inspector.custom_types import TypeLike from pydoc_fork.inspector.utils import ( _split_list , classify_class_attrs , classname , getdoc , sort_attributes , visiblename , ) from pydoc_fork.reporter import inline_styles from pydoc_fork.reporter.format_data import document_data from pydoc_fork.reporter.format_other import docother from pydoc_fork.reporter.formatter_html import markup , section def classlink ( the_object : Union [ TypeLike , type ], modname : str ) -> str : \"\"\"Make a link for a class.\"\"\" name , module = the_object . __name__ , sys . modules . get ( the_object . __module__ ) if hasattr ( module , name ) and getattr ( module , name ) is the_object : return f '<a href=\" { module . __name__ } .html# { name } \"> { classname ( cast ( TypeLike , the_object ), modname ) } </a>' return classname ( the_object , modname ) # noinspection PyBroadException def docclass ( the_object : TypeLike , name : str = \"\" , mod : str = \"\" , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None , ) -> str : \"\"\"Produce HTML documentation for a class object.\"\"\" funcs = funcs or {} classes = classes or {} real_name = the_object . __name__ name = name or real_name bases = the_object . __bases__ contents : List [ str ] = [] push = contents . append class HorizontalRule : \"\"\"Cute little class to pump out a horizontal rule between sections.\"\"\" def __init__ ( self ) -> None : self . need_one = 0 def maybe ( self ) -> None : \"\"\"Skip\"\"\" if self . need_one : push ( \"<hr> \\n \" ) self . need_one = 1 # pylint:disable=invalid-name hr = HorizontalRule () # List the mro, if non-trivial. mro = deque ( inspect . getmro ( cast ( type , the_object ))) if len ( mro ) > 2 : hr . maybe () push ( \"<dl><dt>Method resolution order:</dt> \\n \" ) for base in mro : push ( f \"<dd> { classlink ( base , the_object . __module__ ) } </dd> \\n \" ) push ( \"</dl> \\n \" ) def spill ( msg : str , attrs_in : List [ Any ], predicate : Callable [[ Any ], Any ] ) -> List [ Any ]: \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , _ , value in ok : # noinspection PyBroadException try : value = getattr ( the_object , name ) except Exception : # nosec # Some descriptors may meet a failure in their __get__. # (bug #1785) push ( document_data ( value , name , # mod, unused ) ) else : # circular ref # pylint: disable=import-outside-toplevel from pydoc_fork.reporter.format_page import document push ( document ( value , name , mod , funcs , classes , module_dict , the_object ) ) push ( \" \\n \" ) return attrs def spilldescriptors ( msg : str , attrs_in : List [ Any ], # Tuple[str, str, type, \"object\"] predicate : Callable [[ Any ], bool ], ) -> List [ Any ]: \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , _ , value in ok : push ( document_data ( value , name , # mod, ignored ) ) return attrs def spilldata ( msg : str , attrs_in : List [ Any ], predicate : Callable [[ Any ], bool ] ) -> List [ Any ]: \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , __ , value in ok : base = docother ( getattr ( the_object , name ), name , # mod ignored ) found_doc = getdoc ( value ) if not found_doc : push ( f \"<dl><dt> { base } </dl> \\n \" ) else : found_doc = markup ( getdoc ( value ), funcs , classes , module_dict ) found_doc = f \"<dd><tt> { found_doc } </tt>\" push ( f \"<dl><dt> { base }{ found_doc } </dl> \\n \" ) push ( \" \\n \" ) return attrs attrs = [ ( name , kind , cls , value ) for name , kind , cls , value in classify_class_attrs ( the_object ) if visiblename ( name , obj = the_object ) ] module_dict = {} for key , _ , _ , value in attrs : module_dict [ key ] = anchor = \"#\" + name + \"-\" + key try : value = getattr ( the_object , name ) except Exception : # nosec # Some descriptors may meet a failure in their __get__. # (bug #1785) pass # nosec try : # The value may not be hashable (e.g., a data attr with # a dict or list value). module_dict [ value ] = anchor except TypeError : pass # nosec while attrs : if mro : this_class = mro . popleft () else : this_class = attrs [ 0 ][ 2 ] is_this_class : Callable [[ Any ], Any ] = lambda t : t [ 2 ] is this_class attrs , inherited = _split_list ( attrs , is_this_class ) if the_object is not builtins . object and this_class is builtins . object : attrs = inherited continue if this_class is the_object : tag = \"defined here\" else : tag = f \"inherited from { classlink ( this_class , the_object . __module__ ) } \" tag += \":<br> \\n \" sort_attributes ( attrs , the_object ) # feature to remove typing annotations cruft. for kind in attrs . copy (): module_name = inspect . getmodule ( kind ) if module_name and module_name . __name__ in settings . SKIP_MODULES : attrs . remove ( kind ) # Pump out the attrs, segregated by kind. is_method : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"method\" attrs = spill ( f \"Methods { tag } \" , attrs , is_method ) is_class : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"class method\" attrs = spill ( f \"Class methods { tag } \" , attrs , is_class ) is_static : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"static method\" attrs = spill ( f \"Static methods { tag } \" , attrs , is_static ) is_read_only : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"readonly property\" attrs = spilldescriptors ( f \"Readonly properties { tag } \" , attrs , is_read_only , ) is_data_descriptor : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"data descriptor\" attrs = spilldescriptors ( f \"Data descriptors { tag } \" , attrs , is_data_descriptor ) is_data : Callable [[ Any ], Any ] = lambda t : t [ 1 ] == \"data\" attrs = spilldata ( f \"Data and other attributes { tag } \" , attrs , is_data ) assert not attrs # nosec attrs = inherited contents_as_string = \"\" . join ( contents ) # type got redefined if name == real_name : title = f '<a name=\" { name } \">class <strong> { real_name } </strong></a>' else : title = f '<strong> { name } </strong> = <a name=\" { name } \">class { real_name } </a>' if bases : parents = [] for base in bases : parents . append ( classlink ( base , the_object . __module__ )) title = title + f \"( { ', ' . join ( parents ) } )\" decl = \"\" try : signature = inspect . signature ( the_object ) except ( ValueError , TypeError ): signature = None if signature : argument_specification = str ( signature ) if argument_specification and argument_specification != \"()\" : # this will cause double escape on -> # escape(argument_specification) decl = name + argument_specification + \" \\n\\n \" doc = getdoc ( the_object ) if decl : doc = decl + ( doc or \"\" ) doc = markup ( doc , funcs , classes , module_dict ) doc = doc and f \"<tt> { doc } <br>&nbsp;</tt>\" return section ( title , \"#000000\" , \"#ffc8d8\" , contents_as_string , 3 , doc ) def format_tree ( tree : List [ Any ], modname : str , parent : Optional [ Any ] = None ) -> str : \"\"\" Creates a representation of class inheritance. \"\"\" # \"\"\"Produce HTML for a class tree as given by inspect.getclasstree().\"\"\" result = \"\" for entry in tree : class_object = entry # pylint: disable=unidiomatic-typecheck if type ( entry ) is type (()): # noqa - not sure of switching to isinstance class_object , bases = entry result = ( result + f '<dt><span style=\"font-family: { inline_styles . SAN_SERIF } \">' ) result = result + classlink ( class_object , modname ) if bases and bases != ( parent ,): parents = [] for base in bases : parents . append ( classlink ( base , modname )) result = result + \"(\" + \", \" . join ( parents ) + \")\" result = result + \" \\n </span></dt>\" elif type ( entry ) is type ([]): # noqa - not sure of switching to isinstance tree = format_tree ( entry , modname , class_object ) result = result + f \"<dd> \\n { tree } </dd> \\n \" return f \"<dl> \\n { result } </dl> \\n \"","title":"Module pydoc_fork.reporter.format_class"},{"location":"reference/pydoc_fork/reporter/format_class/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/reporter/format_class/#classlink","text":"def classlink ( the_object : Union [ pydoc_fork . inspector . custom_types . TypeLike , type ], modname : str ) -> str Make a link for a class. View Source def classlink(the_object: Union[TypeLike, type], modname: str) -> str: \"\"\"Make a link for a class.\"\"\" name, module = the_object.__name__, sys.modules.get(the_object.__module__) if hasattr(module, name) and getattr(module, name) is the_object: return f' <a href= \"{module.__name__}.html#{name}\" > {classname(cast(TypeLike, the_object), modname)} </a> ' return classname(the_object, modname)","title":"classlink"},{"location":"reference/pydoc_fork/reporter/format_class/#docclass","text":"def docclass ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' , mod : str = '' , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None ) -> str Produce HTML documentation for a class object. View Source def docclass ( the_object : TypeLike , name : str = \"\" , mod : str = \"\" , funcs : Optional [ Dict[str, str ] ] = None , classes : Optional [ Dict[str, str ] ] = None , ) -> str : \"\"\"Produce HTML documentation for a class object.\"\"\" funcs = funcs or {} classes = classes or {} real_name = the_object . __name__ name = name or real_name bases = the_object . __bases__ contents : List [ str ] = [] push = contents . append class HorizontalRule : \"\"\"Cute little class to pump out a horizontal rule between sections.\"\"\" def __init__ ( self ) -> None : self . need_one = 0 def maybe ( self ) -> None : \"\"\"Skip\"\"\" if self . need_one : push ( \"<hr>\\n\" ) self . need_one = 1 # pylint : disable = invalid - name hr = HorizontalRule () # List the mro , if non - trivial . mro = deque ( inspect . getmro ( cast ( type , the_object ))) if len ( mro ) > 2 : hr . maybe () push ( \"<dl><dt>Method resolution order:</dt>\\n\" ) for base in mro : push ( f \"<dd>{classlink(base, the_object.__module__)}</dd>\\n\" ) push ( \"</dl>\\n\" ) def spill ( msg : str , attrs_in : List [ Any ] , predicate : Callable [ [Any ] , Any ] ) -> List [ Any ] : \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , _ , value in ok : # noinspection PyBroadException try : value = getattr ( the_object , name ) except Exception : # nosec # Some descriptors may meet a failure in their __get__ . # ( bug #1785 ) push ( document_data ( value , name , # mod , unused ) ) else : # circular ref # pylint : disable = import - outside - toplevel from pydoc_fork . reporter . format_page import document push ( document ( value , name , mod , funcs , classes , module_dict , the_object ) ) push ( \"\\n\" ) return attrs def spilldescriptors ( msg : str , attrs_in : List [ Any ] , # Tuple [ str, str, type, \"object\" ] predicate : Callable [ [Any ] , bool ] , ) -> List [ Any ] : \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , _ , value in ok : push ( document_data ( value , name , # mod , ignored ) ) return attrs def spilldata ( msg : str , attrs_in : List [ Any ] , predicate : Callable [ [Any ] , bool ] ) -> List [ Any ] : \"\"\"Not sure\"\"\" ok , attrs = _split_list ( attrs_in , predicate ) if ok : hr . maybe () push ( msg ) for name , _ , __ , value in ok : base = docother ( getattr ( the_object , name ), name , # mod ignored ) found_doc = getdoc ( value ) if not found_doc : push ( f \"<dl><dt>{base}</dl>\\n\" ) else : found_doc = markup ( getdoc ( value ), funcs , classes , module_dict ) found_doc = f \"<dd><tt>{found_doc}</tt>\" push ( f \"<dl><dt>{base}{found_doc}</dl>\\n\" ) push ( \"\\n\" ) return attrs attrs = [ (name, kind, cls, value) for name, kind, cls, value in classify_class_attrs(the_object) if visiblename(name, obj=the_object) ] module_dict = {} for key , _ , _ , value in attrs : module_dict [ key ] = anchor = \"#\" + name + \"-\" + key try : value = getattr ( the_object , name ) except Exception : # nosec # Some descriptors may meet a failure in their __get__ . # ( bug #1785 ) pass # nosec try : # The value may not be hashable ( e . g ., a data attr with # a dict or list value ). module_dict [ value ] = anchor except TypeError : pass # nosec while attrs : if mro : this_class = mro . popleft () else : this_class = attrs [ 0 ][ 2 ] is_this_class : Callable [ [Any ] , Any ] = lambda t : t [ 2 ] is this_class attrs , inherited = _split_list ( attrs , is_this_class ) if the_object is not builtins . object and this_class is builtins . object : attrs = inherited continue if this_class is the_object : tag = \"defined here\" else : tag = f \"inherited from {classlink(this_class, the_object.__module__)}\" tag += \":<br>\\n\" sort_attributes ( attrs , the_object ) # feature to remove typing annotations cruft . for kind in attrs . copy () : module_name = inspect . getmodule ( kind ) if module_name and module_name . __name__ in settings . SKIP_MODULES : attrs . remove ( kind ) # Pump out the attrs , segregated by kind . is_method : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"method\" attrs = spill ( f \"Methods {tag}\" , attrs , is_method ) is_class : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"class method\" attrs = spill ( f \"Class methods {tag}\" , attrs , is_class ) is_static : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"static method\" attrs = spill ( f \"Static methods {tag}\" , attrs , is_static ) is_read_only : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"readonly property\" attrs = spilldescriptors ( f \"Readonly properties {tag}\" , attrs , is_read_only , ) is_data_descriptor : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"data descriptor\" attrs = spilldescriptors ( f \"Data descriptors {tag}\" , attrs , is_data_descriptor ) is_data : Callable [ [Any ] , Any ] = lambda t : t [ 1 ] == \"data\" attrs = spilldata ( f \"Data and other attributes {tag}\" , attrs , is_data ) assert not attrs # nosec attrs = inherited contents_as_string = \"\" . join ( contents ) # type got redefined if name == real_name : title = f '<a name=\"{name}\">class <strong>{real_name}</strong></a>' else : title = f '<strong>{name}</strong> = <a name=\"{name}\">class {real_name}</a>' if bases : parents = [] for base in bases : parents . append ( classlink ( base , the_object . __module__ )) title = title + f \"({', '.join(parents)})\" decl = \"\" try : signature = inspect . signature ( the_object ) except ( ValueError , TypeError ) : signature = None if signature : argument_specification = str ( signature ) if argument_specification and argument_specification != \"()\" : # this will cause double escape on -> # escape ( argument_specification ) decl = name + argument_specification + \"\\n\\n\" doc = getdoc ( the_object ) if decl : doc = decl + ( doc or \"\" ) doc = markup ( doc , funcs , classes , module_dict ) doc = doc and f \"<tt>{doc}<br>&nbsp;</tt>\" return section ( title , \"#000000\" , \"#ffc8d8\" , contents_as_string , 3 , doc )","title":"docclass"},{"location":"reference/pydoc_fork/reporter/format_class/#format_tree","text":"def format_tree ( tree : List [ Any ], modname : str , parent : Optional [ Any ] = None ) -> str Creates a representation of class inheritance. View Source def format_tree ( tree : List [ Any ] , modname : str , parent : Optional [ Any ] = None ) -> str : \"\"\" Creates a representation of class inheritance. \"\"\" # \"\"\"Produce HTML for a class tree as given by inspect.getclasstree().\"\"\" result = \"\" for entry in tree : class_object = entry # pylint : disable = unidiomatic - typecheck if type ( entry ) is type (()) : # noqa - not sure of switching to isinstance class_object , bases = entry result = ( result + f '<dt><span style=\"font-family:{inline_styles.SAN_SERIF}\">' ) result = result + classlink ( class_object , modname ) if bases and bases != ( parent ,) : parents = [] for base in bases : parents . append ( classlink ( base , modname )) result = result + \"(\" + \", \" . join ( parents ) + \")\" result = result + \"\\n</span></dt>\" elif type ( entry ) is type ( [] ) : # noqa - not sure of switching to isinstance tree = format_tree ( entry , modname , class_object ) result = result + f \"<dd>\\n{tree}</dd>\\n\" return f \"<dl>\\n{result}</dl>\\n\"","title":"format_tree"},{"location":"reference/pydoc_fork/reporter/format_data/","text":"Module pydoc_fork.reporter.format_data Roughly a UI component for variables and their values None View Source \"\"\" Roughly a UI component for variables and their values \"\"\" from typing import List from pydoc_fork.inspector.custom_types import TypeLike from pydoc_fork.inspector.utils import getdoc from pydoc_fork.reporter.formatter_html import markup def document_data ( the_object : TypeLike , name : str = \"\" , ) -> str : \"\"\"Produce html documentation for a data descriptor.\"\"\" results : List [ str ] = [] if name : results . append ( f \"<dl><dt><strong> { name } </strong></dt> \\n \" ) doc = markup ( getdoc ( the_object )) if doc : results . append ( f \"<dd><tt> { doc } </tt></dd> \\n \" ) results . append ( \"</dl> \\n \" ) return \"\" . join ( results ) Functions document_data def document_data ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' ) -> str Produce html documentation for a data descriptor. View Source def document_data ( the_object : TypeLike , name : str = \"\" , ) -> str : \"\"\"Produce html documentation for a data descriptor.\"\"\" results : List [ str ] = [] if name : results . append ( f \"<dl><dt><strong>{name}</strong></dt>\\n\" ) doc = markup ( getdoc ( the_object )) if doc : results . append ( f \"<dd><tt>{doc}</tt></dd>\\n\" ) results . append ( \"</dl>\\n\" ) return \"\" . join ( results )","title":"Format Data"},{"location":"reference/pydoc_fork/reporter/format_data/#module-pydoc_forkreporterformat_data","text":"Roughly a UI component for variables and their values None View Source \"\"\" Roughly a UI component for variables and their values \"\"\" from typing import List from pydoc_fork.inspector.custom_types import TypeLike from pydoc_fork.inspector.utils import getdoc from pydoc_fork.reporter.formatter_html import markup def document_data ( the_object : TypeLike , name : str = \"\" , ) -> str : \"\"\"Produce html documentation for a data descriptor.\"\"\" results : List [ str ] = [] if name : results . append ( f \"<dl><dt><strong> { name } </strong></dt> \\n \" ) doc = markup ( getdoc ( the_object )) if doc : results . append ( f \"<dd><tt> { doc } </tt></dd> \\n \" ) results . append ( \"</dl> \\n \" ) return \"\" . join ( results )","title":"Module pydoc_fork.reporter.format_data"},{"location":"reference/pydoc_fork/reporter/format_data/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/reporter/format_data/#document_data","text":"def document_data ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' ) -> str Produce html documentation for a data descriptor. View Source def document_data ( the_object : TypeLike , name : str = \"\" , ) -> str : \"\"\"Produce html documentation for a data descriptor.\"\"\" results : List [ str ] = [] if name : results . append ( f \"<dl><dt><strong>{name}</strong></dt>\\n\" ) doc = markup ( getdoc ( the_object )) if doc : results . append ( f \"<dd><tt>{doc}</tt></dd>\\n\" ) results . append ( \"</dl>\\n\" ) return \"\" . join ( results )","title":"document_data"},{"location":"reference/pydoc_fork/reporter/format_module/","text":"Module pydoc_fork.reporter.format_module Roughly a UI component for modules None View Source \"\"\" Roughly a UI component for modules \"\"\" import inspect import os import pkgutil import sys from typing import Optional , cast from pydoc_fork import settings from pydoc_fork . inspector . custom_types import TypeLike from pydoc_fork . inspector . utils import getdoc , isdata , visiblename from pydoc_fork . reporter import inline_styles from pydoc_fork . reporter . format_class import format_tree from pydoc_fork . reporter . formatter_html import ( STDLIB_BASEDIR , bigsection , escape , file_link , heading , markup , module_package_link , multicolumn , ) def getdocloc ( the_object: TypeLike , basedir : str = STDLIB_BASEDIR ) -> Optional [ str ] : \"\"\"Return the location of module docs or None\"\"\" try : file = inspect . getabsfile ( cast ( type , the_object )) except TypeError : file = \"(built-in)\" basedir = os . path . normcase ( basedir ) is_known_stdlib = the_object . __ name__ in ( \"errno\" , \"exceptions\" , \"gc\" , \"imp\" , \"marshal\" , \"posix\" , \"signal\" , \"sys\" , \"_thread\" , \"zipimport\" , ) is_module = isinstance ( the_object , type ( os )) is_in_pythons_folder = file . startswith ( basedir ) and not file . startswith ( os . path . join ( basedir , \"site-packages\" ) ) # # This is nasty special case coding , how many more special cases are there? # is_exception = the_object . __ name__ in ( \"xml.etree\" , \"test.pydoc_mod\" ) # # special case for etree # \"https://docs.python.org/3/library/xml.etree.elementtree.html\" if ( is_module and ( is_known_stdlib or is_in_pythons_folder ) and settings . PREFER_DOCS_PYTHON_ORG ) : if settings . PYTHONDOCS . startswith (( \"http://\" , \"https://\" )) : doc_loc = ( f \"{settings.PYTHONDOCS.rstrip('/')}/{the_object.__name__.lower()}.html\" ) else : doc_loc = os . path . join ( settings . PYTHONDOCS , the_object . __ name__ . lower () + \".html\" ) else : doc_loc = None return doc_loc def modulelink ( the_object: TypeLike ) -> str : \"\"\"Make a link for a module.\"\"\" url = f \"{the_object.__name__}.html\" internet_link = getdocloc ( the_object ) if internet_link and settings . PREFER_DOCS_PYTHON_ORG : url = internet_link # BUG : doesn't take into consideration an alternate base if not internet_link: settings.MENTIONED_MODULES.add((the_object, the_object.__name__)) return f' < a href= \"{url}\" > { the_object . __ name__ } </a>' def docmodule( the_object: TypeLike, ) -> str: \"\"\"Produce HTML documentation for a module object.\"\"\" # circular ref from pydoc_fork.reporter.format_page import document name = the_object.__name__ try: all_things = None if settings.DOCUMENT_INTERNALS else the_object.__all__ except AttributeError: all_things = None parts = name.split(\".\") links = [] for i in range(len(parts) - 1): link_url = \".\".join(parts[: i + 1]) link_text = parts[i] links.append( f' < a href= \"{link_url}.html\" ><span style= \"color:{inline_styles.MODULE_LINK}\" > { link_text } </span></a>' ) linked_name = \".\".join(links + parts[-1:]) head = f\"<big><big><strong>{linked_name}</strong></big></big>\" try: path = inspect.getabsfile(cast(type, the_object)) # MR : Make relative output_folder_path = os.path.normcase(os.path.abspath(settings.OUTPUT_FOLDER)) path = os.path.relpath(path, output_folder_path).replace(\"\\\\\", \"/\") # end MR # uh, oh, forgot why I wrote this # url = urllib.parse.quote(path) # MR file_link_text = file_link(path, path) except TypeError: file_link_text = \"(built-in)\" info = [] # TODO: Include the rest of the meta data if hasattr(the_object, \"__version__\"): version = str(the_object.__version__) if version[:11] == \"$\" + \"Revision: \" and version[-1:] == \"$\": version = version[11:-1].strip() info.append(f\"version {escape(version)}\") if hasattr(the_object, \"__date__\"): info.append(escape(str(the_object.__date__))) if info: head = head + f\" ({' , '.join(info)})\" document_location = getdocloc(the_object) if document_location is not None: # Was this just a bug? document_location/locals? # document_location = ' < br><a href= \"%(docloc)s\" > Module Reference </a>' % locals() document_location = f' < br><a href= \"{document_location}\" > Module Reference </a>' else: document_location = \"\" result = heading( head, \"#ffffff\", \"#7799ee\", ' < a href= \".\" > index</a><br> ' + file_link_text + document_location , ) # this will get ` import foo ` but ignore ` from foo import bar ` # And bar gets no doc string love either ! modules = inspect . getmembers ( the_object , inspect . ismodule ) for to_remove in settings . SKIP_MODULES : for module_info in modules : candidate_module , _ = module_info if candidate_module == to_remove: try : modules . remove ( module_info ) except ValueError : pass modules_by_import_from = set () classes , class_dict = [], {} for key , value in inspect . getmembers ( the_object , inspect . isclass ) : _ class_module = inspect . getmodule ( value ) if _ class_module and _ class_module is not the_object: if _ class_module . __ name__ not in settings . SKIP_MODULES : modules_by_import_from . add (( None , _ class_module )) settings . MENTIONED_MODULES . add (( _ class_module , _ class_module . __ name__ )) # if __ all__ exists , believe it . Otherwise use old heuristic . if ( # TODO put doc internals switch here # all_things is not None or ( inspect . getmodule ( value ) or the_object ) is the_object ) : if visiblename ( key , all_things , the_object ) : classes . append (( key , value )) class_dict [ key ] = class_dict [ value ] = \"#\" + key for key , value in classes : for base in value . __ bases__: key , modname = base . __ name__ , base . __ module__ module = sys . modules . get ( modname ) if ( modname ! = name and module and hasattr ( module , key ) and getattr ( module , key ) is base and key not in class_dict ) : class_dict [ key ] = class_dict [ base ] = modname + \".html#\" + key funcs , function_dict = [], {} for key , value in inspect . getmembers ( the_object , inspect . isroutine ) : # if __ all__ exists , believe it . Otherwise use old heuristic . _ func_module = inspect . getmodule ( value ) # why does this sometimes return no module? if _ func_module and _ func_module is not the_object: if _ func_module . __ name__ not in settings . SKIP_MODULES : modules_by_import_from . add (( None , _ func_module )) settings . MENTIONED_MODULES . add (( _ func_module , _ func_module . __ name__ )) if ( True # TODO put doc internals switch here # all_things is not None or # __ all__ as scope limiter # inspect . isbuiltin ( value ) # thing w / o module # or inspect . getmodule ( value ) is the_object # from foo import bar ) and visiblename ( key , all_things , the_object ) : funcs . append (( key , value )) function_dict [ key ] = \"#-\" + key if inspect . isfunction ( value ) : function_dict [ value ] = function_dict [ key ] data = [] for key , value in inspect . getmembers ( the_object , isdata ) : if inspect . getmodule ( type ( value )). __ name__ in settings . SKIP_MODULES : continue if visiblename ( key , all_things , the_object ) : data . append (( key , value )) doc = markup ( getdoc ( the_object ), function_dict , class_dict ) doc = doc and f \"<tt>{doc}</tt>\" result = result + f \"<p>{doc}</p>\\n\" if hasattr ( the_object , \"__path__\" ) : module_packages = [] for _ , modname , is_package in pkgutil . iter_modules ( the_object . __ path__ ) : if modname not in settings . SKIP_MODULES : module_packages . append (( modname , name , is_package , 0 )) module_packages . sort () contents_string = multicolumn ( module_packages , module_package_link ) result = result + bigsection ( \"Package Contents\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) elif modules : contents_string = multicolumn ( modules , lambda t : modulelink ( t [ 1 ])) result = result + bigsection ( \"Modules\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) if modules_by_import_from: contents_string = multicolumn ( list ( modules_by_import_from ), lambda t : modulelink ( list ( t )[ 1 ]) ) result = result + bigsection ( \"`from` Modules\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) if classes : class_list = [ value for ( key , value ) in classes ] # MR : boolean type safety contents_list = [ format_tree ( inspect . getclasstree ( class_list , True ), name )] for key , value in classes : contents_list . append ( document ( value , key , name , function_dict , class_dict )) result = result + bigsection ( \"Classes\" , \"#ffffff\" , \"#ee77aa\" , \" \" . join ( contents_list ) ) if funcs : contents_list = [] for key , value in funcs : contents_list . append ( document ( value , key , name , function_dict , class_dict )) result = result + bigsection ( \"Functions\" , \"#ffffff\" , \"#eeaa77\" , \" \" . join ( contents_list ) ) if data : contents_list = [] for key , value in data : contents_list . append ( document ( value , key )) result = result + bigsection ( \"Data\" , \"#ffffff\" , \"#55aa55\" , \"<br>\\n\" . join ( contents_list ) ) if hasattr ( the_object , \"__author__\" ) : contents = markup ( str ( the_object . __ author__ )) result = result + bigsection ( \"Author\" , \"#ffffff\" , \"#7799ee\" , contents ) if hasattr ( the_object , \"__credits__\" ) : contents = markup ( str ( the_object . __ credits__ )) result = result + bigsection ( \"Credits\" , \"#ffffff\" , \"#7799ee\" , contents ) return result Variables STDLIB_BASEDIR Functions docmodule def docmodule ( the_object : pydoc_fork . inspector . custom_types . TypeLike ) -> str Produce HTML documentation for a module object. View Source def docmodule ( the_object: TypeLike , ) -> str : \"\"\"Produce HTML documentation for a module object.\"\"\" # circular ref from pydoc_fork . reporter . format_page import document name = the_object . __ name__ try : all_things = None if settings . DOCUMENT_INTERNALS else the_object . __ all__ except AttributeError : all_things = None parts = name . split ( \".\" ) links = [] for i in range ( len ( parts ) - 1 ) : link_url = \".\" . join ( parts [ : i + 1 ]) link_text = parts [ i ] links . append ( f'<a href=\"{link_url}.html\"><span style=\"color:{inline_styles.MODULE_LINK}\">{link_text}</span></a>' ) linked_name = \".\" . join ( links + parts [ - 1 : ]) head = f \"<big><big><strong>{linked_name}</strong></big></big>\" try : path = inspect . getabsfile ( cast ( type , the_object )) # MR : Make relative output_folder_path = os . path . normcase ( os . path . abspath ( settings . OUTPUT_FOLDER )) path = os . path . relpath ( path , output_folder_path ). replace ( \" \\\\ \", \" / \") # end MR # uh, oh, forgot why I wrote this # url = urllib.parse.quote(path) # MR file_link_text = file_link(path, path) except TypeError: file_link_text = \" ( built - in ) \" info = [] # TODO: Include the rest of the meta data if hasattr(the_object, \" __ version__ \"): version = str(the_object.__version__) if version[:11] == \" $ \" + \" Revision : \" and version[-1:] == \" $ \": version = version[11:-1].strip() info.append(f\" version { escape ( version )} \") if hasattr(the_object, \" __ date__ \"): info.append(escape(str(the_object.__date__))) if info: head = head + f\" ({ ', ' . join ( info )}) \" document_location = getdocloc(the_object) if document_location is not None: # Was this just a bug? document_location/locals? # document_location = '<br><a href=\" %(docloc)s\">Module Reference</a>' % locals() document_location = f'<br><a href=\"{document_location}\">Module Reference</a>' else : document_location = \"\" result = heading ( head , \"#ffffff\" , \"#7799ee\" , '<a href=\".\">index</a><br>' + file_link_text + document_location , ) # this will get ` import foo ` but ignore ` from foo import bar ` # And bar gets no doc string love either ! modules = inspect . getmembers ( the_object , inspect . ismodule ) for to_remove in settings . SKIP_MODULES : for module_info in modules : candidate_module , _ = module_info if candidate_module == to_remove: try : modules . remove ( module_info ) except ValueError : pass modules_by_import_from = set () classes , class_dict = [], {} for key , value in inspect . getmembers ( the_object , inspect . isclass ) : _ class_module = inspect . getmodule ( value ) if _ class_module and _ class_module is not the_object: if _ class_module . __ name__ not in settings . SKIP_MODULES : modules_by_import_from . add (( None , _ class_module )) settings . MENTIONED_MODULES . add (( _ class_module , _ class_module . __ name__ )) # if __ all__ exists , believe it . Otherwise use old heuristic . if ( # TODO put doc internals switch here # all_things is not None or ( inspect . getmodule ( value ) or the_object ) is the_object ) : if visiblename ( key , all_things , the_object ) : classes . append (( key , value )) class_dict [ key ] = class_dict [ value ] = \"#\" + key for key , value in classes : for base in value . __ bases__: key , modname = base . __ name__ , base . __ module__ module = sys . modules . get ( modname ) if ( modname ! = name and module and hasattr ( module , key ) and getattr ( module , key ) is base and key not in class_dict ) : class_dict [ key ] = class_dict [ base ] = modname + \".html#\" + key funcs , function_dict = [], {} for key , value in inspect . getmembers ( the_object , inspect . isroutine ) : # if __ all__ exists , believe it . Otherwise use old heuristic . _ func_module = inspect . getmodule ( value ) # why does this sometimes return no module? if _ func_module and _ func_module is not the_object: if _ func_module . __ name__ not in settings . SKIP_MODULES : modules_by_import_from . add (( None , _ func_module )) settings . MENTIONED_MODULES . add (( _ func_module , _ func_module . __ name__ )) if ( True # TODO put doc internals switch here # all_things is not None or # __ all__ as scope limiter # inspect . isbuiltin ( value ) # thing w / o module # or inspect . getmodule ( value ) is the_object # from foo import bar ) and visiblename ( key , all_things , the_object ) : funcs . append (( key , value )) function_dict [ key ] = \"#-\" + key if inspect . isfunction ( value ) : function_dict [ value ] = function_dict [ key ] data = [] for key , value in inspect . getmembers ( the_object , isdata ) : if inspect . getmodule ( type ( value )). __ name__ in settings . SKIP_MODULES : continue if visiblename ( key , all_things , the_object ) : data . append (( key , value )) doc = markup ( getdoc ( the_object ), function_dict , class_dict ) doc = doc and f \"<tt>{doc}</tt>\" result = result + f \"<p>{doc}</p>\\n\" if hasattr ( the_object , \"__path__\" ) : module_packages = [] for _ , modname , is_package in pkgutil . iter_modules ( the_object . __ path__ ) : if modname not in settings . SKIP_MODULES : module_packages . append (( modname , name , is_package , 0 )) module_packages . sort () contents_string = multicolumn ( module_packages , module_package_link ) result = result + bigsection ( \"Package Contents\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) elif modules : contents_string = multicolumn ( modules , lambda t : modulelink ( t [ 1 ])) result = result + bigsection ( \"Modules\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) if modules_by_import_from: contents_string = multicolumn ( list ( modules_by_import_from ), lambda t : modulelink ( list ( t )[ 1 ]) ) result = result + bigsection ( \"`from` Modules\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) if classes : class_list = [ value for ( key , value ) in classes ] # MR : boolean type safety contents_list = [ format_tree ( inspect . getclasstree ( class_list , True ), name )] for key , value in classes : contents_list . append ( document ( value , key , name , function_dict , class_dict )) result = result + bigsection ( \"Classes\" , \"#ffffff\" , \"#ee77aa\" , \" \" . join ( contents_list ) ) if funcs : contents_list = [] for key , value in funcs : contents_list . append ( document ( value , key , name , function_dict , class_dict )) result = result + bigsection ( \"Functions\" , \"#ffffff\" , \"#eeaa77\" , \" \" . join ( contents_list ) ) if data : contents_list = [] for key , value in data : contents_list . append ( document ( value , key )) result = result + bigsection ( \"Data\" , \"#ffffff\" , \"#55aa55\" , \"<br>\\n\" . join ( contents_list ) ) if hasattr ( the_object , \"__author__\" ) : contents = markup ( str ( the_object . __ author__ )) result = result + bigsection ( \"Author\" , \"#ffffff\" , \"#7799ee\" , contents ) if hasattr ( the_object , \"__credits__\" ) : contents = markup ( str ( the_object . __ credits__ )) result = result + bigsection ( \"Credits\" , \"#ffffff\" , \"#7799ee\" , contents ) return result getdocloc def getdocloc ( the_object : pydoc_fork . inspector . custom_types . TypeLike , basedir : str = 'C: \\\\ Users \\\\ matth \\\\ AppData \\\\ Local \\\\ Programs \\\\ Python \\\\ Python39 \\\\ Lib' ) -> Optional [ str ] Return the location of module docs or None View Source def getdocloc ( the_object : TypeLike , basedir : str = STDLIB_BASEDIR ) -> Optional [ str ] : \"\"\"Return the location of module docs or None\"\"\" try : file = inspect . getabsfile ( cast ( type , the_object )) except TypeError : file = \"(built-in)\" basedir = os . path . normcase ( basedir ) is_known_stdlib = the_object . __name__ in ( \"errno\" , \"exceptions\" , \"gc\" , \"imp\" , \"marshal\" , \"posix\" , \"signal\" , \"sys\" , \"_thread\" , \"zipimport\" , ) is_module = isinstance ( the_object , type ( os )) is_in_pythons_folder = file . startswith ( basedir ) and not file . startswith ( os . path . join ( basedir , \"site-packages\" ) ) # # This is nasty special case coding , how many more special cases are there ? # is_exception = the_object . __name__ in ( \"xml.etree\" , \"test.pydoc_mod\" ) # # special case for etree # \"https://docs.python.org/3/library/xml.etree.elementtree.html\" if ( is_module and ( is_known_stdlib or is_in_pythons_folder ) and settings . PREFER_DOCS_PYTHON_ORG ) : if settings . PYTHONDOCS . startswith (( \"http://\" , \"https://\" )) : doc_loc = ( f \"{settings.PYTHONDOCS.rstrip('/')}/{the_object.__name__.lower()}.html\" ) else : doc_loc = os . path . join ( settings . PYTHONDOCS , the_object . __name__ . lower () + \".html\" ) else : doc_loc = None return doc_loc modulelink def modulelink ( the_object : pydoc_fork . inspector . custom_types . TypeLike ) -> str Make a link for a module. View Source def modulelink(the_object: TypeLike) -> str: \"\"\"Make a link for a module.\"\"\" url = f\"{the_object.__name__}.html\" internet_link = getdocloc(the_object) if internet_link and settings.PREFER_DOCS_PYTHON_ORG: url = internet_link # BUG: doesn't take into consideration an alternate base if not internet_link: settings.MENTIONED_MODULES.add((the_object, the_object.__name__)) return f' <a href= \"{url}\" > {the_object.__name__} </a> '","title":"Format Module"},{"location":"reference/pydoc_fork/reporter/format_module/#module-pydoc_forkreporterformat_module","text":"Roughly a UI component for modules None View Source \"\"\" Roughly a UI component for modules \"\"\" import inspect import os import pkgutil import sys from typing import Optional , cast from pydoc_fork import settings from pydoc_fork . inspector . custom_types import TypeLike from pydoc_fork . inspector . utils import getdoc , isdata , visiblename from pydoc_fork . reporter import inline_styles from pydoc_fork . reporter . format_class import format_tree from pydoc_fork . reporter . formatter_html import ( STDLIB_BASEDIR , bigsection , escape , file_link , heading , markup , module_package_link , multicolumn , ) def getdocloc ( the_object: TypeLike , basedir : str = STDLIB_BASEDIR ) -> Optional [ str ] : \"\"\"Return the location of module docs or None\"\"\" try : file = inspect . getabsfile ( cast ( type , the_object )) except TypeError : file = \"(built-in)\" basedir = os . path . normcase ( basedir ) is_known_stdlib = the_object . __ name__ in ( \"errno\" , \"exceptions\" , \"gc\" , \"imp\" , \"marshal\" , \"posix\" , \"signal\" , \"sys\" , \"_thread\" , \"zipimport\" , ) is_module = isinstance ( the_object , type ( os )) is_in_pythons_folder = file . startswith ( basedir ) and not file . startswith ( os . path . join ( basedir , \"site-packages\" ) ) # # This is nasty special case coding , how many more special cases are there? # is_exception = the_object . __ name__ in ( \"xml.etree\" , \"test.pydoc_mod\" ) # # special case for etree # \"https://docs.python.org/3/library/xml.etree.elementtree.html\" if ( is_module and ( is_known_stdlib or is_in_pythons_folder ) and settings . PREFER_DOCS_PYTHON_ORG ) : if settings . PYTHONDOCS . startswith (( \"http://\" , \"https://\" )) : doc_loc = ( f \"{settings.PYTHONDOCS.rstrip('/')}/{the_object.__name__.lower()}.html\" ) else : doc_loc = os . path . join ( settings . PYTHONDOCS , the_object . __ name__ . lower () + \".html\" ) else : doc_loc = None return doc_loc def modulelink ( the_object: TypeLike ) -> str : \"\"\"Make a link for a module.\"\"\" url = f \"{the_object.__name__}.html\" internet_link = getdocloc ( the_object ) if internet_link and settings . PREFER_DOCS_PYTHON_ORG : url = internet_link # BUG : doesn't take into consideration an alternate base if not internet_link: settings.MENTIONED_MODULES.add((the_object, the_object.__name__)) return f' < a href= \"{url}\" > { the_object . __ name__ } </a>' def docmodule( the_object: TypeLike, ) -> str: \"\"\"Produce HTML documentation for a module object.\"\"\" # circular ref from pydoc_fork.reporter.format_page import document name = the_object.__name__ try: all_things = None if settings.DOCUMENT_INTERNALS else the_object.__all__ except AttributeError: all_things = None parts = name.split(\".\") links = [] for i in range(len(parts) - 1): link_url = \".\".join(parts[: i + 1]) link_text = parts[i] links.append( f' < a href= \"{link_url}.html\" ><span style= \"color:{inline_styles.MODULE_LINK}\" > { link_text } </span></a>' ) linked_name = \".\".join(links + parts[-1:]) head = f\"<big><big><strong>{linked_name}</strong></big></big>\" try: path = inspect.getabsfile(cast(type, the_object)) # MR : Make relative output_folder_path = os.path.normcase(os.path.abspath(settings.OUTPUT_FOLDER)) path = os.path.relpath(path, output_folder_path).replace(\"\\\\\", \"/\") # end MR # uh, oh, forgot why I wrote this # url = urllib.parse.quote(path) # MR file_link_text = file_link(path, path) except TypeError: file_link_text = \"(built-in)\" info = [] # TODO: Include the rest of the meta data if hasattr(the_object, \"__version__\"): version = str(the_object.__version__) if version[:11] == \"$\" + \"Revision: \" and version[-1:] == \"$\": version = version[11:-1].strip() info.append(f\"version {escape(version)}\") if hasattr(the_object, \"__date__\"): info.append(escape(str(the_object.__date__))) if info: head = head + f\" ({' , '.join(info)})\" document_location = getdocloc(the_object) if document_location is not None: # Was this just a bug? document_location/locals? # document_location = ' < br><a href= \"%(docloc)s\" > Module Reference </a>' % locals() document_location = f' < br><a href= \"{document_location}\" > Module Reference </a>' else: document_location = \"\" result = heading( head, \"#ffffff\", \"#7799ee\", ' < a href= \".\" > index</a><br> ' + file_link_text + document_location , ) # this will get ` import foo ` but ignore ` from foo import bar ` # And bar gets no doc string love either ! modules = inspect . getmembers ( the_object , inspect . ismodule ) for to_remove in settings . SKIP_MODULES : for module_info in modules : candidate_module , _ = module_info if candidate_module == to_remove: try : modules . remove ( module_info ) except ValueError : pass modules_by_import_from = set () classes , class_dict = [], {} for key , value in inspect . getmembers ( the_object , inspect . isclass ) : _ class_module = inspect . getmodule ( value ) if _ class_module and _ class_module is not the_object: if _ class_module . __ name__ not in settings . SKIP_MODULES : modules_by_import_from . add (( None , _ class_module )) settings . MENTIONED_MODULES . add (( _ class_module , _ class_module . __ name__ )) # if __ all__ exists , believe it . Otherwise use old heuristic . if ( # TODO put doc internals switch here # all_things is not None or ( inspect . getmodule ( value ) or the_object ) is the_object ) : if visiblename ( key , all_things , the_object ) : classes . append (( key , value )) class_dict [ key ] = class_dict [ value ] = \"#\" + key for key , value in classes : for base in value . __ bases__: key , modname = base . __ name__ , base . __ module__ module = sys . modules . get ( modname ) if ( modname ! = name and module and hasattr ( module , key ) and getattr ( module , key ) is base and key not in class_dict ) : class_dict [ key ] = class_dict [ base ] = modname + \".html#\" + key funcs , function_dict = [], {} for key , value in inspect . getmembers ( the_object , inspect . isroutine ) : # if __ all__ exists , believe it . Otherwise use old heuristic . _ func_module = inspect . getmodule ( value ) # why does this sometimes return no module? if _ func_module and _ func_module is not the_object: if _ func_module . __ name__ not in settings . SKIP_MODULES : modules_by_import_from . add (( None , _ func_module )) settings . MENTIONED_MODULES . add (( _ func_module , _ func_module . __ name__ )) if ( True # TODO put doc internals switch here # all_things is not None or # __ all__ as scope limiter # inspect . isbuiltin ( value ) # thing w / o module # or inspect . getmodule ( value ) is the_object # from foo import bar ) and visiblename ( key , all_things , the_object ) : funcs . append (( key , value )) function_dict [ key ] = \"#-\" + key if inspect . isfunction ( value ) : function_dict [ value ] = function_dict [ key ] data = [] for key , value in inspect . getmembers ( the_object , isdata ) : if inspect . getmodule ( type ( value )). __ name__ in settings . SKIP_MODULES : continue if visiblename ( key , all_things , the_object ) : data . append (( key , value )) doc = markup ( getdoc ( the_object ), function_dict , class_dict ) doc = doc and f \"<tt>{doc}</tt>\" result = result + f \"<p>{doc}</p>\\n\" if hasattr ( the_object , \"__path__\" ) : module_packages = [] for _ , modname , is_package in pkgutil . iter_modules ( the_object . __ path__ ) : if modname not in settings . SKIP_MODULES : module_packages . append (( modname , name , is_package , 0 )) module_packages . sort () contents_string = multicolumn ( module_packages , module_package_link ) result = result + bigsection ( \"Package Contents\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) elif modules : contents_string = multicolumn ( modules , lambda t : modulelink ( t [ 1 ])) result = result + bigsection ( \"Modules\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) if modules_by_import_from: contents_string = multicolumn ( list ( modules_by_import_from ), lambda t : modulelink ( list ( t )[ 1 ]) ) result = result + bigsection ( \"`from` Modules\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) if classes : class_list = [ value for ( key , value ) in classes ] # MR : boolean type safety contents_list = [ format_tree ( inspect . getclasstree ( class_list , True ), name )] for key , value in classes : contents_list . append ( document ( value , key , name , function_dict , class_dict )) result = result + bigsection ( \"Classes\" , \"#ffffff\" , \"#ee77aa\" , \" \" . join ( contents_list ) ) if funcs : contents_list = [] for key , value in funcs : contents_list . append ( document ( value , key , name , function_dict , class_dict )) result = result + bigsection ( \"Functions\" , \"#ffffff\" , \"#eeaa77\" , \" \" . join ( contents_list ) ) if data : contents_list = [] for key , value in data : contents_list . append ( document ( value , key )) result = result + bigsection ( \"Data\" , \"#ffffff\" , \"#55aa55\" , \"<br>\\n\" . join ( contents_list ) ) if hasattr ( the_object , \"__author__\" ) : contents = markup ( str ( the_object . __ author__ )) result = result + bigsection ( \"Author\" , \"#ffffff\" , \"#7799ee\" , contents ) if hasattr ( the_object , \"__credits__\" ) : contents = markup ( str ( the_object . __ credits__ )) result = result + bigsection ( \"Credits\" , \"#ffffff\" , \"#7799ee\" , contents ) return result","title":"Module pydoc_fork.reporter.format_module"},{"location":"reference/pydoc_fork/reporter/format_module/#variables","text":"STDLIB_BASEDIR","title":"Variables"},{"location":"reference/pydoc_fork/reporter/format_module/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/reporter/format_module/#docmodule","text":"def docmodule ( the_object : pydoc_fork . inspector . custom_types . TypeLike ) -> str Produce HTML documentation for a module object. View Source def docmodule ( the_object: TypeLike , ) -> str : \"\"\"Produce HTML documentation for a module object.\"\"\" # circular ref from pydoc_fork . reporter . format_page import document name = the_object . __ name__ try : all_things = None if settings . DOCUMENT_INTERNALS else the_object . __ all__ except AttributeError : all_things = None parts = name . split ( \".\" ) links = [] for i in range ( len ( parts ) - 1 ) : link_url = \".\" . join ( parts [ : i + 1 ]) link_text = parts [ i ] links . append ( f'<a href=\"{link_url}.html\"><span style=\"color:{inline_styles.MODULE_LINK}\">{link_text}</span></a>' ) linked_name = \".\" . join ( links + parts [ - 1 : ]) head = f \"<big><big><strong>{linked_name}</strong></big></big>\" try : path = inspect . getabsfile ( cast ( type , the_object )) # MR : Make relative output_folder_path = os . path . normcase ( os . path . abspath ( settings . OUTPUT_FOLDER )) path = os . path . relpath ( path , output_folder_path ). replace ( \" \\\\ \", \" / \") # end MR # uh, oh, forgot why I wrote this # url = urllib.parse.quote(path) # MR file_link_text = file_link(path, path) except TypeError: file_link_text = \" ( built - in ) \" info = [] # TODO: Include the rest of the meta data if hasattr(the_object, \" __ version__ \"): version = str(the_object.__version__) if version[:11] == \" $ \" + \" Revision : \" and version[-1:] == \" $ \": version = version[11:-1].strip() info.append(f\" version { escape ( version )} \") if hasattr(the_object, \" __ date__ \"): info.append(escape(str(the_object.__date__))) if info: head = head + f\" ({ ', ' . join ( info )}) \" document_location = getdocloc(the_object) if document_location is not None: # Was this just a bug? document_location/locals? # document_location = '<br><a href=\" %(docloc)s\">Module Reference</a>' % locals() document_location = f'<br><a href=\"{document_location}\">Module Reference</a>' else : document_location = \"\" result = heading ( head , \"#ffffff\" , \"#7799ee\" , '<a href=\".\">index</a><br>' + file_link_text + document_location , ) # this will get ` import foo ` but ignore ` from foo import bar ` # And bar gets no doc string love either ! modules = inspect . getmembers ( the_object , inspect . ismodule ) for to_remove in settings . SKIP_MODULES : for module_info in modules : candidate_module , _ = module_info if candidate_module == to_remove: try : modules . remove ( module_info ) except ValueError : pass modules_by_import_from = set () classes , class_dict = [], {} for key , value in inspect . getmembers ( the_object , inspect . isclass ) : _ class_module = inspect . getmodule ( value ) if _ class_module and _ class_module is not the_object: if _ class_module . __ name__ not in settings . SKIP_MODULES : modules_by_import_from . add (( None , _ class_module )) settings . MENTIONED_MODULES . add (( _ class_module , _ class_module . __ name__ )) # if __ all__ exists , believe it . Otherwise use old heuristic . if ( # TODO put doc internals switch here # all_things is not None or ( inspect . getmodule ( value ) or the_object ) is the_object ) : if visiblename ( key , all_things , the_object ) : classes . append (( key , value )) class_dict [ key ] = class_dict [ value ] = \"#\" + key for key , value in classes : for base in value . __ bases__: key , modname = base . __ name__ , base . __ module__ module = sys . modules . get ( modname ) if ( modname ! = name and module and hasattr ( module , key ) and getattr ( module , key ) is base and key not in class_dict ) : class_dict [ key ] = class_dict [ base ] = modname + \".html#\" + key funcs , function_dict = [], {} for key , value in inspect . getmembers ( the_object , inspect . isroutine ) : # if __ all__ exists , believe it . Otherwise use old heuristic . _ func_module = inspect . getmodule ( value ) # why does this sometimes return no module? if _ func_module and _ func_module is not the_object: if _ func_module . __ name__ not in settings . SKIP_MODULES : modules_by_import_from . add (( None , _ func_module )) settings . MENTIONED_MODULES . add (( _ func_module , _ func_module . __ name__ )) if ( True # TODO put doc internals switch here # all_things is not None or # __ all__ as scope limiter # inspect . isbuiltin ( value ) # thing w / o module # or inspect . getmodule ( value ) is the_object # from foo import bar ) and visiblename ( key , all_things , the_object ) : funcs . append (( key , value )) function_dict [ key ] = \"#-\" + key if inspect . isfunction ( value ) : function_dict [ value ] = function_dict [ key ] data = [] for key , value in inspect . getmembers ( the_object , isdata ) : if inspect . getmodule ( type ( value )). __ name__ in settings . SKIP_MODULES : continue if visiblename ( key , all_things , the_object ) : data . append (( key , value )) doc = markup ( getdoc ( the_object ), function_dict , class_dict ) doc = doc and f \"<tt>{doc}</tt>\" result = result + f \"<p>{doc}</p>\\n\" if hasattr ( the_object , \"__path__\" ) : module_packages = [] for _ , modname , is_package in pkgutil . iter_modules ( the_object . __ path__ ) : if modname not in settings . SKIP_MODULES : module_packages . append (( modname , name , is_package , 0 )) module_packages . sort () contents_string = multicolumn ( module_packages , module_package_link ) result = result + bigsection ( \"Package Contents\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) elif modules : contents_string = multicolumn ( modules , lambda t : modulelink ( t [ 1 ])) result = result + bigsection ( \"Modules\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) if modules_by_import_from: contents_string = multicolumn ( list ( modules_by_import_from ), lambda t : modulelink ( list ( t )[ 1 ]) ) result = result + bigsection ( \"`from` Modules\" , \"#ffffff\" , \"#aa55cc\" , contents_string ) if classes : class_list = [ value for ( key , value ) in classes ] # MR : boolean type safety contents_list = [ format_tree ( inspect . getclasstree ( class_list , True ), name )] for key , value in classes : contents_list . append ( document ( value , key , name , function_dict , class_dict )) result = result + bigsection ( \"Classes\" , \"#ffffff\" , \"#ee77aa\" , \" \" . join ( contents_list ) ) if funcs : contents_list = [] for key , value in funcs : contents_list . append ( document ( value , key , name , function_dict , class_dict )) result = result + bigsection ( \"Functions\" , \"#ffffff\" , \"#eeaa77\" , \" \" . join ( contents_list ) ) if data : contents_list = [] for key , value in data : contents_list . append ( document ( value , key )) result = result + bigsection ( \"Data\" , \"#ffffff\" , \"#55aa55\" , \"<br>\\n\" . join ( contents_list ) ) if hasattr ( the_object , \"__author__\" ) : contents = markup ( str ( the_object . __ author__ )) result = result + bigsection ( \"Author\" , \"#ffffff\" , \"#7799ee\" , contents ) if hasattr ( the_object , \"__credits__\" ) : contents = markup ( str ( the_object . __ credits__ )) result = result + bigsection ( \"Credits\" , \"#ffffff\" , \"#7799ee\" , contents ) return result","title":"docmodule"},{"location":"reference/pydoc_fork/reporter/format_module/#getdocloc","text":"def getdocloc ( the_object : pydoc_fork . inspector . custom_types . TypeLike , basedir : str = 'C: \\\\ Users \\\\ matth \\\\ AppData \\\\ Local \\\\ Programs \\\\ Python \\\\ Python39 \\\\ Lib' ) -> Optional [ str ] Return the location of module docs or None View Source def getdocloc ( the_object : TypeLike , basedir : str = STDLIB_BASEDIR ) -> Optional [ str ] : \"\"\"Return the location of module docs or None\"\"\" try : file = inspect . getabsfile ( cast ( type , the_object )) except TypeError : file = \"(built-in)\" basedir = os . path . normcase ( basedir ) is_known_stdlib = the_object . __name__ in ( \"errno\" , \"exceptions\" , \"gc\" , \"imp\" , \"marshal\" , \"posix\" , \"signal\" , \"sys\" , \"_thread\" , \"zipimport\" , ) is_module = isinstance ( the_object , type ( os )) is_in_pythons_folder = file . startswith ( basedir ) and not file . startswith ( os . path . join ( basedir , \"site-packages\" ) ) # # This is nasty special case coding , how many more special cases are there ? # is_exception = the_object . __name__ in ( \"xml.etree\" , \"test.pydoc_mod\" ) # # special case for etree # \"https://docs.python.org/3/library/xml.etree.elementtree.html\" if ( is_module and ( is_known_stdlib or is_in_pythons_folder ) and settings . PREFER_DOCS_PYTHON_ORG ) : if settings . PYTHONDOCS . startswith (( \"http://\" , \"https://\" )) : doc_loc = ( f \"{settings.PYTHONDOCS.rstrip('/')}/{the_object.__name__.lower()}.html\" ) else : doc_loc = os . path . join ( settings . PYTHONDOCS , the_object . __name__ . lower () + \".html\" ) else : doc_loc = None return doc_loc","title":"getdocloc"},{"location":"reference/pydoc_fork/reporter/format_module/#modulelink","text":"def modulelink ( the_object : pydoc_fork . inspector . custom_types . TypeLike ) -> str Make a link for a module. View Source def modulelink(the_object: TypeLike) -> str: \"\"\"Make a link for a module.\"\"\" url = f\"{the_object.__name__}.html\" internet_link = getdocloc(the_object) if internet_link and settings.PREFER_DOCS_PYTHON_ORG: url = internet_link # BUG: doesn't take into consideration an alternate base if not internet_link: settings.MENTIONED_MODULES.add((the_object, the_object.__name__)) return f' <a href= \"{url}\" > {the_object.__name__} </a> '","title":"modulelink"},{"location":"reference/pydoc_fork/reporter/format_other/","text":"Module pydoc_fork.reporter.format_other Fallback docs None View Source \"\"\" Fallback docs \"\"\" from pydoc_fork.inspector.custom_types import TypeLike from pydoc_fork.reporter.formatter_html import html_repr def docother ( the_object : TypeLike , name : str = \"\" , ) -> str : \"\"\"Produce HTML documentation for a data object.\"\"\" lhs = name and f \"<strong> { name } </strong> = \" or \"\" return lhs + html_repr ( the_object ) Functions docother def docother ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' ) -> str Produce HTML documentation for a data object. View Source def docother( the_object: TypeLike, name: str = \"\", ) -> str: \"\"\"Produce HTML documentation for a data object.\"\"\" lhs = name and f\" <strong> {name} </strong> = \" or \"\" return lhs + html_repr(the_object)","title":"Format Other"},{"location":"reference/pydoc_fork/reporter/format_other/#module-pydoc_forkreporterformat_other","text":"Fallback docs None View Source \"\"\" Fallback docs \"\"\" from pydoc_fork.inspector.custom_types import TypeLike from pydoc_fork.reporter.formatter_html import html_repr def docother ( the_object : TypeLike , name : str = \"\" , ) -> str : \"\"\"Produce HTML documentation for a data object.\"\"\" lhs = name and f \"<strong> { name } </strong> = \" or \"\" return lhs + html_repr ( the_object )","title":"Module pydoc_fork.reporter.format_other"},{"location":"reference/pydoc_fork/reporter/format_other/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/reporter/format_other/#docother","text":"def docother ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' ) -> str Produce HTML documentation for a data object. View Source def docother( the_object: TypeLike, name: str = \"\", ) -> str: \"\"\"Produce HTML documentation for a data object.\"\"\" lhs = name and f\" <strong> {name} </strong> = \" or \"\" return lhs + html_repr(the_object)","title":"docother"},{"location":"reference/pydoc_fork/reporter/format_page/","text":"Module pydoc_fork.reporter.format_page Roughly page and top level containers None View Source \"\"\" Roughly page and top level containers \"\"\" import inspect import pkgutil from typing import Any , Dict , Optional from pydoc_fork.inspector.custom_types import TypeLike from pydoc_fork.reporter.format_class import docclass from pydoc_fork.reporter.format_data import document_data from pydoc_fork.reporter.format_module import docmodule from pydoc_fork.reporter.format_other import docother from pydoc_fork.reporter.format_routine import docroutine from pydoc_fork.reporter.formatter_html import ( bigsection , module_package_link , multicolumn , ) from pydoc_fork.reporter.jinja_code import JINJA_ENV def render ( title : str , the_object : TypeLike , name : str ) -> str : \"\"\"Compose two functions\"\"\" return page ( title , document ( the_object , name )) def page ( title : str , contents : str ) -> str : \"\"\"Format an HTML page. This is part of the public API \"\"\" template = JINJA_ENV . get_template ( \"page.jinja2\" ) result = template . render ( title = title , contents = contents ) return result def document ( the_object : TypeLike , name : str = \"\" , * args : Any ) -> str : # Null safety \"\"\"Generate documentation for an object. This also part of the public API of class Types of : Module, class, routine, data descriptor, \"other\" are supported Modules ignore 1st name. Public API doesn't call with *args Args are: name, fdict, cdict (name twice?) mod, funcs, classes, mdict, the_object \"\"\" args = ( the_object , name ) + args # 'try' clause is to attempt to handle the possibility that inspect # identifies something in a way that pydoc itself has issues handling; # think 'super' and how it is a descriptor (which raises the exception # by lacking a __name__ attribute) and an instance. # try: if inspect . ismodule ( the_object ): return docmodule ( the_object ) if inspect . isclass ( the_object ): return docclass ( * args ) if inspect . isroutine ( the_object ): return docroutine ( * args ) # except AttributeError: # pass # nosec if inspect . isdatadescriptor ( the_object ): return document_data ( the_object , name ) return docother ( the_object , name ) # This is page def index ( directory : str , shadowed : Optional [ Dict [ str , Any ]] = None ) -> str : \"\"\"Generate an HTML index for a directory of modules.\"\"\" module_packages = [] if shadowed is None : shadowed = {} for _ , name , is_package in pkgutil . iter_modules ([ directory ]): if any (( 0xD800 <= ord ( ch ) <= 0xDFFF ) for ch in name ): # ignore a module if its name contains a surrogate character continue module_packages . append (( name , \"\" , is_package , name in shadowed )) shadowed [ name ] = 1 module_packages . sort () contents = multicolumn ( module_packages , module_package_link ) return bigsection ( directory , \"#ffffff\" , \"#ee77aa\" , contents ) Functions document def document ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' , * args : Any ) -> str Generate documentation for an object. This also part of the public API of class Types of : Module, class, routine, data descriptor, \"other\" are supported Modules ignore 1st name. Public API doesn't call with *args Args are: name, fdict, cdict (name twice?) mod, funcs, classes, mdict, the_object View Source def document ( the_object : TypeLike , name : str = \"\" , * args : Any ) -> str : # Null safety \"\"\"Generate documentation for an object. This also part of the public API of class Types of : Module, class, routine, data descriptor, \" other \" are supported Modules ignore 1st name. Public API doesn't call with *args Args are: name, fdict, cdict (name twice?) mod, funcs, classes, mdict, the_object \"\"\" args = ( the_object , name ) + args # 'try' clause is to attempt to handle the possibility that inspect # identifies something in a way that pydoc itself has issues handling ; # think 'super' and how it is a descriptor (which raises the exception # by lacking a __name__ attribute ) and an instance . # try : if inspect . ismodule ( the_object ): return docmodule ( the_object ) if inspect . isclass ( the_object ): return docclass ( * args ) if inspect . isroutine ( the_object ): return docroutine ( * args ) # except AttributeError : # pass # nosec if inspect . isdatadescriptor ( the_object ): return document_data ( the_object , name ) return docother ( the_object , name ) index def index ( directory : str , shadowed : Optional [ Dict [ str , Any ]] = None ) -> str Generate an HTML index for a directory of modules. View Source def index ( directory : str , shadowed : Optional [ Dict[str, Any ] ] = None ) -> str : \"\"\"Generate an HTML index for a directory of modules.\"\"\" module_packages = [] if shadowed is None : shadowed = {} for _ , name , is_package in pkgutil . iter_modules ( [ directory ] ) : if any (( 0xD800 <= ord ( ch ) <= 0xDFFF ) for ch in name ) : # ignore a module if its name contains a surrogate character continue module_packages . append (( name , \"\" , is_package , name in shadowed )) shadowed [ name ] = 1 module_packages . sort () contents = multicolumn ( module_packages , module_package_link ) return bigsection ( directory , \"#ffffff\" , \"#ee77aa\" , contents ) page def page ( title : str , contents : str ) -> str Format an HTML page. This is part of the public API View Source def page ( title : str , contents : str ) -> str : \"\"\"Format an HTML page. This is part of the public API \"\"\" template = JINJA_ENV . get_template ( \"page.jinja2\" ) result = template . render ( title = title , contents = contents ) return result render def render ( title : str , the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str ) -> str Compose two functions View Source def render ( title : str , the_object : TypeLike , name : str ) -> str : \"\"\"Compose two functions\"\"\" return page ( title , document ( the_object , name ))","title":"Format Page"},{"location":"reference/pydoc_fork/reporter/format_page/#module-pydoc_forkreporterformat_page","text":"Roughly page and top level containers None View Source \"\"\" Roughly page and top level containers \"\"\" import inspect import pkgutil from typing import Any , Dict , Optional from pydoc_fork.inspector.custom_types import TypeLike from pydoc_fork.reporter.format_class import docclass from pydoc_fork.reporter.format_data import document_data from pydoc_fork.reporter.format_module import docmodule from pydoc_fork.reporter.format_other import docother from pydoc_fork.reporter.format_routine import docroutine from pydoc_fork.reporter.formatter_html import ( bigsection , module_package_link , multicolumn , ) from pydoc_fork.reporter.jinja_code import JINJA_ENV def render ( title : str , the_object : TypeLike , name : str ) -> str : \"\"\"Compose two functions\"\"\" return page ( title , document ( the_object , name )) def page ( title : str , contents : str ) -> str : \"\"\"Format an HTML page. This is part of the public API \"\"\" template = JINJA_ENV . get_template ( \"page.jinja2\" ) result = template . render ( title = title , contents = contents ) return result def document ( the_object : TypeLike , name : str = \"\" , * args : Any ) -> str : # Null safety \"\"\"Generate documentation for an object. This also part of the public API of class Types of : Module, class, routine, data descriptor, \"other\" are supported Modules ignore 1st name. Public API doesn't call with *args Args are: name, fdict, cdict (name twice?) mod, funcs, classes, mdict, the_object \"\"\" args = ( the_object , name ) + args # 'try' clause is to attempt to handle the possibility that inspect # identifies something in a way that pydoc itself has issues handling; # think 'super' and how it is a descriptor (which raises the exception # by lacking a __name__ attribute) and an instance. # try: if inspect . ismodule ( the_object ): return docmodule ( the_object ) if inspect . isclass ( the_object ): return docclass ( * args ) if inspect . isroutine ( the_object ): return docroutine ( * args ) # except AttributeError: # pass # nosec if inspect . isdatadescriptor ( the_object ): return document_data ( the_object , name ) return docother ( the_object , name ) # This is page def index ( directory : str , shadowed : Optional [ Dict [ str , Any ]] = None ) -> str : \"\"\"Generate an HTML index for a directory of modules.\"\"\" module_packages = [] if shadowed is None : shadowed = {} for _ , name , is_package in pkgutil . iter_modules ([ directory ]): if any (( 0xD800 <= ord ( ch ) <= 0xDFFF ) for ch in name ): # ignore a module if its name contains a surrogate character continue module_packages . append (( name , \"\" , is_package , name in shadowed )) shadowed [ name ] = 1 module_packages . sort () contents = multicolumn ( module_packages , module_package_link ) return bigsection ( directory , \"#ffffff\" , \"#ee77aa\" , contents )","title":"Module pydoc_fork.reporter.format_page"},{"location":"reference/pydoc_fork/reporter/format_page/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/reporter/format_page/#document","text":"def document ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' , * args : Any ) -> str Generate documentation for an object. This also part of the public API of class Types of : Module, class, routine, data descriptor, \"other\" are supported Modules ignore 1st name. Public API doesn't call with *args Args are: name, fdict, cdict (name twice?) mod, funcs, classes, mdict, the_object View Source def document ( the_object : TypeLike , name : str = \"\" , * args : Any ) -> str : # Null safety \"\"\"Generate documentation for an object. This also part of the public API of class Types of : Module, class, routine, data descriptor, \" other \" are supported Modules ignore 1st name. Public API doesn't call with *args Args are: name, fdict, cdict (name twice?) mod, funcs, classes, mdict, the_object \"\"\" args = ( the_object , name ) + args # 'try' clause is to attempt to handle the possibility that inspect # identifies something in a way that pydoc itself has issues handling ; # think 'super' and how it is a descriptor (which raises the exception # by lacking a __name__ attribute ) and an instance . # try : if inspect . ismodule ( the_object ): return docmodule ( the_object ) if inspect . isclass ( the_object ): return docclass ( * args ) if inspect . isroutine ( the_object ): return docroutine ( * args ) # except AttributeError : # pass # nosec if inspect . isdatadescriptor ( the_object ): return document_data ( the_object , name ) return docother ( the_object , name )","title":"document"},{"location":"reference/pydoc_fork/reporter/format_page/#index","text":"def index ( directory : str , shadowed : Optional [ Dict [ str , Any ]] = None ) -> str Generate an HTML index for a directory of modules. View Source def index ( directory : str , shadowed : Optional [ Dict[str, Any ] ] = None ) -> str : \"\"\"Generate an HTML index for a directory of modules.\"\"\" module_packages = [] if shadowed is None : shadowed = {} for _ , name , is_package in pkgutil . iter_modules ( [ directory ] ) : if any (( 0xD800 <= ord ( ch ) <= 0xDFFF ) for ch in name ) : # ignore a module if its name contains a surrogate character continue module_packages . append (( name , \"\" , is_package , name in shadowed )) shadowed [ name ] = 1 module_packages . sort () contents = multicolumn ( module_packages , module_package_link ) return bigsection ( directory , \"#ffffff\" , \"#ee77aa\" , contents )","title":"index"},{"location":"reference/pydoc_fork/reporter/format_page/#page","text":"def page ( title : str , contents : str ) -> str Format an HTML page. This is part of the public API View Source def page ( title : str , contents : str ) -> str : \"\"\"Format an HTML page. This is part of the public API \"\"\" template = JINJA_ENV . get_template ( \"page.jinja2\" ) result = template . render ( title = title , contents = contents ) return result","title":"page"},{"location":"reference/pydoc_fork/reporter/format_page/#render","text":"def render ( title : str , the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str ) -> str Compose two functions View Source def render ( title : str , the_object : TypeLike , name : str ) -> str : \"\"\"Compose two functions\"\"\" return page ( title , document ( the_object , name ))","title":"render"},{"location":"reference/pydoc_fork/reporter/format_routine/","text":"Module pydoc_fork.reporter.format_routine Roughly a UI component for routines None View Source \"\"\"Roughly a UI component for routines \"\"\" import inspect from typing import Any , Dict , Optional from pydoc_fork . inspector . custom_types import TypeLike from pydoc_fork . inspector . utils import _ is_bound_method , getdoc from pydoc_fork . reporter import inline_styles from pydoc_fork . reporter . format_class import classlink from pydoc_fork . reporter . formatter_html import disabled_text , escape , markup def docroutine ( the_object: TypeLike , name : str = \"\" , mod : str = \"\" , funcs : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later classes : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later methods : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later class_object: Optional [ TypeLike ] = None , ) -> str : \"\"\"Produce HTML documentation for a function or method object.\"\"\" if not funcs : funcs = {} if not classes : classes = {} if not methods : methods = {} # AttributeError : 'cached_property' object has no attribute '__name__' try : real_name = the_object . __ name__ except AttributeError : real_name = None name = name or real_name anchor = ( class_object and class_object . __ name__ or \"\" ) + \"-\" + name note = \"\" skip_docs = 0 if _ is_bound_method ( the_object ) : imported_class = the_object . __ self__ . __ class__ if class_object: if imported_class is not class_object: note = \" from \" + classlink ( imported_class , mod ) else : if the_object . __ self__ is not None : link = classlink ( the_object . __ self__ . __ class__ , mod ) note = f \" method of {link} instance\" else : link = classlink ( imported_class , mod ) note = f \" unbound {link} method\" if inspect . iscoroutinefunction ( the_object ) or inspect . isasyncgenfunction ( the_object ) : async_qualifier = \"async \" else : async_qualifier = \"\" if name == real_name: title = f'<a name=\"{anchor}\"><strong>{real_name}</strong></a>' else : if class_object and inspect . getattr_static ( class_object , real_name , []) is the_object: real_link = f'<a href=\"#{class_object.__name__ + \"-\" + real_name}\">{real_name}</a>' skip_docs = 1 else : real_link = real_name title = f'<a name=\"{anchor}\"><strong>{name}</strong></a> = {real_link}' argument_specification = None if inspect . isroutine ( the_object ) : try : signature : Optional [ inspect . Signature ] = inspect . signature ( the_object ) except ( ValueError , TypeError ) : signature = None if signature : argument_specification = str ( signature ) if real_name == \"<lambda>\" : title = f \"<strong>{name}</strong> <em>lambda</em> \" # XXX lambda's won't usually have func_annotations [ 'return' ] # since the syntax doesn't support but it is possible. # So removing parentheses isn't truly safe . argument_specification = argument_specification [ 1 :- 1 ] # remove parentheses if not argument_specification: argument_specification = \"(...)\" decl = ( async_qualifier + title + escape ( argument_specification ) + ( note and disabled_text ( f'<span style=\"font-family:{inline_styles.SAN_SERIF}\">{note}</span>' ) ) ) if skip_docs: return f \"<dl><dt>{decl}</dt></dl>\\n\" doc = markup ( getdoc ( the_object ), funcs , classes , methods ) doc = doc and f \"<dd><tt>{doc}</tt></dd>\" return f \"<dl><dt>{decl}</dt>{doc}</dl>\\n\" Functions docroutine def docroutine ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' , mod : str = '' , funcs : Optional [ Dict [ str , Any ]] = None , classes : Optional [ Dict [ str , Any ]] = None , methods : Optional [ Dict [ str , Any ]] = None , class_object : Optional [ pydoc_fork . inspector . custom_types . TypeLike ] = None ) -> str Produce HTML documentation for a function or method object. View Source def docroutine ( the_object: TypeLike , name : str = \"\" , mod : str = \"\" , funcs : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later classes : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later methods : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later class_object: Optional [ TypeLike ] = None , ) -> str : \"\"\"Produce HTML documentation for a function or method object.\"\"\" if not funcs : funcs = {} if not classes : classes = {} if not methods : methods = {} # AttributeError : 'cached_property' object has no attribute '__name__' try : real_name = the_object . __ name__ except AttributeError : real_name = None name = name or real_name anchor = ( class_object and class_object . __ name__ or \"\" ) + \"-\" + name note = \"\" skip_docs = 0 if _ is_bound_method ( the_object ) : imported_class = the_object . __ self__ . __ class__ if class_object: if imported_class is not class_object: note = \" from \" + classlink ( imported_class , mod ) else : if the_object . __ self__ is not None : link = classlink ( the_object . __ self__ . __ class__ , mod ) note = f \" method of {link} instance\" else : link = classlink ( imported_class , mod ) note = f \" unbound {link} method\" if inspect . iscoroutinefunction ( the_object ) or inspect . isasyncgenfunction ( the_object ) : async_qualifier = \"async \" else : async_qualifier = \"\" if name == real_name: title = f'<a name=\"{anchor}\"><strong>{real_name}</strong></a>' else : if class_object and inspect . getattr_static ( class_object , real_name , []) is the_object: real_link = f'<a href=\"#{class_object.__name__ + \"-\" + real_name}\">{real_name}</a>' skip_docs = 1 else : real_link = real_name title = f'<a name=\"{anchor}\"><strong>{name}</strong></a> = {real_link}' argument_specification = None if inspect . isroutine ( the_object ) : try : signature : Optional [ inspect . Signature ] = inspect . signature ( the_object ) except ( ValueError , TypeError ) : signature = None if signature : argument_specification = str ( signature ) if real_name == \"<lambda>\" : title = f \"<strong>{name}</strong> <em>lambda</em> \" # XXX lambda's won't usually have func_annotations [ 'return' ] # since the syntax doesn't support but it is possible. # So removing parentheses isn't truly safe . argument_specification = argument_specification [ 1 :- 1 ] # remove parentheses if not argument_specification: argument_specification = \"(...)\" decl = ( async_qualifier + title + escape ( argument_specification ) + ( note and disabled_text ( f'<span style=\"font-family:{inline_styles.SAN_SERIF}\">{note}</span>' ) ) ) if skip_docs: return f \"<dl><dt>{decl}</dt></dl>\\n\" doc = markup ( getdoc ( the_object ), funcs , classes , methods ) doc = doc and f \"<dd><tt>{doc}</tt></dd>\" return f \"<dl><dt>{decl}</dt>{doc}</dl>\\n\"","title":"Format Routine"},{"location":"reference/pydoc_fork/reporter/format_routine/#module-pydoc_forkreporterformat_routine","text":"Roughly a UI component for routines None View Source \"\"\"Roughly a UI component for routines \"\"\" import inspect from typing import Any , Dict , Optional from pydoc_fork . inspector . custom_types import TypeLike from pydoc_fork . inspector . utils import _ is_bound_method , getdoc from pydoc_fork . reporter import inline_styles from pydoc_fork . reporter . format_class import classlink from pydoc_fork . reporter . formatter_html import disabled_text , escape , markup def docroutine ( the_object: TypeLike , name : str = \"\" , mod : str = \"\" , funcs : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later classes : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later methods : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later class_object: Optional [ TypeLike ] = None , ) -> str : \"\"\"Produce HTML documentation for a function or method object.\"\"\" if not funcs : funcs = {} if not classes : classes = {} if not methods : methods = {} # AttributeError : 'cached_property' object has no attribute '__name__' try : real_name = the_object . __ name__ except AttributeError : real_name = None name = name or real_name anchor = ( class_object and class_object . __ name__ or \"\" ) + \"-\" + name note = \"\" skip_docs = 0 if _ is_bound_method ( the_object ) : imported_class = the_object . __ self__ . __ class__ if class_object: if imported_class is not class_object: note = \" from \" + classlink ( imported_class , mod ) else : if the_object . __ self__ is not None : link = classlink ( the_object . __ self__ . __ class__ , mod ) note = f \" method of {link} instance\" else : link = classlink ( imported_class , mod ) note = f \" unbound {link} method\" if inspect . iscoroutinefunction ( the_object ) or inspect . isasyncgenfunction ( the_object ) : async_qualifier = \"async \" else : async_qualifier = \"\" if name == real_name: title = f'<a name=\"{anchor}\"><strong>{real_name}</strong></a>' else : if class_object and inspect . getattr_static ( class_object , real_name , []) is the_object: real_link = f'<a href=\"#{class_object.__name__ + \"-\" + real_name}\">{real_name}</a>' skip_docs = 1 else : real_link = real_name title = f'<a name=\"{anchor}\"><strong>{name}</strong></a> = {real_link}' argument_specification = None if inspect . isroutine ( the_object ) : try : signature : Optional [ inspect . Signature ] = inspect . signature ( the_object ) except ( ValueError , TypeError ) : signature = None if signature : argument_specification = str ( signature ) if real_name == \"<lambda>\" : title = f \"<strong>{name}</strong> <em>lambda</em> \" # XXX lambda's won't usually have func_annotations [ 'return' ] # since the syntax doesn't support but it is possible. # So removing parentheses isn't truly safe . argument_specification = argument_specification [ 1 :- 1 ] # remove parentheses if not argument_specification: argument_specification = \"(...)\" decl = ( async_qualifier + title + escape ( argument_specification ) + ( note and disabled_text ( f'<span style=\"font-family:{inline_styles.SAN_SERIF}\">{note}</span>' ) ) ) if skip_docs: return f \"<dl><dt>{decl}</dt></dl>\\n\" doc = markup ( getdoc ( the_object ), funcs , classes , methods ) doc = doc and f \"<dd><tt>{doc}</tt></dd>\" return f \"<dl><dt>{decl}</dt>{doc}</dl>\\n\"","title":"Module pydoc_fork.reporter.format_routine"},{"location":"reference/pydoc_fork/reporter/format_routine/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/reporter/format_routine/#docroutine","text":"def docroutine ( the_object : pydoc_fork . inspector . custom_types . TypeLike , name : str = '' , mod : str = '' , funcs : Optional [ Dict [ str , Any ]] = None , classes : Optional [ Dict [ str , Any ]] = None , methods : Optional [ Dict [ str , Any ]] = None , class_object : Optional [ pydoc_fork . inspector . custom_types . TypeLike ] = None ) -> str Produce HTML documentation for a function or method object. View Source def docroutine ( the_object: TypeLike , name : str = \"\" , mod : str = \"\" , funcs : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later classes : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later methods : Optional [ Dict [ str , Any ]] = None , # noqa - clean up later class_object: Optional [ TypeLike ] = None , ) -> str : \"\"\"Produce HTML documentation for a function or method object.\"\"\" if not funcs : funcs = {} if not classes : classes = {} if not methods : methods = {} # AttributeError : 'cached_property' object has no attribute '__name__' try : real_name = the_object . __ name__ except AttributeError : real_name = None name = name or real_name anchor = ( class_object and class_object . __ name__ or \"\" ) + \"-\" + name note = \"\" skip_docs = 0 if _ is_bound_method ( the_object ) : imported_class = the_object . __ self__ . __ class__ if class_object: if imported_class is not class_object: note = \" from \" + classlink ( imported_class , mod ) else : if the_object . __ self__ is not None : link = classlink ( the_object . __ self__ . __ class__ , mod ) note = f \" method of {link} instance\" else : link = classlink ( imported_class , mod ) note = f \" unbound {link} method\" if inspect . iscoroutinefunction ( the_object ) or inspect . isasyncgenfunction ( the_object ) : async_qualifier = \"async \" else : async_qualifier = \"\" if name == real_name: title = f'<a name=\"{anchor}\"><strong>{real_name}</strong></a>' else : if class_object and inspect . getattr_static ( class_object , real_name , []) is the_object: real_link = f'<a href=\"#{class_object.__name__ + \"-\" + real_name}\">{real_name}</a>' skip_docs = 1 else : real_link = real_name title = f'<a name=\"{anchor}\"><strong>{name}</strong></a> = {real_link}' argument_specification = None if inspect . isroutine ( the_object ) : try : signature : Optional [ inspect . Signature ] = inspect . signature ( the_object ) except ( ValueError , TypeError ) : signature = None if signature : argument_specification = str ( signature ) if real_name == \"<lambda>\" : title = f \"<strong>{name}</strong> <em>lambda</em> \" # XXX lambda's won't usually have func_annotations [ 'return' ] # since the syntax doesn't support but it is possible. # So removing parentheses isn't truly safe . argument_specification = argument_specification [ 1 :- 1 ] # remove parentheses if not argument_specification: argument_specification = \"(...)\" decl = ( async_qualifier + title + escape ( argument_specification ) + ( note and disabled_text ( f'<span style=\"font-family:{inline_styles.SAN_SERIF}\">{note}</span>' ) ) ) if skip_docs: return f \"<dl><dt>{decl}</dt></dl>\\n\" doc = markup ( getdoc ( the_object ), funcs , classes , methods ) doc = doc and f \"<dd><tt>{doc}</tt></dd>\" return f \"<dl><dt>{decl}</dt>{doc}</dl>\\n\"","title":"docroutine"},{"location":"reference/pydoc_fork/reporter/formatter_html/","text":"Module pydoc_fork.reporter.formatter_html Roughly components None View Source \"\"\" Roughly components \"\"\" import logging import re import sysconfig from enum import Enum from typing import Any , Callable , Dict , Optional , Sequence , Tuple , Union , cast import markdown from pydoc_fork import settings from pydoc_fork.inspector.module_utils import ImportTimeError from pydoc_fork.inspector.utils import resolve from pydoc_fork.reporter import inline_styles from pydoc_fork.reporter.html_repr_class import HTMLRepr from pydoc_fork.reporter.jinja_code import JINJA_ENV from pydoc_fork.reporter.rst_support import rst_to_html from pydoc_fork.reporter.string_utils import replace LOGGER = logging . getLogger ( __name__ ) STDLIB_BASEDIR = cast ( str , sysconfig . get_path ( \"stdlib\" )) \"\"\"Formatter class for HTML documentation.\"\"\" # monkey patching was messing with mypy-- is this now a redeclare? def html_repr ( value : Any ) -> str : # noqa - unhiding could break code? \"\"\"Turn method into function\"\"\" _repr_instance = HTMLRepr () return _repr_instance . repr ( value ) def escape ( value : Any ) -> str : \"\"\"HTML safe repr and escape\"\"\" _repr_instance = HTMLRepr () result = _repr_instance . escape ( value ) if \"&amp;gt;\" in result : print ( \"possible double escape\" ) return result def heading ( title : str , fgcol : str , bgcol : str , extras : str = \"\" ) -> str : \"\"\"Format a page heading.\"\"\" template = JINJA_ENV . get_template ( \"heading.jinja2\" ) return template . render ( title = title , fgcol = fgcol , bgcol = bgcol , extras = extras ) def section ( title : str , fgcol : str , bgcol : str , contents : str , width : int = 6 , # used by marginalia? prelude : str = \"\" , marginalia : str = \"\" , # not used gap : str = \"&nbsp;\" , # not used ) -> str : \"\"\"Format a section with a heading.\"\"\" if marginalia is None : marginalia = \"<tt>\" + \"&nbsp;\" * width + \"</tt>\" template = JINJA_ENV . get_template ( \"section.jinja2\" ) return template . render ( title = title , fgcol = fgcol , bgcol = bgcol , marginalia = marginalia , prelude = prelude , contents = contents , gap = gap , ) def bigsection ( title : str , fgcol : str , bgcol : str , contents : str , width : int = 6 , # used by marginalia? prelude : str = \"\" , marginalia : str = \"\" , # not used gap : str = \"&nbsp;\" , # not used ) -> str : \"\"\"Format a section with a big heading.\"\"\" title = f \"<big><strong> { title } </strong></big>\" # prefer explicit interfaces over secret hidden ones return section ( title , fgcol , bgcol , contents , width , prelude , marginalia , gap ) def preformat ( text : str ) -> str : \"\"\"Format literal preformatted text.\"\"\" text = escape ( text . expandtabs ()) return replace ( text , \" \\n\\n \" , \" \\n \\n \" , \" \\n\\n \" , \" \\n \\n \" , \" \" , \"&nbsp;\" , \" \\n \" , \"<br> \\n \" ) def multicolumn ( the_list : Union [ Sequence [ Tuple [ Any , str , Any , int ]], Sequence [ Tuple [ str , Any ]]], the_format : Callable [[ Any ], str ], cols : int = 4 , ) -> str : \"\"\"Format a list of items into a multi-column list.\"\"\" result = \"\" rows = ( len ( the_list ) + cols - 1 ) // cols for col in range ( cols ): result = result + '<td width=\" %d%% \" valign=top>' % ( 100 // cols ) for i in range ( rows * col , rows * col + rows ): if i < len ( the_list ): result = result + the_format ( the_list [ i ]) + \"<br> \\n \" result = result + \"</td>\" return f '<table width=\"100%%\" summary=\"list\"><tr> { result } </tr></table>' def disabled_text ( text : str ) -> str : \"\"\"Wrap in grey\"\"\" return f '<span style=\"color: { inline_styles . DISABLED_TEXT } \"> { text } </span>' def namelink ( name : str , * dicts : Dict [ str , str ]) -> str : \"\"\"Make a link for an identifier, given name-to-URL mappings.\"\"\" for the_dict in dicts : if name in the_dict : return f '<a href=\" { the_dict [ name ] } \"> { name } </a>' # LOGGER.warning(f\"Failed to find link for {name}\") return name def module_package_link ( module_package_info : Tuple [ str , str , str , str ]) -> str : \"\"\"Make a link for a module or package to display in an index.\"\"\" name , path , ispackage , shadowed = module_package_info try : settings . MENTIONED_MODULES . add (( resolve ( path + \".\" + name )[ 0 ], name )) except ( ImportTimeError , ImportError ): print ( f \"Can't import { name } , won't doc\" ) if shadowed : return disabled_text ( name ) if path : url = f \" { path } . { name } .html\" else : url = f \" { name } .html\" if ispackage : text = f \"<strong> { name } </strong>&nbsp;(package)\" else : text = name return f '<a href=\" { url } \"> { text } </a>' def file_link ( url : str , path : str ) -> str : \"\"\"Make a link to source file.\"\"\" return f '<a href=\"file: { url } \"> { path } </a>' class MarkupSyntax ( Enum ): \"\"\"Syntax type we assume comments are using\"\"\" NOTHING = 0 RST = 1 MARKDOWN = 2 def markup ( text : str , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None , methods : Optional [ Dict [ str , str ]] = None , ) -> str : \"\"\" Replace all linkable things with links of appropriate syntax. Handle either an adhoc markup language, or RST or Markdown. funcs, classes, methods are name/symbol to URL maps. \"\"\" funcs = funcs or {} classes = classes or {} methods = methods or {} syntax = MarkupSyntax . NOTHING def nothing ( _ : str ) -> str : \"\"\"Does nothing\"\"\" return _ if syntax == MarkupSyntax . NOTHING : _preformat = preformat markup_to_html = nothing elif syntax == MarkupSyntax . RST : _preformat = nothing markup_to_html = rst_to_html # make_rst_link = elif syntax == MarkupSyntax . MARKDOWN : _preformat = nothing markup_to_html = markdown . markdown # make_markdown_link = else : raise NotImplementedError () results = [] here = 0 pattern = re . compile ( r \"\\b((http|https|ftp)://\\S+[\\w/]|\" r \"RFC[- ]?(\\d+)|\" r \"PEP[- ]?(\\d+)|\" r \"(self\\.)?(\\w+))\" ) while True : match = pattern . search ( text , here ) if not match : break start , end = match . span () results . append ( _preformat ( text [ here : start ])) the_all , scheme , rfc , pep , self_dot , name = match . groups () if scheme : # Hyperlink actual urls url = _preformat ( the_all ) . replace ( '\"' , \"&quot;\" ) results . append ( f '<a href=\" { url } \"> { url } </a>' ) elif rfc : url = \"https://www.rfc-editor.org/rfc/rfc %d .txt\" % int ( rfc ) results . append ( f '<a href=\" { url } \"> { _preformat ( the_all ) } </a>' ) elif pep : url = \"https://www.python.org/dev/peps/pep- %04d /\" % int ( pep ) results . append ( f '<a href=\" { url } \"> { _preformat ( the_all ) } </a>' ) elif self_dot : # Create a link for methods like 'self.method(...)' # and use <strong> for attributes like 'self.attr' if text [ end : end + 1 ] == \"(\" : results . append ( \"self.\" + namelink ( name , methods )) else : results . append ( f \"self.<strong> { name } </strong>\" ) elif text [ end : end + 1 ] == \"(\" : results . append ( namelink ( name , methods , funcs , classes )) else : # This assumes everything else is a class!! results . append ( namelink ( name , classes )) here = end # plain text with links to HTML results . append ( _preformat ( text [ here :])) rejoined_semi_html = \"\" . join ( results ) return markup_to_html ( rejoined_semi_html ) Variables LOGGER STDLIB_BASEDIR Formatter class for HTML documentation. Functions bigsection def bigsection ( title : str , fgcol : str , bgcol : str , contents : str , width : int = 6 , prelude : str = '' , marginalia : str = '' , gap : str = '&nbsp;' ) -> str Format a section with a big heading. View Source def bigsection( title: str, fgcol: str, bgcol: str, contents: str, width: int = 6, # used by marginalia? prelude: str = \"\", marginalia: str = \"\", # not used gap: str = \" &nbsp; \", # not used ) -> str: \"\"\"Format a section with a big heading.\"\"\" title = f\" <big><strong> {title} </strong></big> \" # prefer explicit interfaces over secret hidden ones return section(title, fgcol, bgcol, contents, width, prelude, marginalia, gap) disabled_text def disabled_text ( text : str ) -> str Wrap in grey View Source def disabled_text(text: str) -> str: \"\"\"Wrap in grey\"\"\" return f' <span style= \"color:{inline_styles.DISABLED_TEXT}\" > {text} </span> ' escape def escape ( value : Any ) -> str HTML safe repr and escape View Source def escape ( value : Any ) - > str : \"\"\"HTML safe repr and escape\"\"\" _repr_instance = HTMLRepr () result = _repr_instance . escape ( value ) if \"&amp;gt;\" in result : print ( \"possible double escape\" ) return result file_link def file_link ( url : str , path : str ) -> str Make a link to source file. View Source def file_link(url: str, path: str) -> str: \"\"\"Make a link to source file.\"\"\" return f' <a href= \"file:{url}\" > {path} </a> ' heading def heading ( title : str , fgcol : str , bgcol : str , extras : str = '' ) -> str Format a page heading. View Source def heading ( title : str , fgcol : str , bgcol : str , extras : str = \"\" ) -> str : \"\"\"Format a page heading.\"\"\" template = JINJA_ENV . get_template ( \"heading.jinja2\" ) return template . render ( title = title , fgcol = fgcol , bgcol = bgcol , extras = extras ) html_repr def html_repr ( value : Any ) -> str Turn method into function View Source def html_repr ( value : Any ) -> str : # noqa - unhiding could break code ? \"\"\"Turn method into function\"\"\" _repr_instance = HTMLRepr () return _repr_instance . repr ( value ) markup def markup ( text : str , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None , methods : Optional [ Dict [ str , str ]] = None ) -> str Replace all linkable things with links of appropriate syntax. Handle either an adhoc markup language, or RST or Markdown. funcs, classes, methods are name/symbol to URL maps. View Source def markup ( text : str , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None , methods : Optional [ Dict [ str , str ]] = None , ) -> str : \"\"\" Replace all linkable things with links of appropriate syntax . Handle either an adhoc markup language , or RST or Markdown . funcs , classes , methods are name / symbol to URL maps . \"\"\" funcs = funcs or {} classes = classes or {} methods = methods or {} syntax = MarkupSyntax . NOTHING def nothing ( _ : str ) -> str : \"\"\"Does nothing\"\"\" return _ if syntax == MarkupSyntax . NOTHING : _preformat = preformat markup_to_html = nothing elif syntax == MarkupSyntax . RST : _preformat = nothing markup_to_html = rst_to_html # make_rst_link = elif syntax == MarkupSyntax . MARKDOWN : _preformat = nothing markup_to_html = markdown . markdown # make_markdown_link = else : raise NotImplementedError () results = [] here = 0 pattern = re . compile ( r \" \\b ((http|https|ftp)://\\S+[\\w/]|\" r \"RFC[- ]?(\\d+)|\" r \"PEP[- ]?(\\d+)|\" r \"(self\\.)?(\\w+))\" ) while True : match = pattern . search ( text , here ) if not match : break start , end = match . span () results . append ( _preformat ( text [ here : start ])) the_all , scheme , rfc , pep , self_dot , name = match . groups () if scheme : # Hyperlink actual urls url = _preformat ( the_all ). replace ( '\"' , \"&quot;\" ) results . append ( f ' < a href = \"{url}\" > { url } </ a > ' ) elif rfc : url = \"https://www.rfc-editor.org/rfc/rfc%d.txt\" % int ( rfc ) results . append ( f ' < a href = \"{url}\" > { _preformat ( the_all )} </ a > ' ) elif pep : url = \"https://www.python.org/dev/peps/pep-%04d/\" % int ( pep ) results . append ( f ' < a href = \"{url}\" > { _preformat ( the_all )} </ a > ' ) elif self_dot : # Create a link for methods like 'self.method(...)' # and use <strong> for attributes like 'self.attr' if text [ end : end + 1 ] == \"(\" : results . append ( \"self.\" + namelink ( name , methods )) else : results . append ( f \"self.<strong>{name}</strong>\" ) elif text [ end : end + 1 ] == \"(\" : results . append ( namelink ( name , methods , funcs , classes )) else : # This assumes everything else is a class!! results . append ( namelink ( name , classes )) here = end # plain text with links to HTML results . append ( _preformat ( text [ here :])) rejoined_semi_html = \"\" . join ( results ) return markup_to_html ( rejoined_semi_html ) module_package_link def module_package_link ( module_package_info : Tuple [ str , str , str , str ] ) -> str Make a link for a module or package to display in an index. View Source def module_package_link ( module_package_info : Tuple [ str , str , str , str ]) -> str : \"\"\"Make a link for a module or package to display in an index.\"\"\" name , path , ispackage , shadowed = module_package_info try : settings . MENTIONED_MODULES . add (( resolve ( path + \".\" + name )[ 0 ], name )) except ( ImportTimeError , ImportError ): print ( f \"Can't import { name } , won't doc\" ) if shadowed : return disabled_text ( name ) if path : url = f \" { path } . { name } .html\" else : url = f \" { name } .html\" if ispackage : text = f \"<strong> { name } </strong>&nbsp;(package)\" else : text = name return f '<a href=\" { url } \"> { text } </a>' multicolumn def multicolumn ( the_list : Union [ Sequence [ Tuple [ Any , str , Any , int ]], Sequence [ Tuple [ str , Any ]]], the_format : Callable [[ Any ], str ], cols : int = 4 ) -> str Format a list of items into a multi-column list. View Source def multicolumn ( the_list : Union [ Sequence[Tuple[Any, str, Any, int ] ] , Sequence [ Tuple[str, Any ] ]] , the_format : Callable [ [Any ] , str ] , cols : int = 4 , ) -> str : \"\"\"Format a list of items into a multi-column list.\"\"\" result = \"\" rows = ( len ( the_list ) + cols - 1 ) // cols for col in range ( cols ) : result = result + '<td width=\"%d%%\" valign=top>' % ( 100 // cols ) for i in range ( rows * col , rows * col + rows ) : if i < len ( the_list ) : result = result + the_format ( the_list [ i ] ) + \"<br>\\n\" result = result + \"</td>\" return f '<table width=\"100%%\" summary=\"list\"><tr>{result}</tr></table>' namelink def namelink ( name : str , * dicts : Dict [ str , str ] ) -> str Make a link for an identifier, given name-to-URL mappings. View Source def namelink ( name : str , * dicts : Dict [ str, str ] ) -> str : \"\"\"Make a link for an identifier, given name-to-URL mappings.\"\"\" for the_dict in dicts : if name in the_dict : return f '<a href=\"{the_dict[name]}\">{name}</a>' # LOGGER . warning ( f \"Failed to find link for {name}\" ) return name preformat def preformat ( text : str ) -> str Format literal preformatted text. View Source def preformat ( text : str ) - > str : \"\"\"Format literal preformatted text.\"\"\" text = escape ( text . expandtabs ()) return replace ( text , \"\\n\\n\" , \"\\n \\n\" , \"\\n\\n\" , \"\\n \\n\" , \" \" , \"&nbsp;\" , \"\\n\" , \"<br>\\n\" ) section def section ( title : str , fgcol : str , bgcol : str , contents : str , width : int = 6 , prelude : str = '' , marginalia : str = '' , gap : str = '&nbsp;' ) -> str Format a section with a heading. View Source def section( title: str, fgcol: str, bgcol: str, contents: str, width: int = 6, # used by marginalia? prelude: str = \"\", marginalia: str = \"\", # not used gap: str = \" &nbsp; \", # not used ) -> str: \"\"\"Format a section with a heading.\"\"\" if marginalia is None: marginalia = \" <tt> \" + \" &nbsp; \" * width + \" </tt> \" template = JINJA_ENV.get_template(\"section.jinja2\") return template.render( title=title, fgcol=fgcol, bgcol=bgcol, marginalia=marginalia, prelude=prelude, contents=contents, gap=gap, ) Classes MarkupSyntax class MarkupSyntax ( / , * args , ** kwargs ) View Source class MarkupSyntax ( Enum ): \"\"\"Syntax type we assume comments are using\"\"\" NOTHING = 0 RST = 1 MARKDOWN = 2 Ancestors (in MRO) enum.Enum Class variables MARKDOWN NOTHING RST name value","title":"Formatter Html"},{"location":"reference/pydoc_fork/reporter/formatter_html/#module-pydoc_forkreporterformatter_html","text":"Roughly components None View Source \"\"\" Roughly components \"\"\" import logging import re import sysconfig from enum import Enum from typing import Any , Callable , Dict , Optional , Sequence , Tuple , Union , cast import markdown from pydoc_fork import settings from pydoc_fork.inspector.module_utils import ImportTimeError from pydoc_fork.inspector.utils import resolve from pydoc_fork.reporter import inline_styles from pydoc_fork.reporter.html_repr_class import HTMLRepr from pydoc_fork.reporter.jinja_code import JINJA_ENV from pydoc_fork.reporter.rst_support import rst_to_html from pydoc_fork.reporter.string_utils import replace LOGGER = logging . getLogger ( __name__ ) STDLIB_BASEDIR = cast ( str , sysconfig . get_path ( \"stdlib\" )) \"\"\"Formatter class for HTML documentation.\"\"\" # monkey patching was messing with mypy-- is this now a redeclare? def html_repr ( value : Any ) -> str : # noqa - unhiding could break code? \"\"\"Turn method into function\"\"\" _repr_instance = HTMLRepr () return _repr_instance . repr ( value ) def escape ( value : Any ) -> str : \"\"\"HTML safe repr and escape\"\"\" _repr_instance = HTMLRepr () result = _repr_instance . escape ( value ) if \"&amp;gt;\" in result : print ( \"possible double escape\" ) return result def heading ( title : str , fgcol : str , bgcol : str , extras : str = \"\" ) -> str : \"\"\"Format a page heading.\"\"\" template = JINJA_ENV . get_template ( \"heading.jinja2\" ) return template . render ( title = title , fgcol = fgcol , bgcol = bgcol , extras = extras ) def section ( title : str , fgcol : str , bgcol : str , contents : str , width : int = 6 , # used by marginalia? prelude : str = \"\" , marginalia : str = \"\" , # not used gap : str = \"&nbsp;\" , # not used ) -> str : \"\"\"Format a section with a heading.\"\"\" if marginalia is None : marginalia = \"<tt>\" + \"&nbsp;\" * width + \"</tt>\" template = JINJA_ENV . get_template ( \"section.jinja2\" ) return template . render ( title = title , fgcol = fgcol , bgcol = bgcol , marginalia = marginalia , prelude = prelude , contents = contents , gap = gap , ) def bigsection ( title : str , fgcol : str , bgcol : str , contents : str , width : int = 6 , # used by marginalia? prelude : str = \"\" , marginalia : str = \"\" , # not used gap : str = \"&nbsp;\" , # not used ) -> str : \"\"\"Format a section with a big heading.\"\"\" title = f \"<big><strong> { title } </strong></big>\" # prefer explicit interfaces over secret hidden ones return section ( title , fgcol , bgcol , contents , width , prelude , marginalia , gap ) def preformat ( text : str ) -> str : \"\"\"Format literal preformatted text.\"\"\" text = escape ( text . expandtabs ()) return replace ( text , \" \\n\\n \" , \" \\n \\n \" , \" \\n\\n \" , \" \\n \\n \" , \" \" , \"&nbsp;\" , \" \\n \" , \"<br> \\n \" ) def multicolumn ( the_list : Union [ Sequence [ Tuple [ Any , str , Any , int ]], Sequence [ Tuple [ str , Any ]]], the_format : Callable [[ Any ], str ], cols : int = 4 , ) -> str : \"\"\"Format a list of items into a multi-column list.\"\"\" result = \"\" rows = ( len ( the_list ) + cols - 1 ) // cols for col in range ( cols ): result = result + '<td width=\" %d%% \" valign=top>' % ( 100 // cols ) for i in range ( rows * col , rows * col + rows ): if i < len ( the_list ): result = result + the_format ( the_list [ i ]) + \"<br> \\n \" result = result + \"</td>\" return f '<table width=\"100%%\" summary=\"list\"><tr> { result } </tr></table>' def disabled_text ( text : str ) -> str : \"\"\"Wrap in grey\"\"\" return f '<span style=\"color: { inline_styles . DISABLED_TEXT } \"> { text } </span>' def namelink ( name : str , * dicts : Dict [ str , str ]) -> str : \"\"\"Make a link for an identifier, given name-to-URL mappings.\"\"\" for the_dict in dicts : if name in the_dict : return f '<a href=\" { the_dict [ name ] } \"> { name } </a>' # LOGGER.warning(f\"Failed to find link for {name}\") return name def module_package_link ( module_package_info : Tuple [ str , str , str , str ]) -> str : \"\"\"Make a link for a module or package to display in an index.\"\"\" name , path , ispackage , shadowed = module_package_info try : settings . MENTIONED_MODULES . add (( resolve ( path + \".\" + name )[ 0 ], name )) except ( ImportTimeError , ImportError ): print ( f \"Can't import { name } , won't doc\" ) if shadowed : return disabled_text ( name ) if path : url = f \" { path } . { name } .html\" else : url = f \" { name } .html\" if ispackage : text = f \"<strong> { name } </strong>&nbsp;(package)\" else : text = name return f '<a href=\" { url } \"> { text } </a>' def file_link ( url : str , path : str ) -> str : \"\"\"Make a link to source file.\"\"\" return f '<a href=\"file: { url } \"> { path } </a>' class MarkupSyntax ( Enum ): \"\"\"Syntax type we assume comments are using\"\"\" NOTHING = 0 RST = 1 MARKDOWN = 2 def markup ( text : str , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None , methods : Optional [ Dict [ str , str ]] = None , ) -> str : \"\"\" Replace all linkable things with links of appropriate syntax. Handle either an adhoc markup language, or RST or Markdown. funcs, classes, methods are name/symbol to URL maps. \"\"\" funcs = funcs or {} classes = classes or {} methods = methods or {} syntax = MarkupSyntax . NOTHING def nothing ( _ : str ) -> str : \"\"\"Does nothing\"\"\" return _ if syntax == MarkupSyntax . NOTHING : _preformat = preformat markup_to_html = nothing elif syntax == MarkupSyntax . RST : _preformat = nothing markup_to_html = rst_to_html # make_rst_link = elif syntax == MarkupSyntax . MARKDOWN : _preformat = nothing markup_to_html = markdown . markdown # make_markdown_link = else : raise NotImplementedError () results = [] here = 0 pattern = re . compile ( r \"\\b((http|https|ftp)://\\S+[\\w/]|\" r \"RFC[- ]?(\\d+)|\" r \"PEP[- ]?(\\d+)|\" r \"(self\\.)?(\\w+))\" ) while True : match = pattern . search ( text , here ) if not match : break start , end = match . span () results . append ( _preformat ( text [ here : start ])) the_all , scheme , rfc , pep , self_dot , name = match . groups () if scheme : # Hyperlink actual urls url = _preformat ( the_all ) . replace ( '\"' , \"&quot;\" ) results . append ( f '<a href=\" { url } \"> { url } </a>' ) elif rfc : url = \"https://www.rfc-editor.org/rfc/rfc %d .txt\" % int ( rfc ) results . append ( f '<a href=\" { url } \"> { _preformat ( the_all ) } </a>' ) elif pep : url = \"https://www.python.org/dev/peps/pep- %04d /\" % int ( pep ) results . append ( f '<a href=\" { url } \"> { _preformat ( the_all ) } </a>' ) elif self_dot : # Create a link for methods like 'self.method(...)' # and use <strong> for attributes like 'self.attr' if text [ end : end + 1 ] == \"(\" : results . append ( \"self.\" + namelink ( name , methods )) else : results . append ( f \"self.<strong> { name } </strong>\" ) elif text [ end : end + 1 ] == \"(\" : results . append ( namelink ( name , methods , funcs , classes )) else : # This assumes everything else is a class!! results . append ( namelink ( name , classes )) here = end # plain text with links to HTML results . append ( _preformat ( text [ here :])) rejoined_semi_html = \"\" . join ( results ) return markup_to_html ( rejoined_semi_html )","title":"Module pydoc_fork.reporter.formatter_html"},{"location":"reference/pydoc_fork/reporter/formatter_html/#variables","text":"LOGGER STDLIB_BASEDIR Formatter class for HTML documentation.","title":"Variables"},{"location":"reference/pydoc_fork/reporter/formatter_html/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/reporter/formatter_html/#bigsection","text":"def bigsection ( title : str , fgcol : str , bgcol : str , contents : str , width : int = 6 , prelude : str = '' , marginalia : str = '' , gap : str = '&nbsp;' ) -> str Format a section with a big heading. View Source def bigsection( title: str, fgcol: str, bgcol: str, contents: str, width: int = 6, # used by marginalia? prelude: str = \"\", marginalia: str = \"\", # not used gap: str = \" &nbsp; \", # not used ) -> str: \"\"\"Format a section with a big heading.\"\"\" title = f\" <big><strong> {title} </strong></big> \" # prefer explicit interfaces over secret hidden ones return section(title, fgcol, bgcol, contents, width, prelude, marginalia, gap)","title":"bigsection"},{"location":"reference/pydoc_fork/reporter/formatter_html/#disabled_text","text":"def disabled_text ( text : str ) -> str Wrap in grey View Source def disabled_text(text: str) -> str: \"\"\"Wrap in grey\"\"\" return f' <span style= \"color:{inline_styles.DISABLED_TEXT}\" > {text} </span> '","title":"disabled_text"},{"location":"reference/pydoc_fork/reporter/formatter_html/#escape","text":"def escape ( value : Any ) -> str HTML safe repr and escape View Source def escape ( value : Any ) - > str : \"\"\"HTML safe repr and escape\"\"\" _repr_instance = HTMLRepr () result = _repr_instance . escape ( value ) if \"&amp;gt;\" in result : print ( \"possible double escape\" ) return result","title":"escape"},{"location":"reference/pydoc_fork/reporter/formatter_html/#file_link","text":"def file_link ( url : str , path : str ) -> str Make a link to source file. View Source def file_link(url: str, path: str) -> str: \"\"\"Make a link to source file.\"\"\" return f' <a href= \"file:{url}\" > {path} </a> '","title":"file_link"},{"location":"reference/pydoc_fork/reporter/formatter_html/#heading","text":"def heading ( title : str , fgcol : str , bgcol : str , extras : str = '' ) -> str Format a page heading. View Source def heading ( title : str , fgcol : str , bgcol : str , extras : str = \"\" ) -> str : \"\"\"Format a page heading.\"\"\" template = JINJA_ENV . get_template ( \"heading.jinja2\" ) return template . render ( title = title , fgcol = fgcol , bgcol = bgcol , extras = extras )","title":"heading"},{"location":"reference/pydoc_fork/reporter/formatter_html/#html_repr","text":"def html_repr ( value : Any ) -> str Turn method into function View Source def html_repr ( value : Any ) -> str : # noqa - unhiding could break code ? \"\"\"Turn method into function\"\"\" _repr_instance = HTMLRepr () return _repr_instance . repr ( value )","title":"html_repr"},{"location":"reference/pydoc_fork/reporter/formatter_html/#markup","text":"def markup ( text : str , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None , methods : Optional [ Dict [ str , str ]] = None ) -> str Replace all linkable things with links of appropriate syntax. Handle either an adhoc markup language, or RST or Markdown. funcs, classes, methods are name/symbol to URL maps. View Source def markup ( text : str , funcs : Optional [ Dict [ str , str ]] = None , classes : Optional [ Dict [ str , str ]] = None , methods : Optional [ Dict [ str , str ]] = None , ) -> str : \"\"\" Replace all linkable things with links of appropriate syntax . Handle either an adhoc markup language , or RST or Markdown . funcs , classes , methods are name / symbol to URL maps . \"\"\" funcs = funcs or {} classes = classes or {} methods = methods or {} syntax = MarkupSyntax . NOTHING def nothing ( _ : str ) -> str : \"\"\"Does nothing\"\"\" return _ if syntax == MarkupSyntax . NOTHING : _preformat = preformat markup_to_html = nothing elif syntax == MarkupSyntax . RST : _preformat = nothing markup_to_html = rst_to_html # make_rst_link = elif syntax == MarkupSyntax . MARKDOWN : _preformat = nothing markup_to_html = markdown . markdown # make_markdown_link = else : raise NotImplementedError () results = [] here = 0 pattern = re . compile ( r \" \\b ((http|https|ftp)://\\S+[\\w/]|\" r \"RFC[- ]?(\\d+)|\" r \"PEP[- ]?(\\d+)|\" r \"(self\\.)?(\\w+))\" ) while True : match = pattern . search ( text , here ) if not match : break start , end = match . span () results . append ( _preformat ( text [ here : start ])) the_all , scheme , rfc , pep , self_dot , name = match . groups () if scheme : # Hyperlink actual urls url = _preformat ( the_all ). replace ( '\"' , \"&quot;\" ) results . append ( f ' < a href = \"{url}\" > { url } </ a > ' ) elif rfc : url = \"https://www.rfc-editor.org/rfc/rfc%d.txt\" % int ( rfc ) results . append ( f ' < a href = \"{url}\" > { _preformat ( the_all )} </ a > ' ) elif pep : url = \"https://www.python.org/dev/peps/pep-%04d/\" % int ( pep ) results . append ( f ' < a href = \"{url}\" > { _preformat ( the_all )} </ a > ' ) elif self_dot : # Create a link for methods like 'self.method(...)' # and use <strong> for attributes like 'self.attr' if text [ end : end + 1 ] == \"(\" : results . append ( \"self.\" + namelink ( name , methods )) else : results . append ( f \"self.<strong>{name}</strong>\" ) elif text [ end : end + 1 ] == \"(\" : results . append ( namelink ( name , methods , funcs , classes )) else : # This assumes everything else is a class!! results . append ( namelink ( name , classes )) here = end # plain text with links to HTML results . append ( _preformat ( text [ here :])) rejoined_semi_html = \"\" . join ( results ) return markup_to_html ( rejoined_semi_html )","title":"markup"},{"location":"reference/pydoc_fork/reporter/formatter_html/#module_package_link","text":"def module_package_link ( module_package_info : Tuple [ str , str , str , str ] ) -> str Make a link for a module or package to display in an index. View Source def module_package_link ( module_package_info : Tuple [ str , str , str , str ]) -> str : \"\"\"Make a link for a module or package to display in an index.\"\"\" name , path , ispackage , shadowed = module_package_info try : settings . MENTIONED_MODULES . add (( resolve ( path + \".\" + name )[ 0 ], name )) except ( ImportTimeError , ImportError ): print ( f \"Can't import { name } , won't doc\" ) if shadowed : return disabled_text ( name ) if path : url = f \" { path } . { name } .html\" else : url = f \" { name } .html\" if ispackage : text = f \"<strong> { name } </strong>&nbsp;(package)\" else : text = name return f '<a href=\" { url } \"> { text } </a>'","title":"module_package_link"},{"location":"reference/pydoc_fork/reporter/formatter_html/#multicolumn","text":"def multicolumn ( the_list : Union [ Sequence [ Tuple [ Any , str , Any , int ]], Sequence [ Tuple [ str , Any ]]], the_format : Callable [[ Any ], str ], cols : int = 4 ) -> str Format a list of items into a multi-column list. View Source def multicolumn ( the_list : Union [ Sequence[Tuple[Any, str, Any, int ] ] , Sequence [ Tuple[str, Any ] ]] , the_format : Callable [ [Any ] , str ] , cols : int = 4 , ) -> str : \"\"\"Format a list of items into a multi-column list.\"\"\" result = \"\" rows = ( len ( the_list ) + cols - 1 ) // cols for col in range ( cols ) : result = result + '<td width=\"%d%%\" valign=top>' % ( 100 // cols ) for i in range ( rows * col , rows * col + rows ) : if i < len ( the_list ) : result = result + the_format ( the_list [ i ] ) + \"<br>\\n\" result = result + \"</td>\" return f '<table width=\"100%%\" summary=\"list\"><tr>{result}</tr></table>'","title":"multicolumn"},{"location":"reference/pydoc_fork/reporter/formatter_html/#namelink","text":"def namelink ( name : str , * dicts : Dict [ str , str ] ) -> str Make a link for an identifier, given name-to-URL mappings. View Source def namelink ( name : str , * dicts : Dict [ str, str ] ) -> str : \"\"\"Make a link for an identifier, given name-to-URL mappings.\"\"\" for the_dict in dicts : if name in the_dict : return f '<a href=\"{the_dict[name]}\">{name}</a>' # LOGGER . warning ( f \"Failed to find link for {name}\" ) return name","title":"namelink"},{"location":"reference/pydoc_fork/reporter/formatter_html/#preformat","text":"def preformat ( text : str ) -> str Format literal preformatted text. View Source def preformat ( text : str ) - > str : \"\"\"Format literal preformatted text.\"\"\" text = escape ( text . expandtabs ()) return replace ( text , \"\\n\\n\" , \"\\n \\n\" , \"\\n\\n\" , \"\\n \\n\" , \" \" , \"&nbsp;\" , \"\\n\" , \"<br>\\n\" )","title":"preformat"},{"location":"reference/pydoc_fork/reporter/formatter_html/#section","text":"def section ( title : str , fgcol : str , bgcol : str , contents : str , width : int = 6 , prelude : str = '' , marginalia : str = '' , gap : str = '&nbsp;' ) -> str Format a section with a heading. View Source def section( title: str, fgcol: str, bgcol: str, contents: str, width: int = 6, # used by marginalia? prelude: str = \"\", marginalia: str = \"\", # not used gap: str = \" &nbsp; \", # not used ) -> str: \"\"\"Format a section with a heading.\"\"\" if marginalia is None: marginalia = \" <tt> \" + \" &nbsp; \" * width + \" </tt> \" template = JINJA_ENV.get_template(\"section.jinja2\") return template.render( title=title, fgcol=fgcol, bgcol=bgcol, marginalia=marginalia, prelude=prelude, contents=contents, gap=gap, )","title":"section"},{"location":"reference/pydoc_fork/reporter/formatter_html/#classes","text":"","title":"Classes"},{"location":"reference/pydoc_fork/reporter/formatter_html/#markupsyntax","text":"class MarkupSyntax ( / , * args , ** kwargs ) View Source class MarkupSyntax ( Enum ): \"\"\"Syntax type we assume comments are using\"\"\" NOTHING = 0 RST = 1 MARKDOWN = 2","title":"MarkupSyntax"},{"location":"reference/pydoc_fork/reporter/formatter_html/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/pydoc_fork/reporter/formatter_html/#class-variables","text":"MARKDOWN NOTHING RST name value","title":"Class variables"},{"location":"reference/pydoc_fork/reporter/html_repr_class/","text":"Module pydoc_fork.reporter.html_repr_class Class for safely making an HTML representation of a Python object. None View Source \"\"\"Class for safely making an HTML representation of a Python object.\"\"\" import re from reprlib import Repr from typing import Any , cast from pydoc_fork.reporter import inline_styles from pydoc_fork.reporter.string_utils import cram , replace , stripid class HTMLRepr ( Repr ): \"\"\"Class for safely making an HTML representation of a Python object.\"\"\" def __init__ ( self ) -> None : \"\"\"Some maximums\"\"\" Repr . __init__ ( self ) self . maximum_list = self . maximum_tuple = 20 self . maximum_dict = 10 self . maximum_string = self . maximum_other = 100 # pylint: disable=no-self-use @staticmethod def escape ( text : str ) -> str : \"\"\"Simple html escaping\"\"\" result = replace ( text , \"&\" , \"&amp;\" , \"<\" , \"&lt;\" , \">\" , \"&gt;\" ) # if \"&amp;\" in result: # print(\"possible double escape\") return result def repr ( self , x : Any ) -> str : # noqa - unhiding could break code? \"\"\"Delegates to Repr.repr\"\"\" return Repr . repr ( self , x ) def repr1 ( self , x : Any , level : int ) -> str : \"\"\"Not sure, is dead code?\"\"\" if hasattr ( type ( x ), \"__name__\" ): method_name = \"repr_\" + \"_\" . join ( type ( x ) . __name__ . split ()) if hasattr ( self , method_name ): return cast ( str , getattr ( self , method_name )( x , level )) return self . escape ( cram ( stripid ( repr ( x )), self . maximum_other )) # pylint: disable=invalid-name def repr_string ( self , x : str , _ : int ) -> str : \"\"\"Repr, but squash it into a window\"\"\" test = cram ( x , self . maximum_string ) test_repr = repr ( test ) if \" \\\\ \" in test and \" \\\\ \" not in replace ( test_repr , r \" \\\\ \" , \"\" ): # Backslashes are only literal in the string and are never # needed to make any special characters, so show a raw string. return \"r\" + test_repr [ 0 ] + self . escape ( test ) + test_repr [ 0 ] return re . sub ( r '(( \\\\ [ \\\\ abfnrtv \\' \"]| \\\\ [0-9]..| \\\\ x..| \\\\ u....)+)' , f '<span style=\"color: { inline_styles . REPR_COLOR } \">' + r \"\\1\" + \"</span>\" , self . escape ( test_repr ), ) repr_str = repr_string def repr_instance ( self , x : Any , level : int ) -> str : \"\"\"Repr, but squash it into a window\"\"\" # noinspection PyBroadException try : return self . escape ( cram ( stripid ( repr ( x )), self . maximum_string )) # pylint: disable=broad-except except BaseException : return self . escape ( f \"< { x . __class__ . __name__ } instance>\" ) repr_unicode = repr_string Classes HTMLRepr class HTMLRepr ( ) View Source class HTMLRepr ( Repr ) : \"\"\"Class for safely making an HTML representation of a Python object.\"\"\" def __init__ ( self ) -> None : \"\"\"Some maximums\"\"\" Repr . __init__ ( self ) self . maximum_list = self . maximum_tuple = 20 self . maximum_dict = 10 self . maximum_string = self . maximum_other = 100 # pylint : disable = no - self - use @staticmethod def escape ( text : str ) -> str : \"\"\"Simple html escaping\"\"\" result = replace ( text , \"&\" , \"&amp;\" , \"<\" , \"&lt;\" , \">\" , \"&gt;\" ) # if \"&amp;\" in result : # print ( \"possible double escape\" ) return result def repr ( self , x : Any ) -> str : # noqa - unhiding could break code ? \"\"\"Delegates to Repr.repr\"\"\" return Repr . repr ( self , x ) def repr1 ( self , x : Any , level : int ) -> str : \"\"\"Not sure, is dead code?\"\"\" if hasattr ( type ( x ), \"__name__\" ) : method_name = \"repr_\" + \"_\" . join ( type ( x ). __name__ . split ()) if hasattr ( self , method_name ) : return cast ( str , getattr ( self , method_name )( x , level )) return self . escape ( cram ( stripid ( repr ( x )), self . maximum_other )) # pylint : disable = invalid - name def repr_string ( self , x : str , _ : int ) -> str : \"\"\"Repr, but squash it into a window\"\"\" test = cram ( x , self . maximum_string ) test_repr = repr ( test ) if \"\\\\\" in test and \"\\\\\" not in replace ( test_repr , r \"\\\\\" , \"\" ) : # Backslashes are only literal in the string and are never # needed to make any special characters , so show a raw string . return \"r\" + test_repr [ 0 ] + self . escape ( test ) + test_repr [ 0 ] return re . sub ( r '((\\\\[\\\\abfnrtv\\' \"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)', f'<span style=\" color : { inline_styles . REPR_COLOR } \">' + r\" \\ 1 \" + \" </ span > \", self.escape(test_repr), ) repr_str = repr_string def repr_instance(self, x: Any, level: int) -> str: \"\"\" Repr , but squash it into a window \"\"\" # noinspection PyBroadException try: return self.escape(cram(stripid(repr(x)), self.maximum_string)) # pylint: disable=broad-except except BaseException: return self.escape(f\" < { x . __class__ . __name__ } instance > \" ) repr_unicode = repr_string Ancestors (in MRO) reprlib.Repr Static methods escape def escape ( text : str ) -> str Simple html escaping View Source @staticmethod def escape ( text : str ) -> str : \"\"\"Simple html escaping\"\"\" result = replace ( text , \"&\" , \"&amp;\" , \"<\" , \"&lt;\" , \">\" , \"&gt;\" ) # if \"&amp;\" in result : # print ( \"possible double escape\" ) return result Methods repr def repr ( self , x : Any ) -> str Delegates to Repr.repr View Source def repr ( self , x : Any ) -> str : # noqa - unhiding could break code ? \"\"\"Delegates to Repr.repr\"\"\" return Repr . repr ( self , x ) repr1 def repr1 ( self , x : Any , level : int ) -> str Not sure, is dead code? View Source def repr1 ( self , x : Any , level : int ) -> str : \"\"\"Not sure, is dead code?\"\"\" if hasattr ( type ( x ), \"__name__\" ) : method_name = \"repr_\" + \"_\" . join ( type ( x ). __name__ . split ()) if hasattr ( self , method_name ) : return cast ( str , getattr ( self , method_name )( x , level )) return self . escape ( cram ( stripid ( repr ( x )), self . maximum_other )) repr_array def repr_array ( self , x , level ) View Source def repr_array ( self , x , level ) : if not x : return \" array('%s') \" % x . typecode header = \" array('%s', [ \" % x . typecode return self . _repr_iterable ( x , level , header , ' ]) ' , self . maxarray ) repr_deque def repr_deque ( self , x , level ) View Source def repr_deque ( self , x , level ) : return self . _repr_iterable ( x , level , ' deque([ ' , ' ]) ' , self . maxdeque ) repr_dict def repr_dict ( self , x , level ) View Source def repr_dict ( self , x , level ) : n = len ( x ) if n == 0 : return '{}' if level <= 0 : return '{...}' newlevel = level - 1 repr1 = self . repr1 pieces = [] for key in islice ( _possibly_sorted ( x ), self . maxdict ) : keyrepr = repr1 ( key , newlevel ) valrepr = repr1 ( x [ key ] , newlevel ) pieces . append ( '%s: %s' % ( keyrepr , valrepr )) if n > self . maxdict : pieces . append ( '...' ) s = ', ' . join ( pieces ) return '{%s}' % ( s ,) repr_frozenset def repr_frozenset ( self , x , level ) View Source def repr_frozenset ( self , x , level ) : if not x : return ' frozenset() ' x = _possibly_sorted ( x ) return self . _repr_iterable ( x , level , ' frozenset({ ' , ' }) ' , self . maxfrozenset ) repr_instance def repr_instance ( self , x : Any , level : int ) -> str Repr, but squash it into a window View Source def repr_instance ( self , x : Any , level : int ) -> str : \"\"\"Repr, but squash it into a window\"\"\" # noinspection PyBroadException try : return self . escape ( cram ( stripid ( repr ( x )), self . maximum_string )) # pylint : disable = broad - except except BaseException : return self . escape ( f \"<{x.__class__.__name__} instance>\" ) repr_int def repr_int ( self , x , level ) View Source def repr_int ( self , x , level ) : s = builtins . repr ( x ) # XXX Hope this isn ' t too slow... if len ( s ) > self . maxlong : i = max ( 0 , ( self . maxlong - 3 ) // 2 ) j = max ( 0 , self . maxlong - 3 - i ) s = s [: i ] + ' ... ' + s [ len ( s ) - j :] return s repr_list def repr_list ( self , x , level ) View Source def repr_list ( self , x , level ) : return self . _repr_iterable ( x , level , ' [ ' , ' ] ' , self . maxlist ) repr_set def repr_set ( self , x , level ) View Source def repr_set ( self , x , level ) : if not x : return ' set() ' x = _possibly_sorted ( x ) return self . _repr_iterable ( x , level , ' { ' , ' } ' , self . maxset ) repr_str def repr_str ( self , x : str , _ : int ) -> str Repr, but squash it into a window View Source def repr_string(self, x: str, _: int) -> str: \"\"\"Repr, but squash it into a window\"\"\" test = cram(x, self.maximum_string) test_repr = repr(test) if \"\\\\\" in test and \"\\\\\" not in replace(test_repr, r\"\\\\\", \"\"): # Backslashes are only literal in the string and are never # needed to make any special characters, so show a raw string. return \"r\" + test_repr[0] + self.escape(test) + test_repr[0] return re.sub( r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)', f' <span style= \"color:{inline_styles.REPR_COLOR}\" > ' + r\"\\1\" + \" </span> \", self.escape(test_repr), ) repr_string def repr_string ( self , x : str , _ : int ) -> str Repr, but squash it into a window View Source def repr_string(self, x: str, _: int) -> str: \"\"\"Repr, but squash it into a window\"\"\" test = cram(x, self.maximum_string) test_repr = repr(test) if \"\\\\\" in test and \"\\\\\" not in replace(test_repr, r\"\\\\\", \"\"): # Backslashes are only literal in the string and are never # needed to make any special characters, so show a raw string. return \"r\" + test_repr[0] + self.escape(test) + test_repr[0] return re.sub( r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)', f' <span style= \"color:{inline_styles.REPR_COLOR}\" > ' + r\"\\1\" + \" </span> \", self.escape(test_repr), ) repr_tuple def repr_tuple ( self , x , level ) View Source def repr_tuple ( self , x , level ) : return self . _repr_iterable ( x , level , ' ( ' , ' ) ' , self . maxtuple , ' , ' ) repr_unicode def repr_unicode ( self , x : str , _ : int ) -> str Repr, but squash it into a window View Source def repr_string(self, x: str, _: int) -> str: \"\"\"Repr, but squash it into a window\"\"\" test = cram(x, self.maximum_string) test_repr = repr(test) if \"\\\\\" in test and \"\\\\\" not in replace(test_repr, r\"\\\\\", \"\"): # Backslashes are only literal in the string and are never # needed to make any special characters, so show a raw string. return \"r\" + test_repr[0] + self.escape(test) + test_repr[0] return re.sub( r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)', f' <span style= \"color:{inline_styles.REPR_COLOR}\" > ' + r\"\\1\" + \" </span> \", self.escape(test_repr), )","title":"Html Repr Class"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#module-pydoc_forkreporterhtml_repr_class","text":"Class for safely making an HTML representation of a Python object. None View Source \"\"\"Class for safely making an HTML representation of a Python object.\"\"\" import re from reprlib import Repr from typing import Any , cast from pydoc_fork.reporter import inline_styles from pydoc_fork.reporter.string_utils import cram , replace , stripid class HTMLRepr ( Repr ): \"\"\"Class for safely making an HTML representation of a Python object.\"\"\" def __init__ ( self ) -> None : \"\"\"Some maximums\"\"\" Repr . __init__ ( self ) self . maximum_list = self . maximum_tuple = 20 self . maximum_dict = 10 self . maximum_string = self . maximum_other = 100 # pylint: disable=no-self-use @staticmethod def escape ( text : str ) -> str : \"\"\"Simple html escaping\"\"\" result = replace ( text , \"&\" , \"&amp;\" , \"<\" , \"&lt;\" , \">\" , \"&gt;\" ) # if \"&amp;\" in result: # print(\"possible double escape\") return result def repr ( self , x : Any ) -> str : # noqa - unhiding could break code? \"\"\"Delegates to Repr.repr\"\"\" return Repr . repr ( self , x ) def repr1 ( self , x : Any , level : int ) -> str : \"\"\"Not sure, is dead code?\"\"\" if hasattr ( type ( x ), \"__name__\" ): method_name = \"repr_\" + \"_\" . join ( type ( x ) . __name__ . split ()) if hasattr ( self , method_name ): return cast ( str , getattr ( self , method_name )( x , level )) return self . escape ( cram ( stripid ( repr ( x )), self . maximum_other )) # pylint: disable=invalid-name def repr_string ( self , x : str , _ : int ) -> str : \"\"\"Repr, but squash it into a window\"\"\" test = cram ( x , self . maximum_string ) test_repr = repr ( test ) if \" \\\\ \" in test and \" \\\\ \" not in replace ( test_repr , r \" \\\\ \" , \"\" ): # Backslashes are only literal in the string and are never # needed to make any special characters, so show a raw string. return \"r\" + test_repr [ 0 ] + self . escape ( test ) + test_repr [ 0 ] return re . sub ( r '(( \\\\ [ \\\\ abfnrtv \\' \"]| \\\\ [0-9]..| \\\\ x..| \\\\ u....)+)' , f '<span style=\"color: { inline_styles . REPR_COLOR } \">' + r \"\\1\" + \"</span>\" , self . escape ( test_repr ), ) repr_str = repr_string def repr_instance ( self , x : Any , level : int ) -> str : \"\"\"Repr, but squash it into a window\"\"\" # noinspection PyBroadException try : return self . escape ( cram ( stripid ( repr ( x )), self . maximum_string )) # pylint: disable=broad-except except BaseException : return self . escape ( f \"< { x . __class__ . __name__ } instance>\" ) repr_unicode = repr_string","title":"Module pydoc_fork.reporter.html_repr_class"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#classes","text":"","title":"Classes"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#htmlrepr","text":"class HTMLRepr ( ) View Source class HTMLRepr ( Repr ) : \"\"\"Class for safely making an HTML representation of a Python object.\"\"\" def __init__ ( self ) -> None : \"\"\"Some maximums\"\"\" Repr . __init__ ( self ) self . maximum_list = self . maximum_tuple = 20 self . maximum_dict = 10 self . maximum_string = self . maximum_other = 100 # pylint : disable = no - self - use @staticmethod def escape ( text : str ) -> str : \"\"\"Simple html escaping\"\"\" result = replace ( text , \"&\" , \"&amp;\" , \"<\" , \"&lt;\" , \">\" , \"&gt;\" ) # if \"&amp;\" in result : # print ( \"possible double escape\" ) return result def repr ( self , x : Any ) -> str : # noqa - unhiding could break code ? \"\"\"Delegates to Repr.repr\"\"\" return Repr . repr ( self , x ) def repr1 ( self , x : Any , level : int ) -> str : \"\"\"Not sure, is dead code?\"\"\" if hasattr ( type ( x ), \"__name__\" ) : method_name = \"repr_\" + \"_\" . join ( type ( x ). __name__ . split ()) if hasattr ( self , method_name ) : return cast ( str , getattr ( self , method_name )( x , level )) return self . escape ( cram ( stripid ( repr ( x )), self . maximum_other )) # pylint : disable = invalid - name def repr_string ( self , x : str , _ : int ) -> str : \"\"\"Repr, but squash it into a window\"\"\" test = cram ( x , self . maximum_string ) test_repr = repr ( test ) if \"\\\\\" in test and \"\\\\\" not in replace ( test_repr , r \"\\\\\" , \"\" ) : # Backslashes are only literal in the string and are never # needed to make any special characters , so show a raw string . return \"r\" + test_repr [ 0 ] + self . escape ( test ) + test_repr [ 0 ] return re . sub ( r '((\\\\[\\\\abfnrtv\\' \"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)', f'<span style=\" color : { inline_styles . REPR_COLOR } \">' + r\" \\ 1 \" + \" </ span > \", self.escape(test_repr), ) repr_str = repr_string def repr_instance(self, x: Any, level: int) -> str: \"\"\" Repr , but squash it into a window \"\"\" # noinspection PyBroadException try: return self.escape(cram(stripid(repr(x)), self.maximum_string)) # pylint: disable=broad-except except BaseException: return self.escape(f\" < { x . __class__ . __name__ } instance > \" ) repr_unicode = repr_string","title":"HTMLRepr"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#ancestors-in-mro","text":"reprlib.Repr","title":"Ancestors (in MRO)"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#static-methods","text":"","title":"Static methods"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#escape","text":"def escape ( text : str ) -> str Simple html escaping View Source @staticmethod def escape ( text : str ) -> str : \"\"\"Simple html escaping\"\"\" result = replace ( text , \"&\" , \"&amp;\" , \"<\" , \"&lt;\" , \">\" , \"&gt;\" ) # if \"&amp;\" in result : # print ( \"possible double escape\" ) return result","title":"escape"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#methods","text":"","title":"Methods"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr","text":"def repr ( self , x : Any ) -> str Delegates to Repr.repr View Source def repr ( self , x : Any ) -> str : # noqa - unhiding could break code ? \"\"\"Delegates to Repr.repr\"\"\" return Repr . repr ( self , x )","title":"repr"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr1","text":"def repr1 ( self , x : Any , level : int ) -> str Not sure, is dead code? View Source def repr1 ( self , x : Any , level : int ) -> str : \"\"\"Not sure, is dead code?\"\"\" if hasattr ( type ( x ), \"__name__\" ) : method_name = \"repr_\" + \"_\" . join ( type ( x ). __name__ . split ()) if hasattr ( self , method_name ) : return cast ( str , getattr ( self , method_name )( x , level )) return self . escape ( cram ( stripid ( repr ( x )), self . maximum_other ))","title":"repr1"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_array","text":"def repr_array ( self , x , level ) View Source def repr_array ( self , x , level ) : if not x : return \" array('%s') \" % x . typecode header = \" array('%s', [ \" % x . typecode return self . _repr_iterable ( x , level , header , ' ]) ' , self . maxarray )","title":"repr_array"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_deque","text":"def repr_deque ( self , x , level ) View Source def repr_deque ( self , x , level ) : return self . _repr_iterable ( x , level , ' deque([ ' , ' ]) ' , self . maxdeque )","title":"repr_deque"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_dict","text":"def repr_dict ( self , x , level ) View Source def repr_dict ( self , x , level ) : n = len ( x ) if n == 0 : return '{}' if level <= 0 : return '{...}' newlevel = level - 1 repr1 = self . repr1 pieces = [] for key in islice ( _possibly_sorted ( x ), self . maxdict ) : keyrepr = repr1 ( key , newlevel ) valrepr = repr1 ( x [ key ] , newlevel ) pieces . append ( '%s: %s' % ( keyrepr , valrepr )) if n > self . maxdict : pieces . append ( '...' ) s = ', ' . join ( pieces ) return '{%s}' % ( s ,)","title":"repr_dict"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_frozenset","text":"def repr_frozenset ( self , x , level ) View Source def repr_frozenset ( self , x , level ) : if not x : return ' frozenset() ' x = _possibly_sorted ( x ) return self . _repr_iterable ( x , level , ' frozenset({ ' , ' }) ' , self . maxfrozenset )","title":"repr_frozenset"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_instance","text":"def repr_instance ( self , x : Any , level : int ) -> str Repr, but squash it into a window View Source def repr_instance ( self , x : Any , level : int ) -> str : \"\"\"Repr, but squash it into a window\"\"\" # noinspection PyBroadException try : return self . escape ( cram ( stripid ( repr ( x )), self . maximum_string )) # pylint : disable = broad - except except BaseException : return self . escape ( f \"<{x.__class__.__name__} instance>\" )","title":"repr_instance"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_int","text":"def repr_int ( self , x , level ) View Source def repr_int ( self , x , level ) : s = builtins . repr ( x ) # XXX Hope this isn ' t too slow... if len ( s ) > self . maxlong : i = max ( 0 , ( self . maxlong - 3 ) // 2 ) j = max ( 0 , self . maxlong - 3 - i ) s = s [: i ] + ' ... ' + s [ len ( s ) - j :] return s","title":"repr_int"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_list","text":"def repr_list ( self , x , level ) View Source def repr_list ( self , x , level ) : return self . _repr_iterable ( x , level , ' [ ' , ' ] ' , self . maxlist )","title":"repr_list"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_set","text":"def repr_set ( self , x , level ) View Source def repr_set ( self , x , level ) : if not x : return ' set() ' x = _possibly_sorted ( x ) return self . _repr_iterable ( x , level , ' { ' , ' } ' , self . maxset )","title":"repr_set"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_str","text":"def repr_str ( self , x : str , _ : int ) -> str Repr, but squash it into a window View Source def repr_string(self, x: str, _: int) -> str: \"\"\"Repr, but squash it into a window\"\"\" test = cram(x, self.maximum_string) test_repr = repr(test) if \"\\\\\" in test and \"\\\\\" not in replace(test_repr, r\"\\\\\", \"\"): # Backslashes are only literal in the string and are never # needed to make any special characters, so show a raw string. return \"r\" + test_repr[0] + self.escape(test) + test_repr[0] return re.sub( r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)', f' <span style= \"color:{inline_styles.REPR_COLOR}\" > ' + r\"\\1\" + \" </span> \", self.escape(test_repr), )","title":"repr_str"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_string","text":"def repr_string ( self , x : str , _ : int ) -> str Repr, but squash it into a window View Source def repr_string(self, x: str, _: int) -> str: \"\"\"Repr, but squash it into a window\"\"\" test = cram(x, self.maximum_string) test_repr = repr(test) if \"\\\\\" in test and \"\\\\\" not in replace(test_repr, r\"\\\\\", \"\"): # Backslashes are only literal in the string and are never # needed to make any special characters, so show a raw string. return \"r\" + test_repr[0] + self.escape(test) + test_repr[0] return re.sub( r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)', f' <span style= \"color:{inline_styles.REPR_COLOR}\" > ' + r\"\\1\" + \" </span> \", self.escape(test_repr), )","title":"repr_string"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_tuple","text":"def repr_tuple ( self , x , level ) View Source def repr_tuple ( self , x , level ) : return self . _repr_iterable ( x , level , ' ( ' , ' ) ' , self . maxtuple , ' , ' )","title":"repr_tuple"},{"location":"reference/pydoc_fork/reporter/html_repr_class/#repr_unicode","text":"def repr_unicode ( self , x : str , _ : int ) -> str Repr, but squash it into a window View Source def repr_string(self, x: str, _: int) -> str: \"\"\"Repr, but squash it into a window\"\"\" test = cram(x, self.maximum_string) test_repr = repr(test) if \"\\\\\" in test and \"\\\\\" not in replace(test_repr, r\"\\\\\", \"\"): # Backslashes are only literal in the string and are never # needed to make any special characters, so show a raw string. return \"r\" + test_repr[0] + self.escape(test) + test_repr[0] return re.sub( r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)', f' <span style= \"color:{inline_styles.REPR_COLOR}\" > ' + r\"\\1\" + \" </span> \", self.escape(test_repr), )","title":"repr_unicode"},{"location":"reference/pydoc_fork/reporter/inline_styles/","text":"Module pydoc_fork.reporter.inline_styles Style sheet for hardcoded styles None View Source \"\"\" Style sheet for hardcoded styles \"\"\" REPR_COLOR = \" #c040c0 \" # purple DISABLED_TEXT = \" #909090 \" # grey MODULE_LINK = \"\" # ffffff \" # white SAN_SERIF = \" helvetica, arial, sans-serif \" Variables DISABLED_TEXT MODULE_LINK REPR_COLOR SAN_SERIF","title":"Inline Styles"},{"location":"reference/pydoc_fork/reporter/inline_styles/#module-pydoc_forkreporterinline_styles","text":"Style sheet for hardcoded styles None View Source \"\"\" Style sheet for hardcoded styles \"\"\" REPR_COLOR = \" #c040c0 \" # purple DISABLED_TEXT = \" #909090 \" # grey MODULE_LINK = \"\" # ffffff \" # white SAN_SERIF = \" helvetica, arial, sans-serif \"","title":"Module pydoc_fork.reporter.inline_styles"},{"location":"reference/pydoc_fork/reporter/inline_styles/#variables","text":"DISABLED_TEXT MODULE_LINK REPR_COLOR SAN_SERIF","title":"Variables"},{"location":"reference/pydoc_fork/reporter/jinja_code/","text":"Module pydoc_fork.reporter.jinja_code Jinja setup None View Source \"\"\" Jinja setup \"\"\" from jinja2 import Environment , PackageLoader , select_autoescape JINJA_ENV = Environment ( loader = PackageLoader ( \"pydoc_fork\" ), autoescape = select_autoescape () ) \"\"\"Object to let Jinja find template folder\"\"\" Variables JINJA_ENV Object to let Jinja find template folder","title":"Jinja Code"},{"location":"reference/pydoc_fork/reporter/jinja_code/#module-pydoc_forkreporterjinja_code","text":"Jinja setup None View Source \"\"\" Jinja setup \"\"\" from jinja2 import Environment , PackageLoader , select_autoescape JINJA_ENV = Environment ( loader = PackageLoader ( \"pydoc_fork\" ), autoescape = select_autoescape () ) \"\"\"Object to let Jinja find template folder\"\"\"","title":"Module pydoc_fork.reporter.jinja_code"},{"location":"reference/pydoc_fork/reporter/jinja_code/#variables","text":"JINJA_ENV Object to let Jinja find template folder","title":"Variables"},{"location":"reference/pydoc_fork/reporter/rst_support/","text":"Module pydoc_fork.reporter.rst_support Rst to HTML function Credits: https://stackoverflow.com/a/49047197/33264 View Source \"\"\" Rst to HTML function Credits: https://stackoverflow.com/a/49047197/33264 \"\"\" from docutils import core from docutils.writers.html4css1 import HTMLTranslator , Writer from typing import Any , List class HTMLFragmentTranslator ( HTMLTranslator ): \"\"\"Minimum to call docutils\"\"\" def __init__ ( self , document : Any ) -> None : \"\"\"setup\"\"\" HTMLTranslator . __init__ ( self , document ) self . head_prefix = [ \"\" , \"\" , \"\" , \"\" , \"\" ] self . body_prefix : List [ Any ] = [] self . body_suffix : List [ Any ] = [] self . stylesheet : List [ Any ] = [] def astext ( self ) -> str : \"\"\"minimum to call docutils\"\"\" return \"\" . join ( self . body ) html_fragment_writer = Writer () html_fragment_writer . translator_class = HTMLFragmentTranslator def rst_to_html ( text : str ) -> str : \"\"\"Convert rst string to html string\"\"\" return core . publish_string ( text , writer = html_fragment_writer ) . decode ( \"utf-8\" ) Variables html_fragment_writer Functions rst_to_html def rst_to_html ( text : str ) -> str Convert rst string to html string View Source def rst_to_html ( text : str ) -> str : \"\"\"Convert rst string to html string\"\"\" return core . publish_string ( text , writer = html_fragment_writer ). decode ( \"utf-8\" ) Classes HTMLFragmentTranslator class HTMLFragmentTranslator ( document : Any ) View Source class HTMLFragmentTranslator ( HTMLTranslator ) : \"\"\"Minimum to call docutils\"\"\" def __init__ ( self , document : Any ) -> None : \"\"\"setup\"\"\" HTMLTranslator . __init__ ( self , document ) self . head_prefix = [ \"\", \"\", \"\", \"\", \"\" ] self . body_prefix : List [ Any ] = [] self . body_suffix : List [ Any ] = [] self . stylesheet : List [ Any ] = [] def astext ( self ) -> str : \"\"\"minimum to call docutils\"\"\" return \"\" . join ( self . body ) Ancestors (in MRO) docutils.writers.html4css1.HTMLTranslator docutils.writers._html_base.HTMLTranslator docutils.nodes.NodeVisitor Class variables attribution_formats content_type content_type_mathml doctype doctype_mathml embedded_stylesheet generator head_prefix_template in_word_wrap_point lang_attribute math_tags mathjax_script mathjax_url object_image_types optional special_characters stylesheet_link words_and_spaces xml_declaration Methods add_meta def add_meta ( self , tag ) View Source def add_meta(self, tag): self.meta.append(tag) self.head.append(tag) astext def astext ( self ) -> str minimum to call docutils View Source def astext ( self ) -> str : \"\"\"minimum to call docutils\"\"\" return \"\" . join ( self . body ) attval def attval ( self , text , whitespace = re . compile ( '[ \\n\\r\\t\\x0b\\x0c ]' ) ) Cleanse, HTML encode, and return attribute value text. View Source def attval ( self , text , whitespace = re . compile ( ' [ \\ n \\ r \\ t \\ v \\ f ] ' )): \"\"\"Cleanse, HTML encode, and return attribute value text.\"\"\" encoded = self . encode ( whitespace . sub ( ' ' , text )) if self . in_mailto and self . settings . cloak_email_addresses : # Cloak at-signs ( \"%40\" ) and periods with HTML entities . encoded = encoded . replace ( '%40' , '&#37;&#52;&#48;' ) encoded = encoded . replace ( '.' , '&#46;' ) return encoded check_simple_list def check_simple_list ( self , node ) Check for a simple list that can be rendered compactly. View Source def check_simple_list ( self , node ) : \"\"\" Check for a simple list that can be rendered compactly. \"\"\" visitor = SimpleListChecker ( self . document ) try : node . walk ( visitor ) except nodes . NodeFound : return False else : return True cloak_email def cloak_email ( self , addr ) Try to hide the link text of a email link from harversters. View Source def cloak_email ( self , addr ) : \"\"\"Try to hide the link text of a email link from harversters.\"\"\" # Surround at-signs and periods with <span> tags. (\"@\" has # already been encoded to \"&#64 ; \" by the `encode` method.) addr = addr . replace ( ' & # 64 ; ' , ' < span >& # 64 ; </ span > ' ) addr = addr . replace ( '.' , ' < span >& # 46 ; </ span > ' ) return addr cloak_mailto def cloak_mailto ( self , uri ) Try to hide a mailto: URL from harvesters. View Source def cloak_mailto ( self , uri ) : \"\"\"Try to hide a mailto: URL from harvesters.\"\"\" # Encode \"@\" using a URL octet reference (see RFC 1738). # Further cloaking with HTML entities will be done in the # `attval` function. return uri . replace ( '@' , ' % 40 ' ) depart_Text def depart_Text ( self , node ) View Source def depart_Text(self, node): pass depart_abbreviation def depart_abbreviation ( self , node ) View Source def depart_abbreviation(self, node): self.body.append('</abbr>') depart_acronym def depart_acronym ( self , node ) View Source def depart_acronym(self, node): self.body.append('</acronym>') depart_address def depart_address ( self , node ) View Source def depart_address(self, node): self.body.append('\\n</pre>\\n') self.depart_docinfo_item() depart_admonition def depart_admonition ( self , node = None ) View Source def depart_admonition(self, node=None): self.body.append('</div>\\n') depart_attribution def depart_attribution ( self , node ) View Source def depart_attribution(self, node): self.body.append(self.context.pop() + '</p>\\n') depart_author def depart_author ( self , node ) View Source def depart_author ( self , node ) : if isinstance ( node . parent , nodes . authors ) : self . author_in_authors = True else : self . depart_docinfo_item () depart_authors def depart_authors ( self , node ) View Source def depart_authors(self, node): self.depart_docinfo_item() depart_block_quote def depart_block_quote ( self , node ) View Source def depart_block_quote(self, node): self.body.append('</blockquote>\\n') depart_bullet_list def depart_bullet_list ( self , node ) View Source def depart_bullet_list(self, node): self.compact_simple, self.compact_p = self.context.pop() self.body.append('</ul>\\n') depart_caption def depart_caption ( self , node ) View Source def depart_caption(self, node): self.body.append('</p>\\n') depart_citation def depart_citation ( self , node ) View Source def depart_citation(self, node): self.body.append(' </td></tr> \\n' ' </tbody> \\n </table> \\n') depart_citation_reference def depart_citation_reference ( self , node ) View Source def depart_citation_reference(self, node): self.body.append(']</a>') depart_classifier def depart_classifier ( self , node ) View Source def depart_classifier(self, node): self.body.append('</span>') depart_colspec def depart_colspec ( self , node ) View Source def depart_colspec(self, node): # write out <colgroup> when all colspecs are processed if isinstance(node.next_node(descend=False, siblings=True), nodes.colspec): return if 'colwidths-auto' in node.parent.parent['classes'] or ( 'colwidths-auto' in self.settings.table_style and ('colwidths-given' not in node.parent.parent['classes'])): return total_width = sum(node['colwidth'] for node in self.colspecs) self.body.append(self.starttag(node, 'colgroup')) for node in self.colspecs: colwidth = int(node['colwidth'] * 100.0 / total_width + 0.5) self.body.append(self.emptytag(node, 'col', width='%i%%' % colwidth)) self.body.append(' </colgroup> \\n') depart_compound def depart_compound ( self , node ) View Source def depart_compound(self, node): self.body.append('</div>\\n') depart_contact def depart_contact ( self , node ) View Source def depart_contact(self, node): self.depart_docinfo_item() depart_container def depart_container ( self , node ) View Source def depart_container(self, node): self.body.append('</div>\\n') depart_copyright def depart_copyright ( self , node ) View Source def depart_copyright(self, node): self.depart_docinfo_item() depart_date def depart_date ( self , node ) View Source def depart_date(self, node): self.depart_docinfo_item() depart_decoration def depart_decoration ( self , node ) View Source def depart_decoration(self, node): pass depart_definition def depart_definition ( self , node ) View Source def depart_definition(self, node): self.body.append('</dd>\\n') depart_definition_list def depart_definition_list ( self , node ) View Source def depart_definition_list(self, node): self.body.append('</dl>\\n') depart_definition_list_item def depart_definition_list_item ( self , node ) View Source def depart_definition_list_item(self, node): pass depart_description def depart_description ( self , node ) View Source def depart_description(self, node): self.body.append('</td>') depart_docinfo def depart_docinfo ( self , node ) View Source def depart_docinfo(self, node): self.body.append(' </tbody> \\n </table> \\n') self.in_docinfo = False start = self.context.pop() self.docinfo = self.body[start:] self.body = [] depart_docinfo_item def depart_docinfo_item ( self ) View Source def depart_docinfo_item(self): self.body.append(' </td></tr> \\n') depart_doctest_block def depart_doctest_block ( self , node ) View Source def depart_doctest_block(self, node): self.body.append('\\n</pre>\\n') depart_document def depart_document ( self , node ) View Source def depart_document ( self , node ) : self . head_prefix . extend ([ self . doctype , self . head_prefix_template % { 'lang': self . settings . language_code }]) self . html_prolog . append ( self . doctype ) self . meta . insert ( 0 , self . content_type % self.settings.output_encoding) self . head . insert ( 0 , self . content_type % self.settings.output_encoding) if 'name=\"dcterms.' in '' . join ( self . meta ) : self . head . append ( '<link rel=\"schema.dcterms\" href=\"http://purl.org/dc/terms/\"/>' ) if self . math_header: if self . math_output == 'mathjax': self . head . extend ( self . math_header ) else : self . stylesheet . extend ( self . math_header ) # skip content - type meta tag with interpolated charset value : self . html_head . extend ( self . head [ 1 : ]) self . body_prefix . append ( self . starttag ( node , 'div' , CLASS ='document' )) self . body_suffix . insert ( 0 , '</div>\\n' ) self . fragment . extend ( self . body ) # self . fragment is the \"naked\" body self . html_body . extend ( self . body_prefix [ 1 : ] + self . body_pre_docinfo + self . docinfo + self . body + self . body_suffix [:- 1 ]) assert not self . context , 'len(context) = %s' % len(self.context) depart_emphasis def depart_emphasis ( self , node ) View Source def depart_emphasis(self, node): self.body.append('</em>') depart_entry def depart_entry ( self , node ) View Source def depart_entry(self, node): self.body.append(self.context.pop()) depart_enumerated_list def depart_enumerated_list ( self , node ) View Source def depart_enumerated_list ( self , node ): self . compact_simple , self . compact_p = self . context . pop () self . body . append ( '</ol> \\n ' ) depart_field def depart_field ( self , node ) View Source def depart_field(self, node): self.body.append('</tr>\\n') depart_field_body def depart_field_body ( self , node ) View Source def depart_field_body(self, node): self.body.append('</td>\\n') depart_field_list def depart_field_list ( self , node ) View Source def depart_field_list(self, node): self.body.append(' </tbody> \\n </table> \\n') self.compact_field_list, self.compact_p = self.context.pop() depart_field_name def depart_field_name ( self , node ) View Source def depart_field_name(self, node): self.body.append(':</th>') self.body.append(self.context.pop()) depart_figure def depart_figure ( self , node ) View Source def depart_figure(self, node): self.body.append('</div>\\n') depart_footer def depart_footer ( self , node ) View Source def depart_footer(self, node): start = self.context.pop() footer = [self.starttag(node, 'div', CLASS='footer'), ' <hr class= \"footer\" /> \\n'] footer.extend(self.body[start:]) footer.append('\\n </div> \\n') self.footer.extend(footer) self.body_suffix[:0] = footer del self.body[start:] depart_footnote def depart_footnote ( self , node ) View Source def depart_footnote(self, node): self.body.append(' </td></tr> \\n' ' </tbody> \\n </table> \\n') depart_footnote_reference def depart_footnote_reference ( self , node ) View Source def depart_footnote_reference(self, node): self.body.append(self.context.pop() + '</a>') depart_generated def depart_generated ( self , node ) View Source def depart_generated(self, node): pass depart_header def depart_header ( self , node ) View Source def depart_header(self, node): start = self.context.pop() header = [self.starttag(node, 'div', CLASS='header')] header.extend(self.body[start:]) header.append('\\n <hr class= \"header\" /> \\n </div> \\n') self.body_prefix.extend(header) self.header.extend(header) del self.body[start:] depart_image def depart_image ( self , node ) View Source def depart_image(self, node): pass depart_inline def depart_inline ( self , node ) View Source def depart_inline(self, node): self.body.append('</span>') depart_label def depart_label ( self , node ) View Source def depart_label(self, node): self.body.append(']%s</td><td>%s' % (self.context.pop(), self.context.pop())) depart_legend def depart_legend ( self , node ) View Source def depart_legend(self, node): self.body.append('</div>\\n') depart_line def depart_line ( self , node ) View Source def depart_line(self, node): self.body.append('</div>\\n') depart_line_block def depart_line_block ( self , node ) View Source def depart_line_block(self, node): self.body.append('</div>\\n') depart_list_item def depart_list_item ( self , node ) View Source def depart_list_item(self, node): self.body.append('</li>\\n') depart_literal def depart_literal ( self , node ) View Source def depart_literal(self, node): # skipped unless literal element is from \"code\" role: self.body.append('</code>') depart_literal_block def depart_literal_block ( self , node ) View Source def depart_literal_block(self, node): self.body.append('\\n</pre>\\n') depart_math def depart_math ( self , node ) View Source def depart_math(self, node): pass # never reached depart_math_block def depart_math_block ( self , node ) View Source def depart_math_block(self, node): pass # never reached depart_meta def depart_meta ( self , node ) View Source def depart_meta(self, node): pass depart_option def depart_option ( self , node ) View Source def depart_option ( self , node ) : self . body . append ( ' </span> ' ) if isinstance ( node . next_node ( descend = False , siblings = True ) , nodes . option ) : self . body . append ( ' , ' ) depart_option_argument def depart_option_argument ( self , node ) View Source def depart_option_argument ( self , node ): self . body . append ( '</var>' ) depart_option_group def depart_option_group ( self , node ) View Source def depart_option_group(self, node): self.context.pop() self.body.append(' </kbd></td> \\n') self.body.append(self.context.pop()) depart_option_list def depart_option_list ( self , node ) View Source def depart_option_list(self, node): self.body.append(' </tbody> \\n </table> \\n') depart_option_list_item def depart_option_list_item ( self , node ) View Source def depart_option_list_item(self, node): self.body.append('</tr>\\n') depart_option_string def depart_option_string ( self , node ) View Source def depart_option_string(self, node): pass depart_organization def depart_organization ( self , node ) View Source def depart_organization(self, node): self.depart_docinfo_item() depart_paragraph def depart_paragraph ( self , node ) View Source def depart_paragraph(self, node): self.body.append(self.context.pop()) depart_problematic def depart_problematic ( self , node ) View Source def depart_problematic(self, node): self.body.append('</span>') self.body.append(self.context.pop()) depart_reference def depart_reference ( self , node ) View Source def depart_reference ( self , node ) : self . body . append ( ' </a> ' ) if not isinstance ( node . parent , nodes . TextElement ) : self . body . append ( ' \\n ' ) self . in_mailto = False depart_revision def depart_revision ( self , node ) View Source def depart_revision(self, node): self.depart_docinfo_item() depart_row def depart_row ( self , node ) View Source def depart_row(self, node): self.body.append('</tr>\\n') depart_rubric def depart_rubric ( self , node ) View Source def depart_rubric(self, node): self.body.append('</p>\\n') depart_section def depart_section ( self , node ) View Source def depart_section(self, node): self.section_level -= 1 self.body.append('</div>\\n') depart_sidebar def depart_sidebar ( self , node ) View Source def depart_sidebar(self, node): self.body.append('</div>\\n') self.in_sidebar = False depart_status def depart_status ( self , node ) View Source def depart_status(self, node): self.depart_docinfo_item() depart_strong def depart_strong ( self , node ) View Source def depart_strong(self, node): self.body.append('</strong>') depart_subscript def depart_subscript ( self , node ) View Source def depart_subscript(self, node): if isinstance(node.parent, nodes.literal_block): self.body.append(' </span> ') else: self.body.append(' </sub> ') depart_subtitle def depart_subtitle ( self , node ) View Source def depart_subtitle ( self , node ) : self . body . append ( self . context . pop ()) if self . in_document_title: self . subtitle = self . body [ self . in_document_title :- 1 ] self . in_document_title = 0 self . body_pre_docinfo . extend ( self . body ) self . html_subtitle . extend ( self . body ) del self . body [ : ] depart_superscript def depart_superscript ( self , node ) View Source def depart_superscript(self, node): if isinstance(node.parent, nodes.literal_block): self.body.append(' </span> ') else: self.body.append(' </sup> ') depart_system_message def depart_system_message ( self , node ) View Source def depart_system_message(self, node): self.body.append('</div>\\n') depart_table def depart_table ( self , node ) View Source def depart_table(self, node): self.compact_p = self.context.pop() self.body.append('</table>\\n') depart_target def depart_target ( self , node ) View Source def depart_target(self, node): self.body.append(self.context.pop()) depart_tbody def depart_tbody ( self , node ) View Source def depart_tbody(self, node): self.body.append('</tbody>\\n') depart_term def depart_term ( self , node ) Leave the end tag to self.visit_definition() , in case there's a classifier. View Source def depart_term ( self , node ) : \"\"\" Leave the end tag to ` self . visit_definition () `, in case there ' s a classifier . \"\"\" pass depart_tgroup def depart_tgroup ( self , node ) View Source def depart_tgroup(self, node): pass depart_thead def depart_thead ( self , node ) View Source def depart_thead(self, node): self.body.append('</thead>\\n') depart_title def depart_title ( self , node ) View Source def depart_title ( self , node ) : self . body . append ( self . context . pop ()) if self . in_document_title: self . title = self . body [ self . in_document_title :- 1 ] self . in_document_title = 0 self . body_pre_docinfo . extend ( self . body ) self . html_title . extend ( self . body ) del self . body [ : ] depart_title_reference def depart_title_reference ( self , node ) View Source def depart_title_reference(self, node): self.body.append('</cite>') depart_topic def depart_topic ( self , node ) View Source def depart_topic(self, node): self.body.append('</div>\\n') self.topic_classes = [] depart_transition def depart_transition ( self , node ) View Source def depart_transition(self, node): pass depart_version def depart_version ( self , node ) View Source def depart_version(self, node): self.depart_docinfo_item() dispatch_departure def dispatch_departure ( self , node ) Call self.\" depart_ + node class name\" with node as parameter. If the depart_... method does not exist, call self.unknown_departure. View Source def dispatch_departure ( self , node ) : \" \"\" Call self.\" `` depart_ `` + node class name \" with `node` as parameter. If the ``depart_...`` method does not exist, call self.unknown_departure. \"\" \" node_name = node . __class__ . __name__ method = getattr ( self , 'depart_' + node_name , self . unknown_departure ) self . document . reporter . debug ( 'docutils.nodes.NodeVisitor.dispatch_departure calling %s for %s' % ( method . __name__ , node_name )) return method ( node ) dispatch_visit def dispatch_visit ( self , node ) Call self.\" visit_ + node class name\" with node as parameter. If the visit_... method does not exist, call self.unknown_visit. View Source def dispatch_visit ( self , node ) : \" \"\" Call self.\" `` visit_ `` + node class name \" with `node` as parameter. If the ``visit_...`` method does not exist, call self.unknown_visit. \"\" \" node_name = node . __class__ . __name__ method = getattr ( self , 'visit_' + node_name , self . unknown_visit ) self . document . reporter . debug ( 'docutils.nodes.NodeVisitor.dispatch_visit calling %s for %s' % ( method . __name__ , node_name )) return method ( node ) emptytag def emptytag ( self , node , tagname , suffix = ' \\n ' , ** attributes ) Construct and return an XML-compatible empty tag. View Source def emptytag ( self , node , tagname , suffix = ' \\n ' , ** attributes ) : \"\"\" Construct and return an XML-compatible empty tag. \"\"\" return self . starttag ( node , tagname , suffix , empty = True , ** attributes ) encode def encode ( self , text ) Encode special characters in text & return. View Source def encode ( self , text ) : \" \"\" Encode special characters in `text` & return. \"\" \" # Use only named entities known in both XML and HTML # other characters are automatically encoded \"by number\" if required. # @@@ A codec to do these and all other HTML entities would be nice. text = unicode ( text ) return text . translate ( self . special_characters ) footnote_backrefs def footnote_backrefs ( self , node ) View Source def footnote_backrefs(self, node): backlinks = [] backrefs = node['backrefs'] if self.settings.footnote_backlinks and backrefs: if len(backrefs) == 1: self.context.append('') self.context.append(' </a> ') self.context.append(' <a class= \"fn-backref\" href= \"#%s\" > ' % backrefs[0]) else: for (i, backref) in enumerate(backrefs, 1): backlinks.append(' <a class= \"fn-backref\" href= \"#%s\" > %s </a> ' % (backref, i)) self.context.append(' <em> (%s) </em> ' % ', '.join(backlinks)) self.context += ['', ''] else: self.context.append('') self.context += ['', ''] # If the node does not only consist of a label. if len(node) > 1: # If there are preceding backlinks, we do not set class # 'first', because we need to retain the top-margin. if not backlinks: node[1]['classes'].append('first') node[-1]['classes'].append('last') is_compactable def is_compactable ( self , node ) View Source def is_compactable ( self , node ) : return ( ' compact ' in node [ ' classes ' ] or ( self . settings . compact_lists and ' open ' not in node [ ' classes ' ] and ( self . compact_simple or self . topic_classes == [ ' contents ' ] # TODO : self . in_contents or self . check_simple_list ( node )))) set_class_on_child def set_class_on_child ( self , node , class_ , index = 0 ) Set class class_ on the visible child no. index of node . Do nothing if node has fewer children than index . View Source def set _class_on_child ( self , node , class_ , index = 0 ) : \" \"\" Set class `class_` on the visible child no. index of `node`. Do nothing if node has fewer children than `index`. \"\" \" children = [ n for n in node if not isinstance ( n , nodes . Invisible ) ] try : child = children [ index ] except IndexError : return child [ 'classes' ] . append ( class_ ) set_first_last def set_first_last ( self , node ) View Source def set_first_last(self, node): self.set_class_on_child(node, 'first', 0) self.set_class_on_child(node, 'last', -1) should_be_compact_paragraph def should_be_compact_paragraph ( self , node ) Determine if the tags around paragraph node can be omitted. View Source def should_be_compact_paragraph ( self , node ) : \" \"\" Determine if the <p> tags around paragraph ``node`` can be omitted. \"\" \" if ( isinstance ( node . parent , nodes . document ) or isinstance ( node . parent , nodes . compound )) : # Never compact paragraphs in document or compound. return False for key , value in node . attlist () : if ( node . is_not_default ( key ) and not ( key == 'classes' and value in ( [] , [ 'first' ] , [ 'last' ] , [ 'first' , 'last' ] ))) : # Attribute which needs to survive. return False first = isinstance ( node . parent [ 0 ] , nodes . label ) # skip label for child in node . parent . children [ first : ] : # only first paragraph can be compact if isinstance ( child , nodes . Invisible ) : continue if child is node : break return False parent_length = len ( [ n for n in node . parent if not isinstance ( n , ( nodes . Invisible , nodes . label )) ] ) if ( self . compact_simple or self . compact_field_list or self . compact_p and parent_length == 1 ) : return True return False starttag def starttag ( self , node , tagname , suffix = ' \\n ' , empty = False , ** attributes ) Construct and return a start tag given a node (id & class attributes are extracted), tag name, and optional attributes. View Source def starttag ( self , node , tagname , suffix = '\\n' , empty = False , ** attributes ) : \"\"\" Construct and return a start tag given a node (id & class attributes are extracted), tag name, and optional attributes. \"\"\" tagname = tagname . lower () prefix = [] atts = {} ids = [] for ( name , value ) in attributes . items () : atts [ name.lower() ] = value classes = [] languages = [] # unify class arguments and move language specification for cls in node . get ( 'classes' , [] ) + atts . pop ( 'class' , '' ). split () : if cls . startswith ( 'language-' ) : languages . append ( cls [ 9: ] ) elif cls . strip () and cls not in classes : classes . append ( cls ) if languages : # attribute name is 'lang' in XHTML 1.0 but 'xml:lang' in 1.1 atts [ self.lang_attribute ] = languages [ 0 ] if classes : atts [ 'class' ] = ' ' . join ( classes ) assert 'id' not in atts ids . extend ( node . get ( 'ids' , [] )) if 'ids' in atts : ids . extend ( atts [ 'ids' ] ) del atts [ 'ids' ] if ids : atts [ 'id' ] = ids [ 0 ] for id in ids [ 1: ] : # Add empty \"span\" elements for additional IDs . Note # that we cannot use empty \"a\" elements because there # may be targets inside of references , but nested \"a\" # elements aren 't allowed in XHTML (even if they do # not all have a \"href\" attribute). if empty or isinstance(node, (nodes.bullet_list, nodes.docinfo, nodes.definition_list, nodes.enumerated_list, nodes.field_list, nodes.option_list, nodes.table)): # Insert target right in front of element. prefix.append(' < span id = \"%s\" ></ span > ' % id) else: # Non-empty tag. Place the auxiliary <span> tag # *inside* the element, as the first child. suffix += ' < span id = \"%s\" ></ span > ' % id attlist = sorted(atts.items()) parts = [tagname] for name, value in attlist: # value=None was used for boolean attributes without # value, but this isn' t supported by XHTML . assert value is not None if isinstance ( value , list ) : values = [ unicode(v) for v in value ] parts . append ( '%s=\"%s\"' % ( name . lower (), self . attval ( ' ' . join ( values )))) else : parts . append ( '%s=\"%s\"' % ( name . lower (), self . attval ( unicode ( value )))) if empty : infix = ' /' else : infix = '' return '' . join ( prefix ) + '<%s%s>' % ( ' ' . join ( parts ), infix ) + suffix stylesheet_call def stylesheet_call ( self , path ) Return code to reference or embed stylesheet file path View Source def stylesheet_call ( self , path ) : \" \"\" Return code to reference or embed stylesheet file `path` \"\" \" if self . set tings . embed_stylesheet : try : content = io . FileInput ( source_path = path , encoding = 'utf-8' ). read () self . set tings . record_dependencies . add ( path ) except IOError as err : msg = u \"Cannot embed stylesheet '%r': %s.\" % ( path , SafeString ( err . strerror )) self . document . reporter . error ( msg ) return '<--- %s ---> \\n ' % msg return self . embedded_stylesheet % content # else link to style file: if self . set tings . stylesheet_path : # adapt path relative to output (cf. config.html#stylesheet-path) path = utils . relative_path ( self . set tings . _destination , path ) return self . stylesheet_link % self . encode ( path ) unimplemented_visit def unimplemented_visit ( self , node ) View Source def unimplemented_visit(self, node): raise NotImplementedError ( 'visiting unimplemented node type: %s' % node.__class__.__name__) unknown_departure def unknown_departure ( self , node ) Called before exiting unknown Node types. Raise exception unless overridden. View Source def unknown_departure ( self , node ) : \" \"\" Called before exiting unknown `Node` types. Raise exception unless overridden. \"\" \" if ( self . document . set tings . strict_visitor or node . __class__ . __name__ not in self . optional ) : raise NotImplementedError ( '%s departing unknown node type: %s' % ( self . __class__ , node . __class__ . __name__ )) unknown_visit def unknown_visit ( self , node ) Called when entering unknown Node types. Raise an exception unless overridden. View Source def unknown_visit ( self , node ) : \" \"\" Called when entering unknown `Node` types. Raise an exception unless overridden. \"\" \" if ( self . document . set tings . strict_visitor or node . __class__ . __name__ not in self . optional ) : raise NotImplementedError ( '%s visiting unknown node type: %s' % ( self . __class__ , node . __class__ . __name__ )) visit_Text def visit_Text ( self , node ) View Source def visit_Text ( self , node ) : text = node . astext () encoded = self . encode ( text ) if self . in_mailto and self . settings . cloak_email_addresses : encoded = self . cloak_email ( encoded ) self . body . append ( encoded ) visit_abbreviation def visit_abbreviation ( self , node ) View Source def visit_abbreviation(self, node): # @@@ implementation incomplete (\"title\" attribute) self.body.append(self.starttag(node, 'abbr', '')) visit_acronym def visit_acronym ( self , node ) View Source def visit_acronym(self, node): # @@@ implementation incomplete (\"title\" attribute) self.body.append(self.starttag(node, 'acronym', '')) visit_address def visit_address ( self , node ) View Source def visit_address(self, node): self.visit_docinfo_item(node, 'address', meta=False) self.body.append(self.starttag(node, 'pre', CLASS='address')) visit_admonition def visit_admonition ( self , node ) View Source def visit_admonition(self, node): node['classes'].insert(0, 'admonition') self.body.append(self.starttag(node, 'div')) self.set_first_last(node) visit_attribution def visit_attribution ( self , node ) View Source def visit_attribution(self, node): prefix, suffix = self.attribution_formats[self.settings.attribution] self.context.append(suffix) self.body.append( self.starttag(node, 'p', prefix, CLASS='attribution')) visit_author def visit_author ( self , node ) View Source def visit_author ( self , node ) : if isinstance ( node . parent , nodes . authors ) : if self . author_in_authors : self . body . append ( ' \\n <br /> ' ) else : self . visit_docinfo_item ( node , ' author ' ) visit_authors def visit_authors ( self , node ) View Source def visit_authors(self, node): self.visit_docinfo_item(node, 'authors') self.author_in_authors = False # initialize visit_block_quote def visit_block_quote ( self , node ) View Source def visit_block_quote(self, node): self.body.append(self.starttag(node, 'blockquote')) visit_bullet_list def visit_bullet_list ( self , node ) View Source def visit_bullet_list ( self , node ) : atts = {} old_compact_simple = self . compact_simple self . context . append (( self . compact_simple , self . compact_p )) self . compact_p = None self . compact_simple = self . is_compactable ( node ) if self . compact_simple and not old_compact_simple : atts [ ' class ' ] = ' simple ' self . body . append ( self . starttag ( node , ' ul ' , ** atts )) visit_caption def visit_caption ( self , node ) View Source def visit_caption(self, node): self.body.append(self.starttag(node, 'p', '', CLASS='caption')) visit_citation def visit_citation ( self , node ) View Source def visit_citation(self, node): self.body.append(self.starttag(node, 'table', CLASS='docutils citation', frame=\"void\", rules=\"none\")) self.body.append(' <colgroup><col class= \"label\" /><col /></colgroup> \\n' ' <tbody valign= \"top\" > \\n' ' <tr> ') self.footnote_backrefs(node) visit_citation_reference def visit_citation_reference ( self , node ) View Source def visit_citation_reference ( self , node ) : href = ' # ' if ' refid ' in node : href += node [ ' refid ' ] elif ' refname ' in node : href += self . document . nameids [ node [ ' refname ' ]] # else : # TODO system message ( or already in the transform ) ? # ' Citation reference missing. ' self . body . append ( self . starttag ( node , ' a ' , ' [ ' , CLASS = ' citation-reference ' , href = href )) visit_classifier def visit_classifier ( self , node ) View Source def visit_classifier(self, node): self.body.append(' <span class= \"classifier-delimiter\" > : </span> ') self.body.append(self.starttag(node, 'span', '', CLASS='classifier')) visit_colspec def visit_colspec ( self , node ) View Source def visit_colspec(self, node): self.colspecs.append(node) # \"stubs\" list is an attribute of the tgroup element: node.parent.stubs.append(node.attributes.get('stub')) visit_comment def visit_comment ( self , node , sub =< built - in method sub of re . Pattern object at 0x0000024728A33500 > ) Escape double-dashes in comment text. View Source def visit_comment ( self , node , sub = re . compile ( '-(?=-)' ). sub ) : \"\"\"Escape double-dashes in comment text.\"\"\" self . body . append ( '<!-- %s -->\\n' % sub ( '- ' , node . astext ())) # Content already processed : raise nodes . SkipNode visit_compound def visit_compound ( self , node ) View Source def visit_compound ( self , node ) : self . body . append ( self . starttag ( node , 'div' , CLASS ='compound' )) if len ( node ) > 1 : node [ 0 ][ 'classes' ]. append ( 'compound-first' ) node [ - 1 ][ 'classes' ]. append ( 'compound-last' ) for child in node [ 1 :- 1 ] : child [ 'classes' ]. append ( 'compound-middle' ) visit_contact def visit_contact ( self , node ) View Source def visit_contact(self, node): self.visit_docinfo_item(node, 'contact', meta=False) visit_container def visit_container ( self , node ) View Source def visit_container(self, node): self.body.append(self.starttag(node, 'div', CLASS='docutils container')) visit_copyright def visit_copyright ( self , node ) View Source def visit_copyright(self, node): self.visit_docinfo_item(node, 'copyright') visit_date def visit_date ( self , node ) View Source def visit_date(self, node): self.visit_docinfo_item(node, 'date') visit_decoration def visit_decoration ( self , node ) View Source def visit_decoration(self, node): pass visit_definition def visit_definition ( self , node ) View Source def visit_definition(self, node): self.body.append('</dt>\\n') self.body.append(self.starttag(node, 'dd', '')) self.set_first_last(node) visit_definition_list def visit_definition_list ( self , node ) View Source def visit_definition_list(self, node): self.body.append(self.starttag(node, 'dl', CLASS='docutils')) visit_definition_list_item def visit_definition_list_item ( self , node ) View Source def visit_definition_list_item(self, node): # pass class arguments, ids and names to definition term: node.children[0]['classes'] = ( node.get('classes', []) + node.children[0].get('classes', [])) node.children[0]['ids'] = ( node.get('ids', []) + node.children[0].get('ids', [])) node.children[0]['names'] = ( node.get('names', []) + node.children[0].get('names', [])) visit_description def visit_description ( self , node ) View Source def visit_description(self, node): self.body.append(self.starttag(node, 'td', '')) self.set_first_last(node) visit_docinfo def visit_docinfo ( self , node ) View Source def visit_docinfo(self, node): self.context.append(len(self.body)) self.body.append(self.starttag(node, 'table', CLASS='docinfo', frame=\"void\", rules=\"none\")) self.body.append('<col class=\"docinfo-name\" />\\n' '<col class=\"docinfo-content\" />\\n' '<tbody valign=\"top\">\\n') self.in_docinfo = True visit_docinfo_item def visit_docinfo_item ( self , node , name , meta = True ) View Source def visit_docinfo_item ( self , node , name , meta = True ) : if meta : meta_tag = '<meta name=\"%s\" content=\"%s\" />\\n' \\ % ( name , self . attval ( node . astext ())) self . add_meta ( meta_tag ) self . body . append ( self . starttag ( node , 'tr' , '' )) self . body . append ( '<th class=\"docinfo-name\">%s:</th>\\n<td>' % self . language . labels [ name ] ) if len ( node ) : if isinstance ( node [ 0 ] , nodes . Element ) : node [ 0 ][ 'classes' ] . append ( 'first' ) if isinstance ( node [ -1 ] , nodes . Element ) : node [ -1 ][ 'classes' ] . append ( 'last' ) visit_doctest_block def visit_doctest_block ( self , node ) View Source def visit_doctest_block(self, node): self.body.append(self.starttag(node, 'pre', CLASS='doctest-block')) visit_document def visit_document ( self , node ) View Source def visit_document(self, node): title = (node.get('title', '') or os.path.basename(node['source']) or 'docutils document without title') self.head.append(' <title> %s </title> \\n' % self.encode(title)) visit_emphasis def visit_emphasis ( self , node ) View Source def visit_emphasis(self, node): self.body.append(self.starttag(node, 'em', '')) visit_entry def visit_entry ( self , node ) View Source def visit_entry ( self , node ): writers . _html_base . HTMLTranslator . visit_entry ( self , node ) if len ( node ) == 0 : # empty cell self . body . append ( '&nbsp;' ) self . set_first_last ( node ) visit_enumerated_list def visit_enumerated_list ( self , node ) The 'start' attribute does not conform to HTML 4.01's strict.dtd, but cannot be emulated in CSS1 (HTML 5 reincludes it). View Source def visit_enumerated_list ( self , node ): \"\"\" The 'start' attribute does not conform to HTML 4.01's strict.dtd, but cannot be emulated in CSS1 (HTML 5 reincludes it). \"\"\" atts = {} if 'start' in node : atts [ 'start' ] = node [ 'start' ] if 'enumtype' in node : atts [ 'class' ] = node [ 'enumtype' ] # @@@ To do: prefix, suffix. How? Change prefix/suffix to a # single \"format\" attribute? Use CSS2? old_compact_simple = self . compact_simple self . context . append (( self . compact_simple , self . compact_p )) self . compact_p = None self . compact_simple = self . is_compactable ( node ) if self . compact_simple and not old_compact_simple : atts [ 'class' ] = ( atts . get ( 'class' , '' ) + ' simple' ) . strip () self . body . append ( self . starttag ( node , 'ol' , ** atts )) visit_field def visit_field ( self , node ) View Source def visit_field(self, node): self.body.append(self.starttag(node, 'tr', '', CLASS='field')) visit_field_body def visit_field_body ( self , node ) View Source def visit_field_body ( self , node ) : self . body . append ( self . starttag ( node , ' td ' , '' , CLASS = ' field-body ' )) self . set_class_on_child ( node , ' first ' , 0 ) field = node . parent if ( self . compact_field_list or isinstance ( field . parent , nodes . docinfo ) or field . parent . index ( field ) == len ( field . parent ) - 1 ) : # If we are in a compact list , the docinfo , or if this is # the last field of the field list , do not add vertical # space after last element . self . set_class_on_child ( node , ' last ' , - 1 ) visit_field_list def visit_field_list ( self , node ) View Source def visit_field_list ( self , node ) : self . context . append (( self . compact_field_list , self . compact_p )) self . compact_p = None if ' compact ' in node [ ' classes ' ]: self . compact_field_list = True elif ( self . settings . compact_field_lists and ' open ' not in node [ ' classes ' ] ) : self . compact_field_list = True if self . compact_field_list : for field in node : field_body = field [ - 1 ] assert isinstance ( field_body , nodes . field_body ) children = [ n for n in field_body if not isinstance ( n , nodes . Invisible ) ] if not ( len ( children ) == 0 or len ( children ) == 1 and isinstance ( children [ 0 ], ( nodes . paragraph , nodes . line_block ))) : self . compact_field_list = False break self . body . append ( self . starttag ( node , ' table ' , frame = ' void ' , rules = ' none ' , CLASS = ' docutils field-list ' )) self . body . append ( ' <col class=\"field-name\" /> \\n ' ' <col class=\"field-body\" /> \\n ' ' <tbody valign=\"top\"> \\n ' ) visit_field_name def visit_field_name ( self , node ) View Source def visit_field_name(self, node): atts = {} if self.in_docinfo: atts['class'] = 'docinfo-name' else: atts['class'] = 'field-name' if ( self.settings.field_name_limit and len(node.astext()) > self.settings.field_name_limit): atts['colspan'] = 2 self.context.append(' </tr> \\n' + self.starttag(node.parent, 'tr', '', CLASS='field') + ' <td> &nbsp; </td> ') else: self.context.append('') self.body.append(self.starttag(node, 'th', '', **atts)) visit_figure def visit_figure ( self , node ) View Source def visit_figure ( self , node ) : atts = { ' class ' : ' figure ' } if node . get ( ' width ' ) : atts [ ' style ' ] = ' width: %s ' % node [ ' width ' ] if node . get ( ' align ' ) : atts [ ' class ' ] += \" align- \" + node [ ' align ' ] self . body . append ( self . starttag ( node , ' div ' , ** atts )) visit_footer def visit_footer ( self , node ) View Source def visit_footer(self, node): self.context.append(len(self.body)) visit_footnote def visit_footnote ( self , node ) View Source def visit_footnote(self, node): self.body.append(self.starttag(node, 'table', CLASS='docutils footnote', frame=\"void\", rules=\"none\")) self.body.append(' <colgroup><col class= \"label\" /><col /></colgroup> \\n' ' <tbody valign= \"top\" > \\n' ' <tr> ') self.footnote_backrefs(node) visit_footnote_reference def visit_footnote_reference ( self , node ) View Source def visit_footnote_reference(self, node): href = '#' + node['refid'] format = self.settings.footnote_references if format == 'brackets': suffix = '[' self.context.append(']') else: assert format == 'superscript' suffix = ' <sup> ' self.context.append(' </sup> ') self.body.append(self.starttag(node, 'a', suffix, CLASS='footnote-reference', href=href)) visit_generated def visit_generated ( self , node ) View Source def visit_generated(self, node): pass visit_header def visit_header ( self , node ) View Source def visit_header(self, node): self.context.append(len(self.body)) visit_image def visit_image ( self , node ) View Source def visit_image ( self , node ) : atts = {} uri = node [ 'uri' ] ext = os . path . splitext ( uri ) [ 1 ] . lower () if ext in self . object_image_types : atts [ 'data' ] = uri atts [ 'type' ] = self . object_image_types [ ext ] else : atts [ 'src' ] = uri atts [ 'alt' ] = node . get ( 'alt' , uri ) # image size if 'width' in node : atts [ 'width' ] = node [ 'width' ] if 'height' in node : atts [ 'height' ] = node [ 'height' ] if 'scale' in node : if ( PIL and not ( 'width' in node and 'height' in node ) and self . settings . file_insertion_enabled ) : imagepath = url2pathname ( uri ) try : img = PIL . Image . open ( imagepath . encode ( sys . getfilesystemencoding ())) except ( IOError , UnicodeEncodeError ) : pass # TODO : warn ? else : self . settings . record_dependencies . add ( imagepath . replace ( '\\\\' , '/' )) if 'width' not in atts : atts [ 'width' ] = '%dpx' % img . size [ 0 ] if 'height' not in atts : atts [ 'height' ] = '%dpx' % img . size [ 1 ] del img for att_name in 'width' , 'height' : if att_name in atts : match = re . match ( r '([0-9.]+)(\\S*)$' , atts [ att_name ] ) assert match atts [ att_name ] = '%s%s' % ( float ( match . group ( 1 )) * ( float ( node [ 'scale' ] ) / 100 ), match . group ( 2 )) style = [] for att_name in 'width' , 'height' : if att_name in atts : if re . match ( r '^[0-9.]+$' , atts [ att_name ] ) : # Interpret unitless values as pixels . atts [ att_name ] += 'px' style . append ( '%s: %s;' % ( att_name , atts [ att_name ] )) del atts [ att_name ] if style : atts [ 'style' ] = ' ' . join ( style ) if ( isinstance ( node . parent , nodes . TextElement ) or ( isinstance ( node . parent , nodes . reference ) and not isinstance ( node . parent . parent , nodes . TextElement ))) : # Inline context or surrounded by < a > ... </ a > . suffix = '' else : suffix = '\\n' if 'align' in node : atts [ 'class' ] = 'align-%s' % node [ 'align' ] if ext in self . object_image_types : # do NOT use an empty tag : incorrect rendering in browsers self . body . append ( self . starttag ( node , 'object' , '' , ** atts ) + node . get ( 'alt' , uri ) + '</object>' + suffix ) else : self . body . append ( self . emptytag ( node , 'img' , suffix , ** atts )) visit_inline def visit_inline ( self , node ) View Source def visit_inline(self, node): self.body.append(self.starttag(node, 'span', '')) visit_label def visit_label ( self , node ) View Source def visit_label(self, node): self.body.append(self.starttag(node, 'td', '%s[' % self.context.pop(), CLASS='label')) visit_legend def visit_legend ( self , node ) View Source def visit_legend(self, node): self.body.append(self.starttag(node, 'div', CLASS='legend')) visit_line def visit_line ( self , node ) View Source def visit_line ( self , node ) : self . body . append ( self . starttag ( node , ' div ' , suffix = '' , CLASS = ' line ' )) if not len ( node ) : self . body . append ( ' <br /> ' ) visit_line_block def visit_line_block ( self , node ) View Source def visit_line_block(self, node): self.body.append(self.starttag(node, 'div', CLASS='line-block')) visit_list_item def visit_list_item ( self , node ) View Source def visit_list_item ( self , node ) : self . body . append ( self . starttag ( node , ' li ' , '' )) if len ( node ) : node [ 0 ][ ' classes ' ]. append ( ' first ' ) visit_literal def visit_literal ( self , node ) View Source def visit_literal(self, node): # special case: \"code\" role classes = node.get('classes', []) if 'code' in classes: # filter 'code' from class arguments node['classes'] = [cls for cls in classes if cls != 'code'] self.body.append(self.starttag(node, 'code', '')) return self.body.append( self.starttag(node, 'tt', '', CLASS='docutils literal')) text = node.astext() for token in self.words_and_spaces.findall(text): if token.strip(): # Protect text like \"--an-option\" and the regular expression # ``[+]?(\\d+(\\.\\d*)?|\\.\\d+)`` from bad line wrapping if self.in_word_wrap_point.search(token): self.body.append(' <span class= \"pre\" > %s </span> ' % self.encode(token)) else: self.body.append(self.encode(token)) elif token in ('\\n', ' '): # Allow breaks at whitespace: self.body.append(token) else: # Protect runs of multiple spaces; the last space can wrap: self.body.append(' &nbsp; ' * (len(token) - 1) + ' ') self.body.append(' </tt> ') # Content already processed: raise nodes.SkipNode visit_literal_block def visit_literal_block ( self , node ) View Source def visit_literal_block(self, node): self.body.append(self.starttag(node, 'pre', CLASS='literal-block')) visit_math def visit_math ( self , node , math_env = '' ) View Source def visit_math ( self , node , math_env = '' ) : # If the method is called from visit_math_block (), math_env != '' . if self . math_output not in self . math_tags : self . document . reporter . error ( 'math-output format \" % s \" not supported ' 'falling back to \" latex \"' % self . math_output ) self . math_output = 'latex' tag = self . math_tags [ self . math_output ][ math_env == '' ] clsarg = self . math_tags [ self . math_output ][ 2 ] # LaTeX container wrappers = { # math_mode : ( inline , block ) 'mathml' : ( '$%s$' , u '\\\\begin{%s}\\n%s\\n\\\\end{%s}' ), 'html' : ( '$%s$' , u '\\\\begin{%s}\\n%s\\n\\\\end{%s}' ), 'mathjax' : ( r '\\(%s\\)' , u '\\\\begin{%s}\\n%s\\n\\\\end{%s}' ), 'latex' : ( None , None ), } wrapper = wrappers [ self . math_output ][ math_env != '' ] if self . math_output == 'mathml' and ( not self . math_output_options or self . math_output_options [ 0 ] == 'blahtexml' ) : wrapper = None # get and wrap content math_code = node . astext (). translate ( unichar2tex . uni2tex_table ) if wrapper : try : # wrapper with three \"%s\" math_code = wrapper % ( math_env , math_code , math_env ) except TypeError : # wrapper with one \"%s\" math_code = wrapper % math_code # settings and conversion if self . math_output in ( 'latex' , 'mathjax' ) : math_code = self . encode ( math_code ) if self . math_output == 'mathjax' and not self . math_header : try : self . mathjax_url = self . math_output_options [ 0 ] except IndexError : self . document . reporter . warning ( 'No MathJax URL specified, ' 'using local fallback (see config.html)' ) # append configuration , if not already present in the URL : # input LaTeX with AMS , output common HTML if '?' not in self . mathjax_url : self . mathjax_url += '?config=TeX-AMS_CHTML' self . math_header = [ self . mathjax_script % self . mathjax_url ] elif self . math_output == 'html' : if self . math_output_options and not self . math_header : self . math_header = [ self . stylesheet_call ( utils . find_file_in_dirs ( s , self . settings . stylesheet_dirs )) for s in self . math_output_options [ 0 ]. split ( ',' )] # TODO : fix display mode in matrices and fractions math2html . DocumentParameters . displaymode = ( math_env != '' ) math_code = math2html . math2html ( math_code ) elif self . math_output == 'mathml' : if 'XHTML 1' in self . doctype : self . doctype = self . doctype_mathml self . content_type = self . content_type_mathml converter = ' ' . join ( self . math_output_options ). lower () try : if converter == 'latexml' : math_code = tex2mathml_extern . latexml ( math_code , self . document . reporter ) elif converter == 'ttm' : math_code = tex2mathml_extern . ttm ( math_code , self . document . reporter ) elif converter == 'blahtexml' : math_code = tex2mathml_extern . blahtexml ( math_code , inline = not ( math_env ), reporter = self . document . reporter ) elif not converter : math_code = latex2mathml . tex2mathml ( math_code , inline = not ( math_env )) else : self . document . reporter . error ( 'option \" % s \" not supported ' 'with math-output \" MathML \"' ) except OSError : raise OSError ( 'is \" latexmlmath \" in your PATH?' ) except SyntaxError as err : err_node = self . document . reporter . error ( err , base_node = node ) self . visit_system_message ( err_node ) self . body . append ( self . starttag ( node , 'p' )) self . body . append ( u ',' . join ( err . args )) self . body . append ( '</p>\\n' ) self . body . append ( self . starttag ( node , 'pre' , CLASS = 'literal-block' )) self . body . append ( self . encode ( math_code )) self . body . append ( '\\n</pre>\\n' ) self . depart_system_message ( err_node ) raise nodes . SkipNode # append to document body if tag : self . body . append ( self . starttag ( node , tag , suffix = '\\n' * bool ( math_env ), CLASS = clsarg )) self . body . append ( math_code ) if math_env : # block mode ( equation , display ) self . body . append ( '\\n' ) if tag : self . body . append ( '<!--%s-->' % tag ) if math_env : self . body . append ( '\\n' ) # Content already processed : raise nodes . SkipNode visit_math_block def visit_math_block ( self , node ) View Source def visit_math_block(self, node): math_env = pick_math_environment(node.astext()) self.visit_math(node, math_env=math_env) visit_meta def visit_meta ( self , node ) View Source def visit_meta(self, node): meta = self.emptytag(node, 'meta', **node.non_default_attributes()) self.add_meta(meta) visit_option def visit_option ( self , node ) View Source def visit_option(self, node): self.body.append(self.starttag(node, 'span', '', CLASS='option')) visit_option_argument def visit_option_argument ( self , node ) View Source def visit_option_argument ( self , node ): self . body . append ( node . get ( 'delimiter' , ' ' )) self . body . append ( self . starttag ( node , 'var' , '' )) visit_option_group def visit_option_group ( self , node ) View Source def visit_option_group(self, node): atts = {} if ( self.settings.option_limit and len(node.astext()) > self.settings.option_limit): atts['colspan'] = 2 self.context.append(' </tr> \\n <tr><td> &nbsp; </td> ') else: self.context.append('') self.body.append( self.starttag(node, 'td', CLASS='option-group', **atts)) self.body.append(' <kbd> ') self.context.append(0) # count number of options visit_option_list def visit_option_list ( self , node ) View Source def visit_option_list(self, node): self.body.append( self.starttag(node, 'table', CLASS='docutils option-list', frame=\"void\", rules=\"none\")) self.body.append('<col class=\"option\" />\\n' '<col class=\"description\" />\\n' '<tbody valign=\"top\">\\n') visit_option_list_item def visit_option_list_item ( self , node ) View Source def visit_option_list_item(self, node): self.body.append(self.starttag(node, 'tr', '')) visit_option_string def visit_option_string ( self , node ) View Source def visit_option_string(self, node): pass visit_organization def visit_organization ( self , node ) View Source def visit_organization(self, node): self.visit_docinfo_item(node, 'organization') visit_paragraph def visit_paragraph ( self , node ) View Source def visit_paragraph ( self , node ) : if self . should_be_compact_paragraph ( node ) : self . context . append ( '' ) else : self . body . append ( self . starttag ( node , ' p ' , '' )) self . context . append ( ' </p> \\n ' ) visit_problematic def visit_problematic ( self , node ) View Source def visit_problematic(self, node): if node.hasattr('refid'): self.body.append(' <a href= \"#%s\" > ' % node['refid']) self.context.append(' </a> ') else: self.context.append('') self.body.append(self.starttag(node, 'span', '', CLASS='problematic')) visit_raw def visit_raw ( self , node ) View Source def visit_raw ( self , node ) : if 'html' in node . get ( 'format' , '' ). split () : t = isinstance ( node . parent , nodes . TextElement ) and 'span' or 'div' if node [ 'classes' ] : self . body . append ( self . starttag ( node , t , suffix = '' )) self . body . append ( node . astext ()) if node [ 'classes' ] : self . body . append ( '<!--%s-->' % t ) # Keep non - HTML raw text out of output : raise nodes . SkipNode visit_reference def visit_reference ( self , node ) View Source def visit_reference ( self , node ) : atts = { ' class ' : ' reference ' } if ' refuri ' in node : atts [ ' href ' ] = node [ ' refuri ' ] if ( self . settings . cloak_email_addresses and atts [ ' href ' ]. startswith ( ' mailto: ' )) : atts [ ' href ' ] = self . cloak_mailto ( atts [ ' href ' ] ) self . in_mailto = True atts [ ' class ' ] += ' external ' else : assert ' refid ' in node , \\ ' References must have \"refuri\" or \"refid\" attribute. ' atts [ ' href ' ] = ' # ' + node [ ' refid ' ] atts [ ' class ' ] += ' internal ' if len ( node ) == 1 and isinstance ( node [ 0 ], nodes . image ) : atts [ ' class ' ] += ' image-reference ' if not isinstance ( node . parent , nodes . TextElement ) : assert len ( node ) == 1 and isinstance ( node [ 0 ], nodes . image ) atts [ ' class ' ] += ' image-reference ' self . body . append ( self . starttag ( node , ' a ' , '' , ** atts )) visit_revision def visit_revision ( self , node ) View Source def visit_revision(self, node): self.visit_docinfo_item(node, 'revision', meta=False) visit_row def visit_row ( self , node ) View Source def visit_row(self, node): self.body.append(self.starttag(node, 'tr', '')) node.column = 0 visit_rubric def visit_rubric ( self , node ) View Source def visit_rubric(self, node): self.body.append(self.starttag(node, 'p', '', CLASS='rubric')) visit_section def visit_section ( self , node ) View Source def visit_section(self, node): self.section_level += 1 self.body.append( self.starttag(node, 'div', CLASS='section')) visit_sidebar def visit_sidebar ( self , node ) View Source def visit_sidebar(self, node): self.body.append( self.starttag(node, 'div', CLASS='sidebar')) self.set_first_last(node) self.in_sidebar = True visit_status def visit_status ( self , node ) View Source def visit_status(self, node): self.visit_docinfo_item(node, 'status', meta=False) visit_strong def visit_strong ( self , node ) View Source def visit_strong(self, node): self.body.append(self.starttag(node, 'strong', '')) visit_subscript def visit_subscript ( self , node ) View Source def visit_subscript ( self , node ) : if isinstance ( node . parent , nodes . literal_block ) : self . body . append ( self . starttag ( node , ' span ' , '' , CLASS = ' subscript ' )) else : self . body . append ( self . starttag ( node , ' sub ' , '' )) visit_substitution_definition def visit_substitution_definition ( self , node ) Internal only. View Source def visit_substitution_definition(self, node): \"\"\"Internal only.\"\"\" raise nodes.SkipNode visit_substitution_reference def visit_substitution_reference ( self , node ) View Source def visit_substitution_reference(self, node): self.unimplemented_visit(node) visit_subtitle def visit_subtitle ( self , node ) View Source def visit_subtitle(self, node): if isinstance(node.parent, nodes.sidebar): self.body.append(self.starttag(node, 'p', '', CLASS='sidebar-subtitle')) self.context.append(' </p> \\n') elif isinstance(node.parent, nodes.document): self.body.append(self.starttag(node, 'h2', '', CLASS='subtitle')) self.context.append(' </h2> \\n') self.in_document_title = len(self.body) elif isinstance(node.parent, nodes.section): tag = 'h%s' % (self.section_level + self.initial_header_level - 1) self.body.append( self.starttag(node, tag, '', CLASS='section-subtitle') + self.starttag({}, 'span', '', CLASS='section-subtitle')) self.context.append(' </span> <!--%s--> \\n' % tag) visit_superscript def visit_superscript ( self , node ) View Source def visit_superscript ( self , node ) : if isinstance ( node . parent , nodes . literal_block ) : self . body . append ( self . starttag ( node , ' span ' , '' , CLASS = ' superscript ' )) else : self . body . append ( self . starttag ( node , ' sup ' , '' )) visit_system_message def visit_system_message ( self , node ) View Source def visit_system_message(self, node): self.body.append(self.starttag(node, 'div', CLASS='system-message')) self.body.append(' <p class= \"system-message-title\" > ') backref_text = '' if len(node['backrefs']): backrefs = node['backrefs'] if len(backrefs) == 1: backref_text = ('; <em><a href= \"#%s\" > backlink </a></em> ' % backrefs[0]) else: i = 1 backlinks = [] for backref in backrefs: backlinks.append(' <a href= \"#%s\" > %s </a> ' % (backref, i)) i += 1 backref_text = ('; <em> backlinks: %s </em> ' % ', '.join(backlinks)) if node.hasattr('line'): line = ', line %s' % node['line'] else: line = '' self.body.append('System Message: %s/%s ' '( <tt class= \"docutils\" > %s </tt> %s)%s </p> \\n' % (node['type'], node['level'], self.encode(node['source']), line, backref_text)) visit_table def visit_table ( self , node ) View Source def visit_table ( self , node ) : self . context . append ( self . compact_p ) self . compact_p = True atts = { ' border ' : 1 } classes = [ ' docutils ' , self . settings . table_style ] if ' align ' in node : classes . append ( ' align-%s ' % node [ ' align ' ] ) if ' width ' in node : atts [ ' style ' ] = ' width: %s ' % node [ ' width ' ] self . body . append ( self . starttag ( node , ' table ' , CLASS = ' ' . join ( classes ) , ** atts )) visit_target def visit_target ( self , node ) View Source def visit_target ( self , node ) : if not ( ' refuri ' in node or ' refid ' in node or ' refname ' in node ) : self . body . append ( self . starttag ( node , ' span ' , '' , CLASS = ' target ' )) self . context . append ( ' </span> ' ) else : self . context . append ( '' ) visit_tbody def visit_tbody ( self , node ) View Source def visit_tbody(self, node): self.body.append(self.starttag(node, 'tbody', valign='top')) visit_term def visit_term ( self , node ) View Source def visit_term(self, node): self.body.append(self.starttag(node, 'dt', '')) visit_tgroup def visit_tgroup ( self , node ) View Source def visit_tgroup(self, node): self.colspecs = [] node.stubs = [] visit_thead def visit_thead ( self , node ) View Source def visit_thead(self, node): self.body.append(self.starttag(node, 'thead', valign='bottom')) visit_title def visit_title ( self , node ) Only 6 section levels are supported by HTML. View Source def visit_title(self, node): \"\"\"Only 6 section levels are supported by HTML.\"\"\" close_tag = ' </p> \\n' if isinstance(node.parent, nodes.topic): self.body.append( self.starttag(node, 'p', '', CLASS='topic-title')) elif isinstance(node.parent, nodes.sidebar): self.body.append( self.starttag(node, 'p', '', CLASS='sidebar-title')) elif isinstance(node.parent, nodes.Admonition): self.body.append( self.starttag(node, 'p', '', CLASS='admonition-title')) elif isinstance(node.parent, nodes.table): self.body.append( self.starttag(node, 'caption', '')) close_tag = ' </caption> \\n' elif isinstance(node.parent, nodes.document): self.body.append(self.starttag(node, 'h1', '', CLASS='title')) close_tag = ' </h1> \\n' self.in_document_title = len(self.body) else: assert isinstance(node.parent, nodes.section) h_level = self.section_level + self.initial_header_level - 1 atts = {} if (len(node.parent) >= 2 and isinstance(node.parent[1], nodes.subtitle)): atts['CLASS'] = 'with-subtitle' self.body.append( self.starttag(node, 'h%s' % h_level, '', **atts)) atts = {} if node.hasattr('refid'): atts['class'] = 'toc-backref' atts['href'] = '#' + node['refid'] if atts: self.body.append(self.starttag({}, 'a', '', **atts)) close_tag = ' </a> < /h%s>\\n' % (h_level) else: close_tag = ' < /h%s>\\n' % (h_level) self.context.append(close_tag) visit_title_reference def visit_title_reference ( self , node ) View Source def visit_title_reference(self, node): self.body.append(self.starttag(node, 'cite', '')) visit_topic def visit_topic ( self , node ) View Source def visit_topic(self, node): self.body.append(self.starttag(node, 'div', CLASS='topic')) self.topic_classes = node['classes'] visit_transition def visit_transition ( self , node ) View Source def visit_transition(self, node): self.body.append(self.emptytag(node, 'hr', CLASS='docutils')) visit_version def visit_version ( self , node ) View Source def visit_version(self, node): self.visit_docinfo_item(node, 'version', meta=False)","title":"Rst Support"},{"location":"reference/pydoc_fork/reporter/rst_support/#module-pydoc_forkreporterrst_support","text":"Rst to HTML function Credits: https://stackoverflow.com/a/49047197/33264 View Source \"\"\" Rst to HTML function Credits: https://stackoverflow.com/a/49047197/33264 \"\"\" from docutils import core from docutils.writers.html4css1 import HTMLTranslator , Writer from typing import Any , List class HTMLFragmentTranslator ( HTMLTranslator ): \"\"\"Minimum to call docutils\"\"\" def __init__ ( self , document : Any ) -> None : \"\"\"setup\"\"\" HTMLTranslator . __init__ ( self , document ) self . head_prefix = [ \"\" , \"\" , \"\" , \"\" , \"\" ] self . body_prefix : List [ Any ] = [] self . body_suffix : List [ Any ] = [] self . stylesheet : List [ Any ] = [] def astext ( self ) -> str : \"\"\"minimum to call docutils\"\"\" return \"\" . join ( self . body ) html_fragment_writer = Writer () html_fragment_writer . translator_class = HTMLFragmentTranslator def rst_to_html ( text : str ) -> str : \"\"\"Convert rst string to html string\"\"\" return core . publish_string ( text , writer = html_fragment_writer ) . decode ( \"utf-8\" )","title":"Module pydoc_fork.reporter.rst_support"},{"location":"reference/pydoc_fork/reporter/rst_support/#variables","text":"html_fragment_writer","title":"Variables"},{"location":"reference/pydoc_fork/reporter/rst_support/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/reporter/rst_support/#rst_to_html","text":"def rst_to_html ( text : str ) -> str Convert rst string to html string View Source def rst_to_html ( text : str ) -> str : \"\"\"Convert rst string to html string\"\"\" return core . publish_string ( text , writer = html_fragment_writer ). decode ( \"utf-8\" )","title":"rst_to_html"},{"location":"reference/pydoc_fork/reporter/rst_support/#classes","text":"","title":"Classes"},{"location":"reference/pydoc_fork/reporter/rst_support/#htmlfragmenttranslator","text":"class HTMLFragmentTranslator ( document : Any ) View Source class HTMLFragmentTranslator ( HTMLTranslator ) : \"\"\"Minimum to call docutils\"\"\" def __init__ ( self , document : Any ) -> None : \"\"\"setup\"\"\" HTMLTranslator . __init__ ( self , document ) self . head_prefix = [ \"\", \"\", \"\", \"\", \"\" ] self . body_prefix : List [ Any ] = [] self . body_suffix : List [ Any ] = [] self . stylesheet : List [ Any ] = [] def astext ( self ) -> str : \"\"\"minimum to call docutils\"\"\" return \"\" . join ( self . body )","title":"HTMLFragmentTranslator"},{"location":"reference/pydoc_fork/reporter/rst_support/#ancestors-in-mro","text":"docutils.writers.html4css1.HTMLTranslator docutils.writers._html_base.HTMLTranslator docutils.nodes.NodeVisitor","title":"Ancestors (in MRO)"},{"location":"reference/pydoc_fork/reporter/rst_support/#class-variables","text":"attribution_formats content_type content_type_mathml doctype doctype_mathml embedded_stylesheet generator head_prefix_template in_word_wrap_point lang_attribute math_tags mathjax_script mathjax_url object_image_types optional special_characters stylesheet_link words_and_spaces xml_declaration","title":"Class variables"},{"location":"reference/pydoc_fork/reporter/rst_support/#methods","text":"","title":"Methods"},{"location":"reference/pydoc_fork/reporter/rst_support/#add_meta","text":"def add_meta ( self , tag ) View Source def add_meta(self, tag): self.meta.append(tag) self.head.append(tag)","title":"add_meta"},{"location":"reference/pydoc_fork/reporter/rst_support/#astext","text":"def astext ( self ) -> str minimum to call docutils View Source def astext ( self ) -> str : \"\"\"minimum to call docutils\"\"\" return \"\" . join ( self . body )","title":"astext"},{"location":"reference/pydoc_fork/reporter/rst_support/#attval","text":"def attval ( self , text , whitespace = re . compile ( '[ \\n\\r\\t\\x0b\\x0c ]' ) ) Cleanse, HTML encode, and return attribute value text. View Source def attval ( self , text , whitespace = re . compile ( ' [ \\ n \\ r \\ t \\ v \\ f ] ' )): \"\"\"Cleanse, HTML encode, and return attribute value text.\"\"\" encoded = self . encode ( whitespace . sub ( ' ' , text )) if self . in_mailto and self . settings . cloak_email_addresses : # Cloak at-signs ( \"%40\" ) and periods with HTML entities . encoded = encoded . replace ( '%40' , '&#37;&#52;&#48;' ) encoded = encoded . replace ( '.' , '&#46;' ) return encoded","title":"attval"},{"location":"reference/pydoc_fork/reporter/rst_support/#check_simple_list","text":"def check_simple_list ( self , node ) Check for a simple list that can be rendered compactly. View Source def check_simple_list ( self , node ) : \"\"\" Check for a simple list that can be rendered compactly. \"\"\" visitor = SimpleListChecker ( self . document ) try : node . walk ( visitor ) except nodes . NodeFound : return False else : return True","title":"check_simple_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#cloak_email","text":"def cloak_email ( self , addr ) Try to hide the link text of a email link from harversters. View Source def cloak_email ( self , addr ) : \"\"\"Try to hide the link text of a email link from harversters.\"\"\" # Surround at-signs and periods with <span> tags. (\"@\" has # already been encoded to \"&#64 ; \" by the `encode` method.) addr = addr . replace ( ' & # 64 ; ' , ' < span >& # 64 ; </ span > ' ) addr = addr . replace ( '.' , ' < span >& # 46 ; </ span > ' ) return addr","title":"cloak_email"},{"location":"reference/pydoc_fork/reporter/rst_support/#cloak_mailto","text":"def cloak_mailto ( self , uri ) Try to hide a mailto: URL from harvesters. View Source def cloak_mailto ( self , uri ) : \"\"\"Try to hide a mailto: URL from harvesters.\"\"\" # Encode \"@\" using a URL octet reference (see RFC 1738). # Further cloaking with HTML entities will be done in the # `attval` function. return uri . replace ( '@' , ' % 40 ' )","title":"cloak_mailto"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_text","text":"def depart_Text ( self , node ) View Source def depart_Text(self, node): pass","title":"depart_Text"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_abbreviation","text":"def depart_abbreviation ( self , node ) View Source def depart_abbreviation(self, node): self.body.append('</abbr>')","title":"depart_abbreviation"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_acronym","text":"def depart_acronym ( self , node ) View Source def depart_acronym(self, node): self.body.append('</acronym>')","title":"depart_acronym"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_address","text":"def depart_address ( self , node ) View Source def depart_address(self, node): self.body.append('\\n</pre>\\n') self.depart_docinfo_item()","title":"depart_address"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_admonition","text":"def depart_admonition ( self , node = None ) View Source def depart_admonition(self, node=None): self.body.append('</div>\\n')","title":"depart_admonition"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_attribution","text":"def depart_attribution ( self , node ) View Source def depart_attribution(self, node): self.body.append(self.context.pop() + '</p>\\n')","title":"depart_attribution"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_author","text":"def depart_author ( self , node ) View Source def depart_author ( self , node ) : if isinstance ( node . parent , nodes . authors ) : self . author_in_authors = True else : self . depart_docinfo_item ()","title":"depart_author"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_authors","text":"def depart_authors ( self , node ) View Source def depart_authors(self, node): self.depart_docinfo_item()","title":"depart_authors"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_block_quote","text":"def depart_block_quote ( self , node ) View Source def depart_block_quote(self, node): self.body.append('</blockquote>\\n')","title":"depart_block_quote"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_bullet_list","text":"def depart_bullet_list ( self , node ) View Source def depart_bullet_list(self, node): self.compact_simple, self.compact_p = self.context.pop() self.body.append('</ul>\\n')","title":"depart_bullet_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_caption","text":"def depart_caption ( self , node ) View Source def depart_caption(self, node): self.body.append('</p>\\n')","title":"depart_caption"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_citation","text":"def depart_citation ( self , node ) View Source def depart_citation(self, node): self.body.append(' </td></tr> \\n' ' </tbody> \\n </table> \\n')","title":"depart_citation"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_citation_reference","text":"def depart_citation_reference ( self , node ) View Source def depart_citation_reference(self, node): self.body.append(']</a>')","title":"depart_citation_reference"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_classifier","text":"def depart_classifier ( self , node ) View Source def depart_classifier(self, node): self.body.append('</span>')","title":"depart_classifier"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_colspec","text":"def depart_colspec ( self , node ) View Source def depart_colspec(self, node): # write out <colgroup> when all colspecs are processed if isinstance(node.next_node(descend=False, siblings=True), nodes.colspec): return if 'colwidths-auto' in node.parent.parent['classes'] or ( 'colwidths-auto' in self.settings.table_style and ('colwidths-given' not in node.parent.parent['classes'])): return total_width = sum(node['colwidth'] for node in self.colspecs) self.body.append(self.starttag(node, 'colgroup')) for node in self.colspecs: colwidth = int(node['colwidth'] * 100.0 / total_width + 0.5) self.body.append(self.emptytag(node, 'col', width='%i%%' % colwidth)) self.body.append(' </colgroup> \\n')","title":"depart_colspec"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_compound","text":"def depart_compound ( self , node ) View Source def depart_compound(self, node): self.body.append('</div>\\n')","title":"depart_compound"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_contact","text":"def depart_contact ( self , node ) View Source def depart_contact(self, node): self.depart_docinfo_item()","title":"depart_contact"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_container","text":"def depart_container ( self , node ) View Source def depart_container(self, node): self.body.append('</div>\\n')","title":"depart_container"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_copyright","text":"def depart_copyright ( self , node ) View Source def depart_copyright(self, node): self.depart_docinfo_item()","title":"depart_copyright"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_date","text":"def depart_date ( self , node ) View Source def depart_date(self, node): self.depart_docinfo_item()","title":"depart_date"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_decoration","text":"def depart_decoration ( self , node ) View Source def depart_decoration(self, node): pass","title":"depart_decoration"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_definition","text":"def depart_definition ( self , node ) View Source def depart_definition(self, node): self.body.append('</dd>\\n')","title":"depart_definition"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_definition_list","text":"def depart_definition_list ( self , node ) View Source def depart_definition_list(self, node): self.body.append('</dl>\\n')","title":"depart_definition_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_definition_list_item","text":"def depart_definition_list_item ( self , node ) View Source def depart_definition_list_item(self, node): pass","title":"depart_definition_list_item"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_description","text":"def depart_description ( self , node ) View Source def depart_description(self, node): self.body.append('</td>')","title":"depart_description"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_docinfo","text":"def depart_docinfo ( self , node ) View Source def depart_docinfo(self, node): self.body.append(' </tbody> \\n </table> \\n') self.in_docinfo = False start = self.context.pop() self.docinfo = self.body[start:] self.body = []","title":"depart_docinfo"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_docinfo_item","text":"def depart_docinfo_item ( self ) View Source def depart_docinfo_item(self): self.body.append(' </td></tr> \\n')","title":"depart_docinfo_item"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_doctest_block","text":"def depart_doctest_block ( self , node ) View Source def depart_doctest_block(self, node): self.body.append('\\n</pre>\\n')","title":"depart_doctest_block"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_document","text":"def depart_document ( self , node ) View Source def depart_document ( self , node ) : self . head_prefix . extend ([ self . doctype , self . head_prefix_template % { 'lang': self . settings . language_code }]) self . html_prolog . append ( self . doctype ) self . meta . insert ( 0 , self . content_type % self.settings.output_encoding) self . head . insert ( 0 , self . content_type % self.settings.output_encoding) if 'name=\"dcterms.' in '' . join ( self . meta ) : self . head . append ( '<link rel=\"schema.dcterms\" href=\"http://purl.org/dc/terms/\"/>' ) if self . math_header: if self . math_output == 'mathjax': self . head . extend ( self . math_header ) else : self . stylesheet . extend ( self . math_header ) # skip content - type meta tag with interpolated charset value : self . html_head . extend ( self . head [ 1 : ]) self . body_prefix . append ( self . starttag ( node , 'div' , CLASS ='document' )) self . body_suffix . insert ( 0 , '</div>\\n' ) self . fragment . extend ( self . body ) # self . fragment is the \"naked\" body self . html_body . extend ( self . body_prefix [ 1 : ] + self . body_pre_docinfo + self . docinfo + self . body + self . body_suffix [:- 1 ]) assert not self . context , 'len(context) = %s' % len(self.context)","title":"depart_document"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_emphasis","text":"def depart_emphasis ( self , node ) View Source def depart_emphasis(self, node): self.body.append('</em>')","title":"depart_emphasis"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_entry","text":"def depart_entry ( self , node ) View Source def depart_entry(self, node): self.body.append(self.context.pop())","title":"depart_entry"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_enumerated_list","text":"def depart_enumerated_list ( self , node ) View Source def depart_enumerated_list ( self , node ): self . compact_simple , self . compact_p = self . context . pop () self . body . append ( '</ol> \\n ' )","title":"depart_enumerated_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_field","text":"def depart_field ( self , node ) View Source def depart_field(self, node): self.body.append('</tr>\\n')","title":"depart_field"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_field_body","text":"def depart_field_body ( self , node ) View Source def depart_field_body(self, node): self.body.append('</td>\\n')","title":"depart_field_body"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_field_list","text":"def depart_field_list ( self , node ) View Source def depart_field_list(self, node): self.body.append(' </tbody> \\n </table> \\n') self.compact_field_list, self.compact_p = self.context.pop()","title":"depart_field_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_field_name","text":"def depart_field_name ( self , node ) View Source def depart_field_name(self, node): self.body.append(':</th>') self.body.append(self.context.pop())","title":"depart_field_name"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_figure","text":"def depart_figure ( self , node ) View Source def depart_figure(self, node): self.body.append('</div>\\n')","title":"depart_figure"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_footer","text":"def depart_footer ( self , node ) View Source def depart_footer(self, node): start = self.context.pop() footer = [self.starttag(node, 'div', CLASS='footer'), ' <hr class= \"footer\" /> \\n'] footer.extend(self.body[start:]) footer.append('\\n </div> \\n') self.footer.extend(footer) self.body_suffix[:0] = footer del self.body[start:]","title":"depart_footer"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_footnote","text":"def depart_footnote ( self , node ) View Source def depart_footnote(self, node): self.body.append(' </td></tr> \\n' ' </tbody> \\n </table> \\n')","title":"depart_footnote"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_footnote_reference","text":"def depart_footnote_reference ( self , node ) View Source def depart_footnote_reference(self, node): self.body.append(self.context.pop() + '</a>')","title":"depart_footnote_reference"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_generated","text":"def depart_generated ( self , node ) View Source def depart_generated(self, node): pass","title":"depart_generated"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_header","text":"def depart_header ( self , node ) View Source def depart_header(self, node): start = self.context.pop() header = [self.starttag(node, 'div', CLASS='header')] header.extend(self.body[start:]) header.append('\\n <hr class= \"header\" /> \\n </div> \\n') self.body_prefix.extend(header) self.header.extend(header) del self.body[start:]","title":"depart_header"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_image","text":"def depart_image ( self , node ) View Source def depart_image(self, node): pass","title":"depart_image"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_inline","text":"def depart_inline ( self , node ) View Source def depart_inline(self, node): self.body.append('</span>')","title":"depart_inline"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_label","text":"def depart_label ( self , node ) View Source def depart_label(self, node): self.body.append(']%s</td><td>%s' % (self.context.pop(), self.context.pop()))","title":"depart_label"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_legend","text":"def depart_legend ( self , node ) View Source def depart_legend(self, node): self.body.append('</div>\\n')","title":"depart_legend"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_line","text":"def depart_line ( self , node ) View Source def depart_line(self, node): self.body.append('</div>\\n')","title":"depart_line"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_line_block","text":"def depart_line_block ( self , node ) View Source def depart_line_block(self, node): self.body.append('</div>\\n')","title":"depart_line_block"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_list_item","text":"def depart_list_item ( self , node ) View Source def depart_list_item(self, node): self.body.append('</li>\\n')","title":"depart_list_item"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_literal","text":"def depart_literal ( self , node ) View Source def depart_literal(self, node): # skipped unless literal element is from \"code\" role: self.body.append('</code>')","title":"depart_literal"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_literal_block","text":"def depart_literal_block ( self , node ) View Source def depart_literal_block(self, node): self.body.append('\\n</pre>\\n')","title":"depart_literal_block"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_math","text":"def depart_math ( self , node ) View Source def depart_math(self, node): pass # never reached","title":"depart_math"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_math_block","text":"def depart_math_block ( self , node ) View Source def depart_math_block(self, node): pass # never reached","title":"depart_math_block"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_meta","text":"def depart_meta ( self , node ) View Source def depart_meta(self, node): pass","title":"depart_meta"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_option","text":"def depart_option ( self , node ) View Source def depart_option ( self , node ) : self . body . append ( ' </span> ' ) if isinstance ( node . next_node ( descend = False , siblings = True ) , nodes . option ) : self . body . append ( ' , ' )","title":"depart_option"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_option_argument","text":"def depart_option_argument ( self , node ) View Source def depart_option_argument ( self , node ): self . body . append ( '</var>' )","title":"depart_option_argument"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_option_group","text":"def depart_option_group ( self , node ) View Source def depart_option_group(self, node): self.context.pop() self.body.append(' </kbd></td> \\n') self.body.append(self.context.pop())","title":"depart_option_group"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_option_list","text":"def depart_option_list ( self , node ) View Source def depart_option_list(self, node): self.body.append(' </tbody> \\n </table> \\n')","title":"depart_option_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_option_list_item","text":"def depart_option_list_item ( self , node ) View Source def depart_option_list_item(self, node): self.body.append('</tr>\\n')","title":"depart_option_list_item"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_option_string","text":"def depart_option_string ( self , node ) View Source def depart_option_string(self, node): pass","title":"depart_option_string"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_organization","text":"def depart_organization ( self , node ) View Source def depart_organization(self, node): self.depart_docinfo_item()","title":"depart_organization"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_paragraph","text":"def depart_paragraph ( self , node ) View Source def depart_paragraph(self, node): self.body.append(self.context.pop())","title":"depart_paragraph"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_problematic","text":"def depart_problematic ( self , node ) View Source def depart_problematic(self, node): self.body.append('</span>') self.body.append(self.context.pop())","title":"depart_problematic"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_reference","text":"def depart_reference ( self , node ) View Source def depart_reference ( self , node ) : self . body . append ( ' </a> ' ) if not isinstance ( node . parent , nodes . TextElement ) : self . body . append ( ' \\n ' ) self . in_mailto = False","title":"depart_reference"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_revision","text":"def depart_revision ( self , node ) View Source def depart_revision(self, node): self.depart_docinfo_item()","title":"depart_revision"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_row","text":"def depart_row ( self , node ) View Source def depart_row(self, node): self.body.append('</tr>\\n')","title":"depart_row"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_rubric","text":"def depart_rubric ( self , node ) View Source def depart_rubric(self, node): self.body.append('</p>\\n')","title":"depart_rubric"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_section","text":"def depart_section ( self , node ) View Source def depart_section(self, node): self.section_level -= 1 self.body.append('</div>\\n')","title":"depart_section"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_sidebar","text":"def depart_sidebar ( self , node ) View Source def depart_sidebar(self, node): self.body.append('</div>\\n') self.in_sidebar = False","title":"depart_sidebar"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_status","text":"def depart_status ( self , node ) View Source def depart_status(self, node): self.depart_docinfo_item()","title":"depart_status"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_strong","text":"def depart_strong ( self , node ) View Source def depart_strong(self, node): self.body.append('</strong>')","title":"depart_strong"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_subscript","text":"def depart_subscript ( self , node ) View Source def depart_subscript(self, node): if isinstance(node.parent, nodes.literal_block): self.body.append(' </span> ') else: self.body.append(' </sub> ')","title":"depart_subscript"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_subtitle","text":"def depart_subtitle ( self , node ) View Source def depart_subtitle ( self , node ) : self . body . append ( self . context . pop ()) if self . in_document_title: self . subtitle = self . body [ self . in_document_title :- 1 ] self . in_document_title = 0 self . body_pre_docinfo . extend ( self . body ) self . html_subtitle . extend ( self . body ) del self . body [ : ]","title":"depart_subtitle"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_superscript","text":"def depart_superscript ( self , node ) View Source def depart_superscript(self, node): if isinstance(node.parent, nodes.literal_block): self.body.append(' </span> ') else: self.body.append(' </sup> ')","title":"depart_superscript"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_system_message","text":"def depart_system_message ( self , node ) View Source def depart_system_message(self, node): self.body.append('</div>\\n')","title":"depart_system_message"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_table","text":"def depart_table ( self , node ) View Source def depart_table(self, node): self.compact_p = self.context.pop() self.body.append('</table>\\n')","title":"depart_table"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_target","text":"def depart_target ( self , node ) View Source def depart_target(self, node): self.body.append(self.context.pop())","title":"depart_target"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_tbody","text":"def depart_tbody ( self , node ) View Source def depart_tbody(self, node): self.body.append('</tbody>\\n')","title":"depart_tbody"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_term","text":"def depart_term ( self , node ) Leave the end tag to self.visit_definition() , in case there's a classifier. View Source def depart_term ( self , node ) : \"\"\" Leave the end tag to ` self . visit_definition () `, in case there ' s a classifier . \"\"\" pass","title":"depart_term"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_tgroup","text":"def depart_tgroup ( self , node ) View Source def depart_tgroup(self, node): pass","title":"depart_tgroup"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_thead","text":"def depart_thead ( self , node ) View Source def depart_thead(self, node): self.body.append('</thead>\\n')","title":"depart_thead"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_title","text":"def depart_title ( self , node ) View Source def depart_title ( self , node ) : self . body . append ( self . context . pop ()) if self . in_document_title: self . title = self . body [ self . in_document_title :- 1 ] self . in_document_title = 0 self . body_pre_docinfo . extend ( self . body ) self . html_title . extend ( self . body ) del self . body [ : ]","title":"depart_title"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_title_reference","text":"def depart_title_reference ( self , node ) View Source def depart_title_reference(self, node): self.body.append('</cite>')","title":"depart_title_reference"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_topic","text":"def depart_topic ( self , node ) View Source def depart_topic(self, node): self.body.append('</div>\\n') self.topic_classes = []","title":"depart_topic"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_transition","text":"def depart_transition ( self , node ) View Source def depart_transition(self, node): pass","title":"depart_transition"},{"location":"reference/pydoc_fork/reporter/rst_support/#depart_version","text":"def depart_version ( self , node ) View Source def depart_version(self, node): self.depart_docinfo_item()","title":"depart_version"},{"location":"reference/pydoc_fork/reporter/rst_support/#dispatch_departure","text":"def dispatch_departure ( self , node ) Call self.\" depart_ + node class name\" with node as parameter. If the depart_... method does not exist, call self.unknown_departure. View Source def dispatch_departure ( self , node ) : \" \"\" Call self.\" `` depart_ `` + node class name \" with `node` as parameter. If the ``depart_...`` method does not exist, call self.unknown_departure. \"\" \" node_name = node . __class__ . __name__ method = getattr ( self , 'depart_' + node_name , self . unknown_departure ) self . document . reporter . debug ( 'docutils.nodes.NodeVisitor.dispatch_departure calling %s for %s' % ( method . __name__ , node_name )) return method ( node )","title":"dispatch_departure"},{"location":"reference/pydoc_fork/reporter/rst_support/#dispatch_visit","text":"def dispatch_visit ( self , node ) Call self.\" visit_ + node class name\" with node as parameter. If the visit_... method does not exist, call self.unknown_visit. View Source def dispatch_visit ( self , node ) : \" \"\" Call self.\" `` visit_ `` + node class name \" with `node` as parameter. If the ``visit_...`` method does not exist, call self.unknown_visit. \"\" \" node_name = node . __class__ . __name__ method = getattr ( self , 'visit_' + node_name , self . unknown_visit ) self . document . reporter . debug ( 'docutils.nodes.NodeVisitor.dispatch_visit calling %s for %s' % ( method . __name__ , node_name )) return method ( node )","title":"dispatch_visit"},{"location":"reference/pydoc_fork/reporter/rst_support/#emptytag","text":"def emptytag ( self , node , tagname , suffix = ' \\n ' , ** attributes ) Construct and return an XML-compatible empty tag. View Source def emptytag ( self , node , tagname , suffix = ' \\n ' , ** attributes ) : \"\"\" Construct and return an XML-compatible empty tag. \"\"\" return self . starttag ( node , tagname , suffix , empty = True , ** attributes )","title":"emptytag"},{"location":"reference/pydoc_fork/reporter/rst_support/#encode","text":"def encode ( self , text ) Encode special characters in text & return. View Source def encode ( self , text ) : \" \"\" Encode special characters in `text` & return. \"\" \" # Use only named entities known in both XML and HTML # other characters are automatically encoded \"by number\" if required. # @@@ A codec to do these and all other HTML entities would be nice. text = unicode ( text ) return text . translate ( self . special_characters )","title":"encode"},{"location":"reference/pydoc_fork/reporter/rst_support/#footnote_backrefs","text":"def footnote_backrefs ( self , node ) View Source def footnote_backrefs(self, node): backlinks = [] backrefs = node['backrefs'] if self.settings.footnote_backlinks and backrefs: if len(backrefs) == 1: self.context.append('') self.context.append(' </a> ') self.context.append(' <a class= \"fn-backref\" href= \"#%s\" > ' % backrefs[0]) else: for (i, backref) in enumerate(backrefs, 1): backlinks.append(' <a class= \"fn-backref\" href= \"#%s\" > %s </a> ' % (backref, i)) self.context.append(' <em> (%s) </em> ' % ', '.join(backlinks)) self.context += ['', ''] else: self.context.append('') self.context += ['', ''] # If the node does not only consist of a label. if len(node) > 1: # If there are preceding backlinks, we do not set class # 'first', because we need to retain the top-margin. if not backlinks: node[1]['classes'].append('first') node[-1]['classes'].append('last')","title":"footnote_backrefs"},{"location":"reference/pydoc_fork/reporter/rst_support/#is_compactable","text":"def is_compactable ( self , node ) View Source def is_compactable ( self , node ) : return ( ' compact ' in node [ ' classes ' ] or ( self . settings . compact_lists and ' open ' not in node [ ' classes ' ] and ( self . compact_simple or self . topic_classes == [ ' contents ' ] # TODO : self . in_contents or self . check_simple_list ( node ))))","title":"is_compactable"},{"location":"reference/pydoc_fork/reporter/rst_support/#set_class_on_child","text":"def set_class_on_child ( self , node , class_ , index = 0 ) Set class class_ on the visible child no. index of node . Do nothing if node has fewer children than index . View Source def set _class_on_child ( self , node , class_ , index = 0 ) : \" \"\" Set class `class_` on the visible child no. index of `node`. Do nothing if node has fewer children than `index`. \"\" \" children = [ n for n in node if not isinstance ( n , nodes . Invisible ) ] try : child = children [ index ] except IndexError : return child [ 'classes' ] . append ( class_ )","title":"set_class_on_child"},{"location":"reference/pydoc_fork/reporter/rst_support/#set_first_last","text":"def set_first_last ( self , node ) View Source def set_first_last(self, node): self.set_class_on_child(node, 'first', 0) self.set_class_on_child(node, 'last', -1)","title":"set_first_last"},{"location":"reference/pydoc_fork/reporter/rst_support/#should_be_compact_paragraph","text":"def should_be_compact_paragraph ( self , node ) Determine if the tags around paragraph node can be omitted. View Source def should_be_compact_paragraph ( self , node ) : \" \"\" Determine if the <p> tags around paragraph ``node`` can be omitted. \"\" \" if ( isinstance ( node . parent , nodes . document ) or isinstance ( node . parent , nodes . compound )) : # Never compact paragraphs in document or compound. return False for key , value in node . attlist () : if ( node . is_not_default ( key ) and not ( key == 'classes' and value in ( [] , [ 'first' ] , [ 'last' ] , [ 'first' , 'last' ] ))) : # Attribute which needs to survive. return False first = isinstance ( node . parent [ 0 ] , nodes . label ) # skip label for child in node . parent . children [ first : ] : # only first paragraph can be compact if isinstance ( child , nodes . Invisible ) : continue if child is node : break return False parent_length = len ( [ n for n in node . parent if not isinstance ( n , ( nodes . Invisible , nodes . label )) ] ) if ( self . compact_simple or self . compact_field_list or self . compact_p and parent_length == 1 ) : return True return False","title":"should_be_compact_paragraph"},{"location":"reference/pydoc_fork/reporter/rst_support/#starttag","text":"def starttag ( self , node , tagname , suffix = ' \\n ' , empty = False , ** attributes ) Construct and return a start tag given a node (id & class attributes are extracted), tag name, and optional attributes. View Source def starttag ( self , node , tagname , suffix = '\\n' , empty = False , ** attributes ) : \"\"\" Construct and return a start tag given a node (id & class attributes are extracted), tag name, and optional attributes. \"\"\" tagname = tagname . lower () prefix = [] atts = {} ids = [] for ( name , value ) in attributes . items () : atts [ name.lower() ] = value classes = [] languages = [] # unify class arguments and move language specification for cls in node . get ( 'classes' , [] ) + atts . pop ( 'class' , '' ). split () : if cls . startswith ( 'language-' ) : languages . append ( cls [ 9: ] ) elif cls . strip () and cls not in classes : classes . append ( cls ) if languages : # attribute name is 'lang' in XHTML 1.0 but 'xml:lang' in 1.1 atts [ self.lang_attribute ] = languages [ 0 ] if classes : atts [ 'class' ] = ' ' . join ( classes ) assert 'id' not in atts ids . extend ( node . get ( 'ids' , [] )) if 'ids' in atts : ids . extend ( atts [ 'ids' ] ) del atts [ 'ids' ] if ids : atts [ 'id' ] = ids [ 0 ] for id in ids [ 1: ] : # Add empty \"span\" elements for additional IDs . Note # that we cannot use empty \"a\" elements because there # may be targets inside of references , but nested \"a\" # elements aren 't allowed in XHTML (even if they do # not all have a \"href\" attribute). if empty or isinstance(node, (nodes.bullet_list, nodes.docinfo, nodes.definition_list, nodes.enumerated_list, nodes.field_list, nodes.option_list, nodes.table)): # Insert target right in front of element. prefix.append(' < span id = \"%s\" ></ span > ' % id) else: # Non-empty tag. Place the auxiliary <span> tag # *inside* the element, as the first child. suffix += ' < span id = \"%s\" ></ span > ' % id attlist = sorted(atts.items()) parts = [tagname] for name, value in attlist: # value=None was used for boolean attributes without # value, but this isn' t supported by XHTML . assert value is not None if isinstance ( value , list ) : values = [ unicode(v) for v in value ] parts . append ( '%s=\"%s\"' % ( name . lower (), self . attval ( ' ' . join ( values )))) else : parts . append ( '%s=\"%s\"' % ( name . lower (), self . attval ( unicode ( value )))) if empty : infix = ' /' else : infix = '' return '' . join ( prefix ) + '<%s%s>' % ( ' ' . join ( parts ), infix ) + suffix","title":"starttag"},{"location":"reference/pydoc_fork/reporter/rst_support/#stylesheet_call","text":"def stylesheet_call ( self , path ) Return code to reference or embed stylesheet file path View Source def stylesheet_call ( self , path ) : \" \"\" Return code to reference or embed stylesheet file `path` \"\" \" if self . set tings . embed_stylesheet : try : content = io . FileInput ( source_path = path , encoding = 'utf-8' ). read () self . set tings . record_dependencies . add ( path ) except IOError as err : msg = u \"Cannot embed stylesheet '%r': %s.\" % ( path , SafeString ( err . strerror )) self . document . reporter . error ( msg ) return '<--- %s ---> \\n ' % msg return self . embedded_stylesheet % content # else link to style file: if self . set tings . stylesheet_path : # adapt path relative to output (cf. config.html#stylesheet-path) path = utils . relative_path ( self . set tings . _destination , path ) return self . stylesheet_link % self . encode ( path )","title":"stylesheet_call"},{"location":"reference/pydoc_fork/reporter/rst_support/#unimplemented_visit","text":"def unimplemented_visit ( self , node ) View Source def unimplemented_visit(self, node): raise NotImplementedError ( 'visiting unimplemented node type: %s' % node.__class__.__name__)","title":"unimplemented_visit"},{"location":"reference/pydoc_fork/reporter/rst_support/#unknown_departure","text":"def unknown_departure ( self , node ) Called before exiting unknown Node types. Raise exception unless overridden. View Source def unknown_departure ( self , node ) : \" \"\" Called before exiting unknown `Node` types. Raise exception unless overridden. \"\" \" if ( self . document . set tings . strict_visitor or node . __class__ . __name__ not in self . optional ) : raise NotImplementedError ( '%s departing unknown node type: %s' % ( self . __class__ , node . __class__ . __name__ ))","title":"unknown_departure"},{"location":"reference/pydoc_fork/reporter/rst_support/#unknown_visit","text":"def unknown_visit ( self , node ) Called when entering unknown Node types. Raise an exception unless overridden. View Source def unknown_visit ( self , node ) : \" \"\" Called when entering unknown `Node` types. Raise an exception unless overridden. \"\" \" if ( self . document . set tings . strict_visitor or node . __class__ . __name__ not in self . optional ) : raise NotImplementedError ( '%s visiting unknown node type: %s' % ( self . __class__ , node . __class__ . __name__ ))","title":"unknown_visit"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_text","text":"def visit_Text ( self , node ) View Source def visit_Text ( self , node ) : text = node . astext () encoded = self . encode ( text ) if self . in_mailto and self . settings . cloak_email_addresses : encoded = self . cloak_email ( encoded ) self . body . append ( encoded )","title":"visit_Text"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_abbreviation","text":"def visit_abbreviation ( self , node ) View Source def visit_abbreviation(self, node): # @@@ implementation incomplete (\"title\" attribute) self.body.append(self.starttag(node, 'abbr', ''))","title":"visit_abbreviation"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_acronym","text":"def visit_acronym ( self , node ) View Source def visit_acronym(self, node): # @@@ implementation incomplete (\"title\" attribute) self.body.append(self.starttag(node, 'acronym', ''))","title":"visit_acronym"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_address","text":"def visit_address ( self , node ) View Source def visit_address(self, node): self.visit_docinfo_item(node, 'address', meta=False) self.body.append(self.starttag(node, 'pre', CLASS='address'))","title":"visit_address"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_admonition","text":"def visit_admonition ( self , node ) View Source def visit_admonition(self, node): node['classes'].insert(0, 'admonition') self.body.append(self.starttag(node, 'div')) self.set_first_last(node)","title":"visit_admonition"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_attribution","text":"def visit_attribution ( self , node ) View Source def visit_attribution(self, node): prefix, suffix = self.attribution_formats[self.settings.attribution] self.context.append(suffix) self.body.append( self.starttag(node, 'p', prefix, CLASS='attribution'))","title":"visit_attribution"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_author","text":"def visit_author ( self , node ) View Source def visit_author ( self , node ) : if isinstance ( node . parent , nodes . authors ) : if self . author_in_authors : self . body . append ( ' \\n <br /> ' ) else : self . visit_docinfo_item ( node , ' author ' )","title":"visit_author"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_authors","text":"def visit_authors ( self , node ) View Source def visit_authors(self, node): self.visit_docinfo_item(node, 'authors') self.author_in_authors = False # initialize","title":"visit_authors"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_block_quote","text":"def visit_block_quote ( self , node ) View Source def visit_block_quote(self, node): self.body.append(self.starttag(node, 'blockquote'))","title":"visit_block_quote"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_bullet_list","text":"def visit_bullet_list ( self , node ) View Source def visit_bullet_list ( self , node ) : atts = {} old_compact_simple = self . compact_simple self . context . append (( self . compact_simple , self . compact_p )) self . compact_p = None self . compact_simple = self . is_compactable ( node ) if self . compact_simple and not old_compact_simple : atts [ ' class ' ] = ' simple ' self . body . append ( self . starttag ( node , ' ul ' , ** atts ))","title":"visit_bullet_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_caption","text":"def visit_caption ( self , node ) View Source def visit_caption(self, node): self.body.append(self.starttag(node, 'p', '', CLASS='caption'))","title":"visit_caption"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_citation","text":"def visit_citation ( self , node ) View Source def visit_citation(self, node): self.body.append(self.starttag(node, 'table', CLASS='docutils citation', frame=\"void\", rules=\"none\")) self.body.append(' <colgroup><col class= \"label\" /><col /></colgroup> \\n' ' <tbody valign= \"top\" > \\n' ' <tr> ') self.footnote_backrefs(node)","title":"visit_citation"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_citation_reference","text":"def visit_citation_reference ( self , node ) View Source def visit_citation_reference ( self , node ) : href = ' # ' if ' refid ' in node : href += node [ ' refid ' ] elif ' refname ' in node : href += self . document . nameids [ node [ ' refname ' ]] # else : # TODO system message ( or already in the transform ) ? # ' Citation reference missing. ' self . body . append ( self . starttag ( node , ' a ' , ' [ ' , CLASS = ' citation-reference ' , href = href ))","title":"visit_citation_reference"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_classifier","text":"def visit_classifier ( self , node ) View Source def visit_classifier(self, node): self.body.append(' <span class= \"classifier-delimiter\" > : </span> ') self.body.append(self.starttag(node, 'span', '', CLASS='classifier'))","title":"visit_classifier"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_colspec","text":"def visit_colspec ( self , node ) View Source def visit_colspec(self, node): self.colspecs.append(node) # \"stubs\" list is an attribute of the tgroup element: node.parent.stubs.append(node.attributes.get('stub'))","title":"visit_colspec"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_comment","text":"def visit_comment ( self , node , sub =< built - in method sub of re . Pattern object at 0x0000024728A33500 > ) Escape double-dashes in comment text. View Source def visit_comment ( self , node , sub = re . compile ( '-(?=-)' ). sub ) : \"\"\"Escape double-dashes in comment text.\"\"\" self . body . append ( '<!-- %s -->\\n' % sub ( '- ' , node . astext ())) # Content already processed : raise nodes . SkipNode","title":"visit_comment"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_compound","text":"def visit_compound ( self , node ) View Source def visit_compound ( self , node ) : self . body . append ( self . starttag ( node , 'div' , CLASS ='compound' )) if len ( node ) > 1 : node [ 0 ][ 'classes' ]. append ( 'compound-first' ) node [ - 1 ][ 'classes' ]. append ( 'compound-last' ) for child in node [ 1 :- 1 ] : child [ 'classes' ]. append ( 'compound-middle' )","title":"visit_compound"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_contact","text":"def visit_contact ( self , node ) View Source def visit_contact(self, node): self.visit_docinfo_item(node, 'contact', meta=False)","title":"visit_contact"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_container","text":"def visit_container ( self , node ) View Source def visit_container(self, node): self.body.append(self.starttag(node, 'div', CLASS='docutils container'))","title":"visit_container"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_copyright","text":"def visit_copyright ( self , node ) View Source def visit_copyright(self, node): self.visit_docinfo_item(node, 'copyright')","title":"visit_copyright"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_date","text":"def visit_date ( self , node ) View Source def visit_date(self, node): self.visit_docinfo_item(node, 'date')","title":"visit_date"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_decoration","text":"def visit_decoration ( self , node ) View Source def visit_decoration(self, node): pass","title":"visit_decoration"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_definition","text":"def visit_definition ( self , node ) View Source def visit_definition(self, node): self.body.append('</dt>\\n') self.body.append(self.starttag(node, 'dd', '')) self.set_first_last(node)","title":"visit_definition"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_definition_list","text":"def visit_definition_list ( self , node ) View Source def visit_definition_list(self, node): self.body.append(self.starttag(node, 'dl', CLASS='docutils'))","title":"visit_definition_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_definition_list_item","text":"def visit_definition_list_item ( self , node ) View Source def visit_definition_list_item(self, node): # pass class arguments, ids and names to definition term: node.children[0]['classes'] = ( node.get('classes', []) + node.children[0].get('classes', [])) node.children[0]['ids'] = ( node.get('ids', []) + node.children[0].get('ids', [])) node.children[0]['names'] = ( node.get('names', []) + node.children[0].get('names', []))","title":"visit_definition_list_item"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_description","text":"def visit_description ( self , node ) View Source def visit_description(self, node): self.body.append(self.starttag(node, 'td', '')) self.set_first_last(node)","title":"visit_description"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_docinfo","text":"def visit_docinfo ( self , node ) View Source def visit_docinfo(self, node): self.context.append(len(self.body)) self.body.append(self.starttag(node, 'table', CLASS='docinfo', frame=\"void\", rules=\"none\")) self.body.append('<col class=\"docinfo-name\" />\\n' '<col class=\"docinfo-content\" />\\n' '<tbody valign=\"top\">\\n') self.in_docinfo = True","title":"visit_docinfo"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_docinfo_item","text":"def visit_docinfo_item ( self , node , name , meta = True ) View Source def visit_docinfo_item ( self , node , name , meta = True ) : if meta : meta_tag = '<meta name=\"%s\" content=\"%s\" />\\n' \\ % ( name , self . attval ( node . astext ())) self . add_meta ( meta_tag ) self . body . append ( self . starttag ( node , 'tr' , '' )) self . body . append ( '<th class=\"docinfo-name\">%s:</th>\\n<td>' % self . language . labels [ name ] ) if len ( node ) : if isinstance ( node [ 0 ] , nodes . Element ) : node [ 0 ][ 'classes' ] . append ( 'first' ) if isinstance ( node [ -1 ] , nodes . Element ) : node [ -1 ][ 'classes' ] . append ( 'last' )","title":"visit_docinfo_item"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_doctest_block","text":"def visit_doctest_block ( self , node ) View Source def visit_doctest_block(self, node): self.body.append(self.starttag(node, 'pre', CLASS='doctest-block'))","title":"visit_doctest_block"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_document","text":"def visit_document ( self , node ) View Source def visit_document(self, node): title = (node.get('title', '') or os.path.basename(node['source']) or 'docutils document without title') self.head.append(' <title> %s </title> \\n' % self.encode(title))","title":"visit_document"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_emphasis","text":"def visit_emphasis ( self , node ) View Source def visit_emphasis(self, node): self.body.append(self.starttag(node, 'em', ''))","title":"visit_emphasis"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_entry","text":"def visit_entry ( self , node ) View Source def visit_entry ( self , node ): writers . _html_base . HTMLTranslator . visit_entry ( self , node ) if len ( node ) == 0 : # empty cell self . body . append ( '&nbsp;' ) self . set_first_last ( node )","title":"visit_entry"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_enumerated_list","text":"def visit_enumerated_list ( self , node ) The 'start' attribute does not conform to HTML 4.01's strict.dtd, but cannot be emulated in CSS1 (HTML 5 reincludes it). View Source def visit_enumerated_list ( self , node ): \"\"\" The 'start' attribute does not conform to HTML 4.01's strict.dtd, but cannot be emulated in CSS1 (HTML 5 reincludes it). \"\"\" atts = {} if 'start' in node : atts [ 'start' ] = node [ 'start' ] if 'enumtype' in node : atts [ 'class' ] = node [ 'enumtype' ] # @@@ To do: prefix, suffix. How? Change prefix/suffix to a # single \"format\" attribute? Use CSS2? old_compact_simple = self . compact_simple self . context . append (( self . compact_simple , self . compact_p )) self . compact_p = None self . compact_simple = self . is_compactable ( node ) if self . compact_simple and not old_compact_simple : atts [ 'class' ] = ( atts . get ( 'class' , '' ) + ' simple' ) . strip () self . body . append ( self . starttag ( node , 'ol' , ** atts ))","title":"visit_enumerated_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_field","text":"def visit_field ( self , node ) View Source def visit_field(self, node): self.body.append(self.starttag(node, 'tr', '', CLASS='field'))","title":"visit_field"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_field_body","text":"def visit_field_body ( self , node ) View Source def visit_field_body ( self , node ) : self . body . append ( self . starttag ( node , ' td ' , '' , CLASS = ' field-body ' )) self . set_class_on_child ( node , ' first ' , 0 ) field = node . parent if ( self . compact_field_list or isinstance ( field . parent , nodes . docinfo ) or field . parent . index ( field ) == len ( field . parent ) - 1 ) : # If we are in a compact list , the docinfo , or if this is # the last field of the field list , do not add vertical # space after last element . self . set_class_on_child ( node , ' last ' , - 1 )","title":"visit_field_body"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_field_list","text":"def visit_field_list ( self , node ) View Source def visit_field_list ( self , node ) : self . context . append (( self . compact_field_list , self . compact_p )) self . compact_p = None if ' compact ' in node [ ' classes ' ]: self . compact_field_list = True elif ( self . settings . compact_field_lists and ' open ' not in node [ ' classes ' ] ) : self . compact_field_list = True if self . compact_field_list : for field in node : field_body = field [ - 1 ] assert isinstance ( field_body , nodes . field_body ) children = [ n for n in field_body if not isinstance ( n , nodes . Invisible ) ] if not ( len ( children ) == 0 or len ( children ) == 1 and isinstance ( children [ 0 ], ( nodes . paragraph , nodes . line_block ))) : self . compact_field_list = False break self . body . append ( self . starttag ( node , ' table ' , frame = ' void ' , rules = ' none ' , CLASS = ' docutils field-list ' )) self . body . append ( ' <col class=\"field-name\" /> \\n ' ' <col class=\"field-body\" /> \\n ' ' <tbody valign=\"top\"> \\n ' )","title":"visit_field_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_field_name","text":"def visit_field_name ( self , node ) View Source def visit_field_name(self, node): atts = {} if self.in_docinfo: atts['class'] = 'docinfo-name' else: atts['class'] = 'field-name' if ( self.settings.field_name_limit and len(node.astext()) > self.settings.field_name_limit): atts['colspan'] = 2 self.context.append(' </tr> \\n' + self.starttag(node.parent, 'tr', '', CLASS='field') + ' <td> &nbsp; </td> ') else: self.context.append('') self.body.append(self.starttag(node, 'th', '', **atts))","title":"visit_field_name"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_figure","text":"def visit_figure ( self , node ) View Source def visit_figure ( self , node ) : atts = { ' class ' : ' figure ' } if node . get ( ' width ' ) : atts [ ' style ' ] = ' width: %s ' % node [ ' width ' ] if node . get ( ' align ' ) : atts [ ' class ' ] += \" align- \" + node [ ' align ' ] self . body . append ( self . starttag ( node , ' div ' , ** atts ))","title":"visit_figure"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_footer","text":"def visit_footer ( self , node ) View Source def visit_footer(self, node): self.context.append(len(self.body))","title":"visit_footer"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_footnote","text":"def visit_footnote ( self , node ) View Source def visit_footnote(self, node): self.body.append(self.starttag(node, 'table', CLASS='docutils footnote', frame=\"void\", rules=\"none\")) self.body.append(' <colgroup><col class= \"label\" /><col /></colgroup> \\n' ' <tbody valign= \"top\" > \\n' ' <tr> ') self.footnote_backrefs(node)","title":"visit_footnote"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_footnote_reference","text":"def visit_footnote_reference ( self , node ) View Source def visit_footnote_reference(self, node): href = '#' + node['refid'] format = self.settings.footnote_references if format == 'brackets': suffix = '[' self.context.append(']') else: assert format == 'superscript' suffix = ' <sup> ' self.context.append(' </sup> ') self.body.append(self.starttag(node, 'a', suffix, CLASS='footnote-reference', href=href))","title":"visit_footnote_reference"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_generated","text":"def visit_generated ( self , node ) View Source def visit_generated(self, node): pass","title":"visit_generated"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_header","text":"def visit_header ( self , node ) View Source def visit_header(self, node): self.context.append(len(self.body))","title":"visit_header"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_image","text":"def visit_image ( self , node ) View Source def visit_image ( self , node ) : atts = {} uri = node [ 'uri' ] ext = os . path . splitext ( uri ) [ 1 ] . lower () if ext in self . object_image_types : atts [ 'data' ] = uri atts [ 'type' ] = self . object_image_types [ ext ] else : atts [ 'src' ] = uri atts [ 'alt' ] = node . get ( 'alt' , uri ) # image size if 'width' in node : atts [ 'width' ] = node [ 'width' ] if 'height' in node : atts [ 'height' ] = node [ 'height' ] if 'scale' in node : if ( PIL and not ( 'width' in node and 'height' in node ) and self . settings . file_insertion_enabled ) : imagepath = url2pathname ( uri ) try : img = PIL . Image . open ( imagepath . encode ( sys . getfilesystemencoding ())) except ( IOError , UnicodeEncodeError ) : pass # TODO : warn ? else : self . settings . record_dependencies . add ( imagepath . replace ( '\\\\' , '/' )) if 'width' not in atts : atts [ 'width' ] = '%dpx' % img . size [ 0 ] if 'height' not in atts : atts [ 'height' ] = '%dpx' % img . size [ 1 ] del img for att_name in 'width' , 'height' : if att_name in atts : match = re . match ( r '([0-9.]+)(\\S*)$' , atts [ att_name ] ) assert match atts [ att_name ] = '%s%s' % ( float ( match . group ( 1 )) * ( float ( node [ 'scale' ] ) / 100 ), match . group ( 2 )) style = [] for att_name in 'width' , 'height' : if att_name in atts : if re . match ( r '^[0-9.]+$' , atts [ att_name ] ) : # Interpret unitless values as pixels . atts [ att_name ] += 'px' style . append ( '%s: %s;' % ( att_name , atts [ att_name ] )) del atts [ att_name ] if style : atts [ 'style' ] = ' ' . join ( style ) if ( isinstance ( node . parent , nodes . TextElement ) or ( isinstance ( node . parent , nodes . reference ) and not isinstance ( node . parent . parent , nodes . TextElement ))) : # Inline context or surrounded by < a > ... </ a > . suffix = '' else : suffix = '\\n' if 'align' in node : atts [ 'class' ] = 'align-%s' % node [ 'align' ] if ext in self . object_image_types : # do NOT use an empty tag : incorrect rendering in browsers self . body . append ( self . starttag ( node , 'object' , '' , ** atts ) + node . get ( 'alt' , uri ) + '</object>' + suffix ) else : self . body . append ( self . emptytag ( node , 'img' , suffix , ** atts ))","title":"visit_image"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_inline","text":"def visit_inline ( self , node ) View Source def visit_inline(self, node): self.body.append(self.starttag(node, 'span', ''))","title":"visit_inline"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_label","text":"def visit_label ( self , node ) View Source def visit_label(self, node): self.body.append(self.starttag(node, 'td', '%s[' % self.context.pop(), CLASS='label'))","title":"visit_label"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_legend","text":"def visit_legend ( self , node ) View Source def visit_legend(self, node): self.body.append(self.starttag(node, 'div', CLASS='legend'))","title":"visit_legend"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_line","text":"def visit_line ( self , node ) View Source def visit_line ( self , node ) : self . body . append ( self . starttag ( node , ' div ' , suffix = '' , CLASS = ' line ' )) if not len ( node ) : self . body . append ( ' <br /> ' )","title":"visit_line"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_line_block","text":"def visit_line_block ( self , node ) View Source def visit_line_block(self, node): self.body.append(self.starttag(node, 'div', CLASS='line-block'))","title":"visit_line_block"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_list_item","text":"def visit_list_item ( self , node ) View Source def visit_list_item ( self , node ) : self . body . append ( self . starttag ( node , ' li ' , '' )) if len ( node ) : node [ 0 ][ ' classes ' ]. append ( ' first ' )","title":"visit_list_item"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_literal","text":"def visit_literal ( self , node ) View Source def visit_literal(self, node): # special case: \"code\" role classes = node.get('classes', []) if 'code' in classes: # filter 'code' from class arguments node['classes'] = [cls for cls in classes if cls != 'code'] self.body.append(self.starttag(node, 'code', '')) return self.body.append( self.starttag(node, 'tt', '', CLASS='docutils literal')) text = node.astext() for token in self.words_and_spaces.findall(text): if token.strip(): # Protect text like \"--an-option\" and the regular expression # ``[+]?(\\d+(\\.\\d*)?|\\.\\d+)`` from bad line wrapping if self.in_word_wrap_point.search(token): self.body.append(' <span class= \"pre\" > %s </span> ' % self.encode(token)) else: self.body.append(self.encode(token)) elif token in ('\\n', ' '): # Allow breaks at whitespace: self.body.append(token) else: # Protect runs of multiple spaces; the last space can wrap: self.body.append(' &nbsp; ' * (len(token) - 1) + ' ') self.body.append(' </tt> ') # Content already processed: raise nodes.SkipNode","title":"visit_literal"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_literal_block","text":"def visit_literal_block ( self , node ) View Source def visit_literal_block(self, node): self.body.append(self.starttag(node, 'pre', CLASS='literal-block'))","title":"visit_literal_block"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_math","text":"def visit_math ( self , node , math_env = '' ) View Source def visit_math ( self , node , math_env = '' ) : # If the method is called from visit_math_block (), math_env != '' . if self . math_output not in self . math_tags : self . document . reporter . error ( 'math-output format \" % s \" not supported ' 'falling back to \" latex \"' % self . math_output ) self . math_output = 'latex' tag = self . math_tags [ self . math_output ][ math_env == '' ] clsarg = self . math_tags [ self . math_output ][ 2 ] # LaTeX container wrappers = { # math_mode : ( inline , block ) 'mathml' : ( '$%s$' , u '\\\\begin{%s}\\n%s\\n\\\\end{%s}' ), 'html' : ( '$%s$' , u '\\\\begin{%s}\\n%s\\n\\\\end{%s}' ), 'mathjax' : ( r '\\(%s\\)' , u '\\\\begin{%s}\\n%s\\n\\\\end{%s}' ), 'latex' : ( None , None ), } wrapper = wrappers [ self . math_output ][ math_env != '' ] if self . math_output == 'mathml' and ( not self . math_output_options or self . math_output_options [ 0 ] == 'blahtexml' ) : wrapper = None # get and wrap content math_code = node . astext (). translate ( unichar2tex . uni2tex_table ) if wrapper : try : # wrapper with three \"%s\" math_code = wrapper % ( math_env , math_code , math_env ) except TypeError : # wrapper with one \"%s\" math_code = wrapper % math_code # settings and conversion if self . math_output in ( 'latex' , 'mathjax' ) : math_code = self . encode ( math_code ) if self . math_output == 'mathjax' and not self . math_header : try : self . mathjax_url = self . math_output_options [ 0 ] except IndexError : self . document . reporter . warning ( 'No MathJax URL specified, ' 'using local fallback (see config.html)' ) # append configuration , if not already present in the URL : # input LaTeX with AMS , output common HTML if '?' not in self . mathjax_url : self . mathjax_url += '?config=TeX-AMS_CHTML' self . math_header = [ self . mathjax_script % self . mathjax_url ] elif self . math_output == 'html' : if self . math_output_options and not self . math_header : self . math_header = [ self . stylesheet_call ( utils . find_file_in_dirs ( s , self . settings . stylesheet_dirs )) for s in self . math_output_options [ 0 ]. split ( ',' )] # TODO : fix display mode in matrices and fractions math2html . DocumentParameters . displaymode = ( math_env != '' ) math_code = math2html . math2html ( math_code ) elif self . math_output == 'mathml' : if 'XHTML 1' in self . doctype : self . doctype = self . doctype_mathml self . content_type = self . content_type_mathml converter = ' ' . join ( self . math_output_options ). lower () try : if converter == 'latexml' : math_code = tex2mathml_extern . latexml ( math_code , self . document . reporter ) elif converter == 'ttm' : math_code = tex2mathml_extern . ttm ( math_code , self . document . reporter ) elif converter == 'blahtexml' : math_code = tex2mathml_extern . blahtexml ( math_code , inline = not ( math_env ), reporter = self . document . reporter ) elif not converter : math_code = latex2mathml . tex2mathml ( math_code , inline = not ( math_env )) else : self . document . reporter . error ( 'option \" % s \" not supported ' 'with math-output \" MathML \"' ) except OSError : raise OSError ( 'is \" latexmlmath \" in your PATH?' ) except SyntaxError as err : err_node = self . document . reporter . error ( err , base_node = node ) self . visit_system_message ( err_node ) self . body . append ( self . starttag ( node , 'p' )) self . body . append ( u ',' . join ( err . args )) self . body . append ( '</p>\\n' ) self . body . append ( self . starttag ( node , 'pre' , CLASS = 'literal-block' )) self . body . append ( self . encode ( math_code )) self . body . append ( '\\n</pre>\\n' ) self . depart_system_message ( err_node ) raise nodes . SkipNode # append to document body if tag : self . body . append ( self . starttag ( node , tag , suffix = '\\n' * bool ( math_env ), CLASS = clsarg )) self . body . append ( math_code ) if math_env : # block mode ( equation , display ) self . body . append ( '\\n' ) if tag : self . body . append ( '<!--%s-->' % tag ) if math_env : self . body . append ( '\\n' ) # Content already processed : raise nodes . SkipNode","title":"visit_math"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_math_block","text":"def visit_math_block ( self , node ) View Source def visit_math_block(self, node): math_env = pick_math_environment(node.astext()) self.visit_math(node, math_env=math_env)","title":"visit_math_block"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_meta","text":"def visit_meta ( self , node ) View Source def visit_meta(self, node): meta = self.emptytag(node, 'meta', **node.non_default_attributes()) self.add_meta(meta)","title":"visit_meta"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_option","text":"def visit_option ( self , node ) View Source def visit_option(self, node): self.body.append(self.starttag(node, 'span', '', CLASS='option'))","title":"visit_option"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_option_argument","text":"def visit_option_argument ( self , node ) View Source def visit_option_argument ( self , node ): self . body . append ( node . get ( 'delimiter' , ' ' )) self . body . append ( self . starttag ( node , 'var' , '' ))","title":"visit_option_argument"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_option_group","text":"def visit_option_group ( self , node ) View Source def visit_option_group(self, node): atts = {} if ( self.settings.option_limit and len(node.astext()) > self.settings.option_limit): atts['colspan'] = 2 self.context.append(' </tr> \\n <tr><td> &nbsp; </td> ') else: self.context.append('') self.body.append( self.starttag(node, 'td', CLASS='option-group', **atts)) self.body.append(' <kbd> ') self.context.append(0) # count number of options","title":"visit_option_group"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_option_list","text":"def visit_option_list ( self , node ) View Source def visit_option_list(self, node): self.body.append( self.starttag(node, 'table', CLASS='docutils option-list', frame=\"void\", rules=\"none\")) self.body.append('<col class=\"option\" />\\n' '<col class=\"description\" />\\n' '<tbody valign=\"top\">\\n')","title":"visit_option_list"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_option_list_item","text":"def visit_option_list_item ( self , node ) View Source def visit_option_list_item(self, node): self.body.append(self.starttag(node, 'tr', ''))","title":"visit_option_list_item"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_option_string","text":"def visit_option_string ( self , node ) View Source def visit_option_string(self, node): pass","title":"visit_option_string"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_organization","text":"def visit_organization ( self , node ) View Source def visit_organization(self, node): self.visit_docinfo_item(node, 'organization')","title":"visit_organization"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_paragraph","text":"def visit_paragraph ( self , node ) View Source def visit_paragraph ( self , node ) : if self . should_be_compact_paragraph ( node ) : self . context . append ( '' ) else : self . body . append ( self . starttag ( node , ' p ' , '' )) self . context . append ( ' </p> \\n ' )","title":"visit_paragraph"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_problematic","text":"def visit_problematic ( self , node ) View Source def visit_problematic(self, node): if node.hasattr('refid'): self.body.append(' <a href= \"#%s\" > ' % node['refid']) self.context.append(' </a> ') else: self.context.append('') self.body.append(self.starttag(node, 'span', '', CLASS='problematic'))","title":"visit_problematic"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_raw","text":"def visit_raw ( self , node ) View Source def visit_raw ( self , node ) : if 'html' in node . get ( 'format' , '' ). split () : t = isinstance ( node . parent , nodes . TextElement ) and 'span' or 'div' if node [ 'classes' ] : self . body . append ( self . starttag ( node , t , suffix = '' )) self . body . append ( node . astext ()) if node [ 'classes' ] : self . body . append ( '<!--%s-->' % t ) # Keep non - HTML raw text out of output : raise nodes . SkipNode","title":"visit_raw"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_reference","text":"def visit_reference ( self , node ) View Source def visit_reference ( self , node ) : atts = { ' class ' : ' reference ' } if ' refuri ' in node : atts [ ' href ' ] = node [ ' refuri ' ] if ( self . settings . cloak_email_addresses and atts [ ' href ' ]. startswith ( ' mailto: ' )) : atts [ ' href ' ] = self . cloak_mailto ( atts [ ' href ' ] ) self . in_mailto = True atts [ ' class ' ] += ' external ' else : assert ' refid ' in node , \\ ' References must have \"refuri\" or \"refid\" attribute. ' atts [ ' href ' ] = ' # ' + node [ ' refid ' ] atts [ ' class ' ] += ' internal ' if len ( node ) == 1 and isinstance ( node [ 0 ], nodes . image ) : atts [ ' class ' ] += ' image-reference ' if not isinstance ( node . parent , nodes . TextElement ) : assert len ( node ) == 1 and isinstance ( node [ 0 ], nodes . image ) atts [ ' class ' ] += ' image-reference ' self . body . append ( self . starttag ( node , ' a ' , '' , ** atts ))","title":"visit_reference"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_revision","text":"def visit_revision ( self , node ) View Source def visit_revision(self, node): self.visit_docinfo_item(node, 'revision', meta=False)","title":"visit_revision"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_row","text":"def visit_row ( self , node ) View Source def visit_row(self, node): self.body.append(self.starttag(node, 'tr', '')) node.column = 0","title":"visit_row"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_rubric","text":"def visit_rubric ( self , node ) View Source def visit_rubric(self, node): self.body.append(self.starttag(node, 'p', '', CLASS='rubric'))","title":"visit_rubric"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_section","text":"def visit_section ( self , node ) View Source def visit_section(self, node): self.section_level += 1 self.body.append( self.starttag(node, 'div', CLASS='section'))","title":"visit_section"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_sidebar","text":"def visit_sidebar ( self , node ) View Source def visit_sidebar(self, node): self.body.append( self.starttag(node, 'div', CLASS='sidebar')) self.set_first_last(node) self.in_sidebar = True","title":"visit_sidebar"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_status","text":"def visit_status ( self , node ) View Source def visit_status(self, node): self.visit_docinfo_item(node, 'status', meta=False)","title":"visit_status"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_strong","text":"def visit_strong ( self , node ) View Source def visit_strong(self, node): self.body.append(self.starttag(node, 'strong', ''))","title":"visit_strong"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_subscript","text":"def visit_subscript ( self , node ) View Source def visit_subscript ( self , node ) : if isinstance ( node . parent , nodes . literal_block ) : self . body . append ( self . starttag ( node , ' span ' , '' , CLASS = ' subscript ' )) else : self . body . append ( self . starttag ( node , ' sub ' , '' ))","title":"visit_subscript"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_substitution_definition","text":"def visit_substitution_definition ( self , node ) Internal only. View Source def visit_substitution_definition(self, node): \"\"\"Internal only.\"\"\" raise nodes.SkipNode","title":"visit_substitution_definition"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_substitution_reference","text":"def visit_substitution_reference ( self , node ) View Source def visit_substitution_reference(self, node): self.unimplemented_visit(node)","title":"visit_substitution_reference"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_subtitle","text":"def visit_subtitle ( self , node ) View Source def visit_subtitle(self, node): if isinstance(node.parent, nodes.sidebar): self.body.append(self.starttag(node, 'p', '', CLASS='sidebar-subtitle')) self.context.append(' </p> \\n') elif isinstance(node.parent, nodes.document): self.body.append(self.starttag(node, 'h2', '', CLASS='subtitle')) self.context.append(' </h2> \\n') self.in_document_title = len(self.body) elif isinstance(node.parent, nodes.section): tag = 'h%s' % (self.section_level + self.initial_header_level - 1) self.body.append( self.starttag(node, tag, '', CLASS='section-subtitle') + self.starttag({}, 'span', '', CLASS='section-subtitle')) self.context.append(' </span> <!--%s--> \\n' % tag)","title":"visit_subtitle"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_superscript","text":"def visit_superscript ( self , node ) View Source def visit_superscript ( self , node ) : if isinstance ( node . parent , nodes . literal_block ) : self . body . append ( self . starttag ( node , ' span ' , '' , CLASS = ' superscript ' )) else : self . body . append ( self . starttag ( node , ' sup ' , '' ))","title":"visit_superscript"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_system_message","text":"def visit_system_message ( self , node ) View Source def visit_system_message(self, node): self.body.append(self.starttag(node, 'div', CLASS='system-message')) self.body.append(' <p class= \"system-message-title\" > ') backref_text = '' if len(node['backrefs']): backrefs = node['backrefs'] if len(backrefs) == 1: backref_text = ('; <em><a href= \"#%s\" > backlink </a></em> ' % backrefs[0]) else: i = 1 backlinks = [] for backref in backrefs: backlinks.append(' <a href= \"#%s\" > %s </a> ' % (backref, i)) i += 1 backref_text = ('; <em> backlinks: %s </em> ' % ', '.join(backlinks)) if node.hasattr('line'): line = ', line %s' % node['line'] else: line = '' self.body.append('System Message: %s/%s ' '( <tt class= \"docutils\" > %s </tt> %s)%s </p> \\n' % (node['type'], node['level'], self.encode(node['source']), line, backref_text))","title":"visit_system_message"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_table","text":"def visit_table ( self , node ) View Source def visit_table ( self , node ) : self . context . append ( self . compact_p ) self . compact_p = True atts = { ' border ' : 1 } classes = [ ' docutils ' , self . settings . table_style ] if ' align ' in node : classes . append ( ' align-%s ' % node [ ' align ' ] ) if ' width ' in node : atts [ ' style ' ] = ' width: %s ' % node [ ' width ' ] self . body . append ( self . starttag ( node , ' table ' , CLASS = ' ' . join ( classes ) , ** atts ))","title":"visit_table"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_target","text":"def visit_target ( self , node ) View Source def visit_target ( self , node ) : if not ( ' refuri ' in node or ' refid ' in node or ' refname ' in node ) : self . body . append ( self . starttag ( node , ' span ' , '' , CLASS = ' target ' )) self . context . append ( ' </span> ' ) else : self . context . append ( '' )","title":"visit_target"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_tbody","text":"def visit_tbody ( self , node ) View Source def visit_tbody(self, node): self.body.append(self.starttag(node, 'tbody', valign='top'))","title":"visit_tbody"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_term","text":"def visit_term ( self , node ) View Source def visit_term(self, node): self.body.append(self.starttag(node, 'dt', ''))","title":"visit_term"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_tgroup","text":"def visit_tgroup ( self , node ) View Source def visit_tgroup(self, node): self.colspecs = [] node.stubs = []","title":"visit_tgroup"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_thead","text":"def visit_thead ( self , node ) View Source def visit_thead(self, node): self.body.append(self.starttag(node, 'thead', valign='bottom'))","title":"visit_thead"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_title","text":"def visit_title ( self , node ) Only 6 section levels are supported by HTML. View Source def visit_title(self, node): \"\"\"Only 6 section levels are supported by HTML.\"\"\" close_tag = ' </p> \\n' if isinstance(node.parent, nodes.topic): self.body.append( self.starttag(node, 'p', '', CLASS='topic-title')) elif isinstance(node.parent, nodes.sidebar): self.body.append( self.starttag(node, 'p', '', CLASS='sidebar-title')) elif isinstance(node.parent, nodes.Admonition): self.body.append( self.starttag(node, 'p', '', CLASS='admonition-title')) elif isinstance(node.parent, nodes.table): self.body.append( self.starttag(node, 'caption', '')) close_tag = ' </caption> \\n' elif isinstance(node.parent, nodes.document): self.body.append(self.starttag(node, 'h1', '', CLASS='title')) close_tag = ' </h1> \\n' self.in_document_title = len(self.body) else: assert isinstance(node.parent, nodes.section) h_level = self.section_level + self.initial_header_level - 1 atts = {} if (len(node.parent) >= 2 and isinstance(node.parent[1], nodes.subtitle)): atts['CLASS'] = 'with-subtitle' self.body.append( self.starttag(node, 'h%s' % h_level, '', **atts)) atts = {} if node.hasattr('refid'): atts['class'] = 'toc-backref' atts['href'] = '#' + node['refid'] if atts: self.body.append(self.starttag({}, 'a', '', **atts)) close_tag = ' </a> < /h%s>\\n' % (h_level) else: close_tag = ' < /h%s>\\n' % (h_level) self.context.append(close_tag)","title":"visit_title"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_title_reference","text":"def visit_title_reference ( self , node ) View Source def visit_title_reference(self, node): self.body.append(self.starttag(node, 'cite', ''))","title":"visit_title_reference"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_topic","text":"def visit_topic ( self , node ) View Source def visit_topic(self, node): self.body.append(self.starttag(node, 'div', CLASS='topic')) self.topic_classes = node['classes']","title":"visit_topic"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_transition","text":"def visit_transition ( self , node ) View Source def visit_transition(self, node): self.body.append(self.emptytag(node, 'hr', CLASS='docutils'))","title":"visit_transition"},{"location":"reference/pydoc_fork/reporter/rst_support/#visit_version","text":"def visit_version ( self , node ) View Source def visit_version(self, node): self.visit_docinfo_item(node, 'version', meta=False)","title":"visit_version"},{"location":"reference/pydoc_fork/reporter/string_utils/","text":"Module pydoc_fork.reporter.string_utils String manipulation None View Source \"\"\" String manipulation \"\"\" import logging import re LOGGER = logging . getLogger ( __name__ ) def replace ( text : str , * pairs : str ) -> str : \"\"\"Do a series of global replacements on a string. >>> replace(\"abc xyz\", \"xyz\", \"abc\") 'abc abc' \"\"\" while pairs : text = pairs [ 1 ] . join ( text . split ( pairs [ 0 ])) pairs = pairs [ 2 :] return text def cram ( text : str , maximum_length : int ) -> str : \"\"\"Omit part of a string if needed to make it fit in a maximum length.\"\"\" if len ( text ) > maximum_length : pre = max ( 0 , ( maximum_length - 3 ) // 2 ) post = max ( 0 , maximum_length - 3 - pre ) return text [: pre ] + \"...\" + text [ len ( text ) - post :] return text _re_stripid = re . compile ( r \" at 0x[0-9a-f]{6,16}(>+)$\" , re . IGNORECASE ) def stripid ( text : str ) -> str : \"\"\"Remove the hexadecimal id from a Python object representation.\"\"\" # The behaviour of %p is implementation-dependent in terms of case. return _re_stripid . sub ( r \"\\1\" , text ) Variables LOGGER Functions cram def cram ( text : str , maximum_length : int ) -> str Omit part of a string if needed to make it fit in a maximum length. View Source def cram ( text : str , maximum_length : int ) -> str : \"\"\"Omit part of a string if needed to make it fit in a maximum length.\"\"\" if len ( text ) > maximum_length : pre = max ( 0 , ( maximum_length - 3 ) // 2) post = max ( 0 , maximum_length - 3 - pre ) return text [ : pre ] + \"...\" + text [ len ( text ) - post : ] return text replace def replace ( text : str , * pairs : str ) -> str Do a series of global replacements on a string. replace(\"abc xyz\", \"xyz\", \"abc\") 'abc abc' View Source def replace ( text : str , * pairs : str ) -> str : \"\"\"Do a series of global replacements on a string. >>> replace(\" abc xyz \", \" xyz \", \" abc \") ' abc abc ' \"\"\" while pairs : text = pairs [ 1 ]. join ( text . split ( pairs [ 0 ])) pairs = pairs [ 2 : ] return text stripid def stripid ( text : str ) -> str Remove the hexadecimal id from a Python object representation. View Source def stripid ( text: str ) -> str: \"\"\"Remove the hexadecimal id from a Python object representation.\"\"\" # The behaviour of %p is implementation-dependent in terms of case. return _re_stripid . sub ( r \"\\1\" , text )","title":"String Utils"},{"location":"reference/pydoc_fork/reporter/string_utils/#module-pydoc_forkreporterstring_utils","text":"String manipulation None View Source \"\"\" String manipulation \"\"\" import logging import re LOGGER = logging . getLogger ( __name__ ) def replace ( text : str , * pairs : str ) -> str : \"\"\"Do a series of global replacements on a string. >>> replace(\"abc xyz\", \"xyz\", \"abc\") 'abc abc' \"\"\" while pairs : text = pairs [ 1 ] . join ( text . split ( pairs [ 0 ])) pairs = pairs [ 2 :] return text def cram ( text : str , maximum_length : int ) -> str : \"\"\"Omit part of a string if needed to make it fit in a maximum length.\"\"\" if len ( text ) > maximum_length : pre = max ( 0 , ( maximum_length - 3 ) // 2 ) post = max ( 0 , maximum_length - 3 - pre ) return text [: pre ] + \"...\" + text [ len ( text ) - post :] return text _re_stripid = re . compile ( r \" at 0x[0-9a-f]{6,16}(>+)$\" , re . IGNORECASE ) def stripid ( text : str ) -> str : \"\"\"Remove the hexadecimal id from a Python object representation.\"\"\" # The behaviour of %p is implementation-dependent in terms of case. return _re_stripid . sub ( r \"\\1\" , text )","title":"Module pydoc_fork.reporter.string_utils"},{"location":"reference/pydoc_fork/reporter/string_utils/#variables","text":"LOGGER","title":"Variables"},{"location":"reference/pydoc_fork/reporter/string_utils/#functions","text":"","title":"Functions"},{"location":"reference/pydoc_fork/reporter/string_utils/#cram","text":"def cram ( text : str , maximum_length : int ) -> str Omit part of a string if needed to make it fit in a maximum length. View Source def cram ( text : str , maximum_length : int ) -> str : \"\"\"Omit part of a string if needed to make it fit in a maximum length.\"\"\" if len ( text ) > maximum_length : pre = max ( 0 , ( maximum_length - 3 ) // 2) post = max ( 0 , maximum_length - 3 - pre ) return text [ : pre ] + \"...\" + text [ len ( text ) - post : ] return text","title":"cram"},{"location":"reference/pydoc_fork/reporter/string_utils/#replace","text":"def replace ( text : str , * pairs : str ) -> str Do a series of global replacements on a string. replace(\"abc xyz\", \"xyz\", \"abc\") 'abc abc' View Source def replace ( text : str , * pairs : str ) -> str : \"\"\"Do a series of global replacements on a string. >>> replace(\" abc xyz \", \" xyz \", \" abc \") ' abc abc ' \"\"\" while pairs : text = pairs [ 1 ]. join ( text . split ( pairs [ 0 ])) pairs = pairs [ 2 : ] return text","title":"replace"},{"location":"reference/pydoc_fork/reporter/string_utils/#stripid","text":"def stripid ( text : str ) -> str Remove the hexadecimal id from a Python object representation. View Source def stripid ( text: str ) -> str: \"\"\"Remove the hexadecimal id from a Python object representation.\"\"\" # The behaviour of %p is implementation-dependent in terms of case. return _re_stripid . sub ( r \"\\1\" , text )","title":"stripid"}]}
